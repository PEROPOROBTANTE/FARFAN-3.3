# üó∫Ô∏è ROADMAP DE IMPLEMENTACI√ìN - FARFAN 3.0

**Documento de Planificaci√≥n Estrat√©gica**  
**Fecha:** 16 de Octubre, 2025  
**Versi√≥n:** 1.0

---

## üéØ OBJETIVO

Llevar FARFAN 3.0 desde su estado actual (75-80% completitud) a un **sistema production-ready** que pueda analizar 170 planes de desarrollo territorial con el cuestionario de 300 preguntas.

---

## üìä SITUACI√ìN ACTUAL

### Estado General: **75-80% COMPLETO**

**‚úÖ Lo que funciona:**
- Arquitectura orquestador (100%)
- Sistema de enrutamiento (100%)
- Circuit breaker (100%)
- Documentaci√≥n t√©cnica (90%)
- 3 de 8 m√≥dulos core (policy_processor, causal_proccesor, financiero_viabilidad_tablas)

**‚ùå Lo que falta:**
- M√≥dulo Derek Beach (cr√≠tico)
- Dependencias completas
- Correcci√≥n de errores de sintaxis
- Sistema de pruebas
- Web Dashboard

---

## üöÄ FASES DE IMPLEMENTACI√ìN

### **FASE 0: EVALUACI√ìN Y DECISIONES CR√çTICAS** (1 d√≠a)

**Objetivo:** Resolver inc√≥gnitas que bloquean planificaci√≥n.

#### Tareas:

1. **Localizar Derek Beach Module** üî¥
   - [ ] Revisar historial de commits en busca de referencias
   - [ ] Buscar en repositorios relacionados del usuario
   - [ ] Revisar si hay issues/PRs que mencionen "derek" o "beach"
   - [ ] Contactar al autor original del c√≥digo
   - [ ] **DECISI√ìN:** ¬øExiste el m√≥dulo? ‚Üí Determina timeline

2. **Validar Entorno de Desarrollo**
   - [ ] Crear entorno virtual limpio
   - [ ] Instalar `requirements_complete.txt`
   - [ ] Documentar problemas de instalaci√≥n
   - [ ] Resolver conflictos de dependencias

3. **Definir Scope M√≠nimo Viable**
   - [ ] ¬øCu√°ntas preguntas DEBEN funcionar? (m√≠nimo: 50/300)
   - [ ] ¬øQu√© dimensiones son prioritarias? (D1, D2, D6)
   - [ ] ¬øCu√°ntos planes en la prueba piloto? (recomendado: 5-10)

**Entregables:**
- Documento de decisiones t√©cnicas
- Plan de implementaci√≥n detallado (este o actualizado)
- Entorno de desarrollo funcional

---

### **FASE 1: FUNDAMENTOS S√ìLIDOS** (3-5 d√≠as)

**Objetivo:** Eliminar blockers t√©cnicos b√°sicos.

#### 1.1 Completar Dependencias (D√≠a 1) üî¥

- [ ] Reemplazar `requirements.txt` con `requirements_complete.txt`
- [ ] Instalar todas las dependencias en entorno limpio
- [ ] Descargar modelo spaCy espa√±ol: `es_core_news_lg`
- [ ] Descargar datos NLTK necesarios
- [ ] Probar importaciones de todos los m√≥dulos
- [ ] Documentar versiones exactas que funcionan

**Script de validaci√≥n:**
```bash
#!/bin/bash
# validate_dependencies.sh

echo "Testing module imports..."
python3 -c "
import sys
modules = [
    'policy_processor',
    'causal_proccesor',
    'Analyzer_one',
    'contradiction_deteccion',
    'emebedding_policy',
    'financiero_viabilidad_tablas',
    'policy_segmenter',
    'semantic_chunking_policy'
]

failed = []
for mod in modules:
    try:
        __import__(mod)
        print(f'‚úì {mod}')
    except Exception as e:
        print(f'‚úó {mod}: {e}')
        failed.append(mod)

if failed:
    print(f'\n{len(failed)} modules failed')
    sys.exit(1)
else:
    print('\n‚úì All modules imported successfully')
"
```

#### 1.2 Corregir Errores de Sintaxis (D√≠a 1-2) üü°

**Analyzer_one.py:**
- [ ] Identificar la l√≠nea con `NameError`
- [ ] Corregir definici√≥n/import de `MunicipalAnalyzer`
- [ ] Validar con `python -m py_compile Analyzer_one.py`

**contradiction_deteccion.py:**
- [ ] Encontrar par√©ntesis sin cerrar
- [ ] Ejecutar linter: `pylint contradiction_deteccion.py`
- [ ] Corregir y validar

**semantic_chunking_policy.py:**
- [ ] Identificar funciones vac√≠as
- [ ] Agregar `pass` o implementaci√≥n stub
- [ ] Validar sintaxis

**Script de validaci√≥n:**
```bash
#!/bin/bash
# validate_syntax.sh

for file in *.py; do
    echo "Checking $file..."
    python3 -m py_compile "$file"
    if [ $? -eq 0 ]; then
        echo "‚úì $file"
    else
        echo "‚úó $file FAILED"
        exit 1
    fi
done

echo "‚úì All Python files have valid syntax"
```

#### 1.3 Resolver Derek Beach (D√≠a 2-5) üî¥

**Opci√≥n A: Si existe y es compatible (2 d√≠as)**
- [ ] Integrar como subm√≥dulo Git o copiar c√≥digo
- [ ] Verificar compatibilidad de APIs
- [ ] Actualizar imports en `module_adapters.py`
- [ ] Probar instanciaci√≥n de clases principales
- [ ] Ejecutar m√©todos clave con datos de prueba

**Opci√≥n B: Si existe pero necesita adaptaci√≥n (3-4 d√≠as)**
- [ ] Integrar c√≥digo base
- [ ] Crear capa de adaptaci√≥n
- [ ] Implementar interfaces requeridas
- [ ] Pruebas de integraci√≥n

**Opci√≥n C: Si no existe - crear stub temporal (1 d√≠a)**
- [ ] Crear estructura de carpeta `dereck_beach/`
- [ ] Implementar stubs para 26 clases
- [ ] Retornar datos mock estructurados
- [ ] Documentar funcionalidad faltante
- [ ] Planificar implementaci√≥n completa (Fase 3)

**Estructura del stub:**
```python
# dereck_beach/__init__.py

class CDAFFramework:
    def __init__(self, config_path, logger=None):
        self.logger = logger
        print("‚ö†Ô∏è  Using STUB implementation of Derek Beach")
    
    def process_document(self, pdf_path_or_text, plan_name):
        return {
            "status": "stub",
            "causal_hierarchy": None,
            "mechanism_inferences": [],
            "financial_audit": {"stub": True},
            "confidence": 0.5,
            "message": "Derek Beach stub - implement real logic"
        }

# ... repetir para las otras 25 clases
```

**Entregables Fase 1:**
- ‚úÖ Todos los m√≥dulos importables
- ‚úÖ Cero errores de sintaxis
- ‚úÖ Derek Beach stub o integrado
- ‚úÖ Script de validaci√≥n de entorno

---

### **FASE 2: INTEGRACI√ìN Y PRUEBAS** (5-7 d√≠as)

**Objetivo:** Validar que el sistema funciona end-to-end.

#### 2.1 Crear Suite de Pruebas B√°sicas (D√≠a 6-7)

**Estructura de tests:**
```
tests/
‚îú‚îÄ‚îÄ __init__.py
‚îú‚îÄ‚îÄ conftest.py                 # Fixtures compartidas
‚îú‚îÄ‚îÄ test_orchestrator.py        # Pruebas del orquestador
‚îú‚îÄ‚îÄ test_question_routing.py    # Pruebas de enrutamiento
‚îú‚îÄ‚îÄ test_modules_import.py      # Validar importaciones
‚îú‚îÄ‚îÄ test_single_question.py     # Ejecutar 1 pregunta
‚îú‚îÄ‚îÄ test_dimension_execution.py # Ejecutar 1 dimensi√≥n completa
‚îî‚îÄ‚îÄ fixtures/
    ‚îú‚îÄ‚îÄ sample_plan.txt         # Plan de prueba
    ‚îî‚îÄ‚îÄ expected_results.json   # Resultados esperados
```

**Pruebas cr√≠ticas:**

1. **test_orchestrator.py:**
```python
import pytest
from orchestrator import FARFANOrchestrator

def test_orchestrator_initialization():
    """Verifica que el orquestador se inicializa correctamente."""
    orch = FARFANOrchestrator()
    assert orch is not None
    assert orch.router is not None
    assert orch.choreographer is not None
    assert orch.circuit_breaker is not None

def test_system_health():
    """Verifica que el sistema reporta estado de salud."""
    orch = FARFANOrchestrator()
    health = orch.get_system_health()
    assert "circuit_breaker" in health
    assert "execution_stats" in health
```

2. **test_single_question.py:**
```python
def test_answer_single_question(sample_plan_text):
    """Prueba end-to-end de 1 pregunta."""
    orch = FARFANOrchestrator()
    
    result = orch.answer_single_question(
        question_id="P1-D1-Q1",
        plan_text=sample_plan_text,
        plan_name="Test Plan"
    )
    
    assert result is not None
    assert result["question_id"] == "P1-D1-Q1"
    assert "confidence" in result
    assert result["confidence"] >= 0.0
    assert result["confidence"] <= 1.0
    assert "evidence" in result
```

#### 2.2 Ejecutar Pruebas Incrementales (D√≠a 8-9)

**Progresi√≥n de pruebas:**

1. **Nivel 1: Importaciones**
   ```bash
   pytest tests/test_modules_import.py -v
   ```
   - Objetivo: 100% de m√≥dulos importables

2. **Nivel 2: Componentes individuales**
   ```bash
   pytest tests/test_orchestrator.py -v
   pytest tests/test_question_routing.py -v
   ```
   - Objetivo: Cada componente funciona aislado

3. **Nivel 3: Una pregunta**
   ```bash
   pytest tests/test_single_question.py -v
   ```
   - Objetivo: Pipeline completo P1-D1-Q1

4. **Nivel 4: Una dimensi√≥n completa**
   ```bash
   pytest tests/test_dimension_execution.py::test_dimension_D1 -v
   ```
   - Objetivo: Todas las preguntas de D1 (50 preguntas)

5. **Nivel 5: Plan completo (300 preguntas)**
   ```bash
   pytest tests/test_full_plan.py -v --timeout=600
   ```
   - Objetivo: An√°lisis completo de 1 plan

#### 2.3 Corregir Bugs de Integraci√≥n (D√≠a 10-12)

Bas√°ndose en los resultados de las pruebas:

- [ ] Documentar cada fallo
- [ ] Priorizar por severidad
- [ ] Corregir bugs cr√≠ticos primero
- [ ] Re-ejecutar pruebas despu√©s de cada correcci√≥n
- [ ] Actualizar tests si es necesario

**Estrategia de debugging:**
1. Aislar el m√≥dulo/m√©todo problem√°tico
2. Crear test espec√≠fico para reproducir
3. Usar debugger o logs detallados
4. Corregir c√≥digo
5. Validar que no se rompi√≥ nada m√°s

**Entregables Fase 2:**
- ‚úÖ Suite de pruebas con >70% cobertura cr√≠tica
- ‚úÖ Al menos 1 pregunta funcionando end-to-end
- ‚úÖ Al menos 1 dimensi√≥n funcionando completa
- ‚úÖ Documentaci√≥n de bugs conocidos

---

### **FASE 3: OPTIMIZACI√ìN Y VALIDACI√ìN** (7-10 d√≠as)

**Objetivo:** Validar con datos reales y optimizar rendimiento.

#### 3.1 Validaci√≥n con Planes Reales (D√≠a 13-15)

**Plan piloto:**

1. **Seleccionar 5 planes de prueba:**
   - 1 plan excelente (caso ideal)
   - 2 planes buenos (casos normales)
   - 1 plan deficiente (caso problem√°tico)
   - 1 plan at√≠pico (edge case)

2. **Ejecutar an√°lisis completo:**
   ```bash
   python run_farfan.py --plan plan1.pdf --output results/plan1/
   python run_farfan.py --plan plan2.pdf --output results/plan2/
   # ... etc
   ```

3. **M√©tricas a recopilar:**
   - Tiempo de ejecuci√≥n total
   - Tiempo por pregunta (promedio, min, max)
   - Tasa de √©xito por dimensi√≥n
   - Confianza promedio por dimensi√≥n
   - Errores/warnings generados

4. **Validaci√≥n de resultados:**
   - [ ] ¬øLas respuestas tienen sentido?
   - [ ] ¬øLa evidencia es relevante?
   - [ ] ¬øLas puntuaciones son razonables?
   - [ ] ¬øHay contradicciones internas?

#### 3.2 Perfilado y Optimizaci√≥n (D√≠a 16-18)

**Identificar cuellos de botella:**

```python
# profile_execution.py
import cProfile
import pstats
from orchestrator import FARFANOrchestrator

def profile_full_analysis():
    orch = FARFANOrchestrator()
    orch.analyze_single_plan("test_plan.pdf")

if __name__ == "__main__":
    profiler = cProfile.Profile()
    profiler.enable()
    profile_full_analysis()
    profiler.disable()
    
    stats = pstats.Stats(profiler)
    stats.sort_stats('cumulative')
    stats.print_stats(50)
```

**Optimizaciones t√≠picas:**

1. **Cach√© agresivo:**
   - Embeddings de texto
   - Resultados de m√≥dulos
   - An√°lisis sem√°ntico

2. **Paralelizaci√≥n:**
   - M√≥dulos independientes en paralelo
   - Procesamiento de m√∫ltiples planes simult√°neamente

3. **Lazy loading:**
   - Cargar modelos solo cuando se necesitan
   - Singleton pattern para modelos pesados

4. **Reducci√≥n de memoria:**
   - Procesar chunks de texto en lugar de todo el documento
   - Liberar recursos despu√©s de cada m√≥dulo

#### 3.3 Documentaci√≥n de Usuario (D√≠a 19-20)

Crear gu√≠as para usuarios finales:

**README_USUARIO.md:**
```markdown
# Gu√≠a de Usuario - FARFAN 3.0

## Instalaci√≥n R√°pida
1. Instalar dependencias: `pip install -r requirements_complete.txt`
2. Descargar modelo spaCy: `python -m spacy download es_core_news_lg`
3. Probar instalaci√≥n: `python run_farfan.py --health`

## Uso B√°sico

### Analizar un plan:
\`\`\`bash
python run_farfan.py --plan mi_plan.pdf
\`\`\`

### Analizar m√∫ltiples planes:
\`\`\`bash
python run_farfan.py --batch carpeta_planes/ --max-plans 10
\`\`\`

## Interpretaci√≥n de Resultados
...
```

**Entregables Fase 3:**
- ‚úÖ 5 planes reales analizados exitosamente
- ‚úÖ Reporte de performance (tiempos, cuellos de botella)
- ‚úÖ Optimizaciones implementadas
- ‚úÖ Documentaci√≥n de usuario completa

---

### **FASE 4: PRODUCCI√ìN Y ESCALAMIENTO** (5-10 d√≠as)

**Objetivo:** Preparar para analizar 170 planes.

#### 4.1 An√°lisis Batch Optimizado (D√≠a 21-23)

**Implementar procesamiento eficiente:**

1. **Worker pool con l√≠mite de memoria:**
```python
# orchestrator/batch_processor.py

from multiprocessing import Pool, Manager
import psutil

def process_plan_with_memory_limit(plan_path, max_memory_gb=4):
    """Procesa plan con l√≠mite de memoria."""
    process = psutil.Process()
    
    # Verificar memoria disponible
    if process.memory_info().rss / 1024**3 > max_memory_gb:
        raise MemoryError("Memory limit exceeded")
    
    orch = FARFANOrchestrator()
    return orch.analyze_single_plan(plan_path)

def batch_process_plans(plan_paths, workers=4):
    """Procesa m√∫ltiples planes en paralelo."""
    with Pool(workers) as pool:
        results = pool.map(process_plan_with_memory_limit, plan_paths)
    return results
```

2. **Checkpoint y recuperaci√≥n:**
   - Guardar progreso cada N planes
   - Reanudar desde √∫ltimo checkpoint en caso de fallo
   - Logging detallado de progreso

3. **Monitoreo en tiempo real:**
   - Dashboard simple con Flask
   - Estad√≠sticas de progreso
   - Alertas de errores

#### 4.2 Prueba de Estr√©s (D√≠a 24-25)

**Ejecutar an√°lisis de 20-30 planes:**

```bash
python run_farfan.py --batch planes_prueba/ --max-plans 30 --workers 4
```

**Monitorear:**
- Uso de CPU
- Uso de memoria
- Uso de disco
- Tiempo total
- Tasa de √©xito
- Errores/warnings

**Ajustar configuraci√≥n seg√∫n resultados:**
- N√∫mero de workers
- Tama√±o de cach√©
- Timeout de m√≥dulos

#### 4.3 An√°lisis de 170 Planes (D√≠a 26-30)

**Ejecuci√≥n en producci√≥n:**

1. **Pre-validaci√≥n:**
   - [ ] Verificar que todos los 170 PDFs son legibles
   - [ ] Estimar tiempo total (planes_prueba √ó escala)
   - [ ] Asegurar espacio en disco suficiente

2. **Ejecuci√≥n por lotes:**
   ```bash
   # Lote 1: 50 planes
   python run_farfan.py --batch lote1/ --max-plans 50 --workers 4
   
   # Lote 2: 50 planes
   python run_farfan.py --batch lote2/ --max-plans 50 --workers 4
   
   # Lote 3: 50 planes
   python run_farfan.py --batch lote3/ --max-plans 50 --workers 4
   
   # Lote 4: 20 planes
   python run_farfan.py --batch lote4/ --max-plans 20 --workers 4
   ```

3. **Validaci√≥n de resultados:**
   - [ ] ¬øTodos los 170 planes procesados?
   - [ ] ¬øTasa de √©xito aceptable? (>90%)
   - [ ] ¬øResultados consistentes?
   - [ ] ¬øReportes generados correctamente?

4. **An√°lisis agregado:**
   - Generar reporte comparativo de 170 planes
   - Rankings por dimensi√≥n
   - Identificar patrones comunes
   - Detectar outliers

**Entregables Fase 4:**
- ‚úÖ 170 planes analizados exitosamente
- ‚úÖ Reporte agregado de todos los planes
- ‚úÖ Dashboard de resultados
- ‚úÖ Documentaci√≥n de proceso batch

---

## üìÖ TIMELINE CONSOLIDADO

### **Escenario Optimista** (Derek Beach existe)

| Fase | Duraci√≥n | D√≠as Acumulados | Hitos |
|------|----------|----------------|-------|
| Fase 0 | 1 d√≠a | 1 | Decisiones cr√≠ticas |
| Fase 1 | 3 d√≠as | 4 | Sistema sin errores |
| Fase 2 | 7 d√≠as | 11 | 1 dimensi√≥n funcional |
| Fase 3 | 7 d√≠as | 18 | 5 planes validados |
| Fase 4 | 5 d√≠as | **23 d√≠as** | **170 planes completos** |

**Total: ~3-4 semanas** ‚úÖ

### **Escenario Realista** (Derek Beach necesita adaptaci√≥n)

| Fase | Duraci√≥n | D√≠as Acumulados | Hitos |
|------|----------|----------------|-------|
| Fase 0 | 2 d√≠as | 2 | Decisiones + evaluaci√≥n |
| Fase 1 | 5 d√≠as | 7 | Derek Beach adaptado |
| Fase 2 | 10 d√≠as | 17 | Sistema integrado |
| Fase 3 | 10 d√≠as | 27 | Performance optimizado |
| Fase 4 | 8 d√≠as | **35 d√≠as** | **170 planes completos** |

**Total: ~5-6 semanas** ‚ö†Ô∏è

### **Escenario Pesimista** (Derek Beach desde cero)

| Fase | Duraci√≥n | D√≠as Acumulados | Hitos |
|------|----------|----------------|-------|
| Fase 0 | 3 d√≠as | 3 | An√°lisis + decisi√≥n |
| Fase 1 | 15 d√≠as | 18 | Derek Beach implementado |
| Fase 2 | 15 d√≠as | 33 | Sistema completamente funcional |
| Fase 3 | 10 d√≠as | 43 | Validaci√≥n exhaustiva |
| Fase 4 | 10 d√≠as | **53 d√≠as** | **170 planes completos** |

**Total: ~7-8 semanas** üî¥

---

## üéØ CRITERIOS DE √âXITO

### **Fase 1 (Fundamentos):**
- ‚úÖ 100% m√≥dulos importables sin errores
- ‚úÖ Derek Beach integrado o stub funcional
- ‚úÖ Orquestador inicializa sin errores

### **Fase 2 (Integraci√≥n):**
- ‚úÖ Al menos 50 preguntas funcionando (1 dimensi√≥n)
- ‚úÖ Tasa de √©xito >80% en pruebas
- ‚úÖ Suite de tests con >70% cobertura

### **Fase 3 (Validaci√≥n):**
- ‚úÖ 5 planes reales analizados exitosamente
- ‚úÖ Tiempo de ejecuci√≥n <30 min por plan
- ‚úÖ Resultados validados por experto de dominio

### **Fase 4 (Producci√≥n):**
- ‚úÖ 170 planes procesados con √©xito >90%
- ‚úÖ Reportes generados correctamente
- ‚úÖ Sistema estable (sin crashes)
- ‚úÖ Documentaci√≥n completa

---

## ‚ö†Ô∏è RIESGOS Y MITIGACIONES

| Riesgo | Probabilidad | Impacto | Mitigaci√≥n |
|--------|--------------|---------|------------|
| Derek Beach no existe | Media | **CR√çTICO** | Crear stubs ‚Üí implementar gradualmente |
| Dependencias incompatibles | Baja | Alto | Usar entorno virtual, fijar versiones |
| Performance insuficiente | Media | Alto | Paralelizaci√≥n, cach√©, optimizaci√≥n |
| Calidad de resultados baja | Media | Alto | Validaci√≥n con expertos, ajuste de umbrales |
| Errores en 170 planes | Media | Medio | Procesamiento por lotes, checkpoints |
| Recursos computacionales | Baja | Medio | Cloud computing, procesamiento distribuido |

---

## üìû PUNTOS DE DECISI√ìN CLAVE

### **Checkpoint 1 (Fin de Fase 0):**
**Pregunta:** ¬øExiste Derek Beach?
- **SI:** Continuar con escenario optimista
- **NO:** Decidir entre stub temporal o implementaci√≥n completa

### **Checkpoint 2 (Fin de Fase 1):**
**Pregunta:** ¬øTodos los m√≥dulos importables?
- **SI:** Proceder a Fase 2
- **NO:** Resolver dependencias faltantes antes de continuar

### **Checkpoint 3 (Fin de Fase 2):**
**Pregunta:** ¬øAl menos 1 dimensi√≥n funciona end-to-end?
- **SI:** Proceder a Fase 3
- **NO:** Revisar arquitectura de integraci√≥n

### **Checkpoint 4 (Fin de Fase 3):**
**Pregunta:** ¬øPerformance aceptable para 170 planes?
- **SI:** Proceder a Fase 4
- **NO:** Optimizar o considerar reducir scope

---

## üìä M√âTRICAS DE PROGRESO

**Actualizar semanalmente:**

```
SEMANA 1:
- M√≥dulos importables: [ ] / 8
- Errores de sintaxis: [ ] / 3
- Derek Beach: [ ] Localizado [ ] Integrado [ ] Stub

SEMANA 2:
- Preguntas funcionando: [ ] / 300
- Dimensiones completas: [ ] / 6
- Cobertura de tests: [ ]%

SEMANA 3:
- Planes validados: [ ] / 5
- Tiempo promedio por plan: [ ] min
- Optimizaciones implementadas: [ ]

SEMANA 4:
- Planes procesados batch: [ ] / 170
- Tasa de √©xito: [ ]%
- Reportes generados: [ ]
```

---

## üèÅ ENTREGABLES FINALES

Al completar este roadmap:

1. **Sistema FARFAN 3.0 Production-Ready**
   - 8 m√≥dulos funcionando
   - 300 preguntas operativas
   - An√°lisis de 170 planes

2. **Documentaci√≥n Completa**
   - Manual de usuario
   - Documentaci√≥n t√©cnica
   - Gu√≠a de troubleshooting

3. **Reportes de An√°lisis**
   - 170 reportes individuales
   - 1 reporte agregado
   - Dashboard de visualizaci√≥n

4. **Repositorio Limpio**
   - Tests completos
   - CI/CD configurado
   - Sin deuda t√©cnica cr√≠tica

---

**Este roadmap debe actualizarse cada semana con el progreso real.**

---

**Creado por:** GitHub Copilot  
**Fecha:** 16 de Octubre, 2025  
**Pr√≥xima revisi√≥n:** Una semana despu√©s de iniciar Fase 1
