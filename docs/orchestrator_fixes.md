# Orchestrator Fixes - Invocation Compatibility Analysis

**Generated by:** audit_orchestrator_invocations.py  
**Scope:** Orchestrator-to-adapter boundary interface contracts only

## Executive Summary

**Total Invocations Analyzed:** 11

- **✓ OK:** 8 (72.7%)
- **⚠ MISMATCH:** 3 (27.3%)
- **✗ MISSING:** 0 (0.0%)
- **⊗ STATIC_VIOLATION:** 0 (0.0%)

### Key Finding

The audit identified **3 parameter name mismatches** in `core_orchestrator.py`. All target methods exist, argument counts are correct, and calls use keyword arguments, so **runtime behavior is correct**. Issues are naming convention inconsistencies only.

## Issues by Orchestrator File

### choreographer.py ✓

**Issues found:** 0

All invocations compatible. The call to `module_adapter_registry.execute_module_method()` at line 361 correctly passes `module_name`, `method_name`, `args`, and `kwargs` as keyword arguments matching the adapter interface signature.

### circuit_breaker.py ✓

**Issues found:** 0

All internal method calls within circuit breaker are compatible with signatures.

### report_assembly.py ✓

**Issues found:** 0

All internal method calls compatible. Methods correctly handle execution_results dictionaries.

### question_router.py ✓

**Issues found:** 0 (contains adapter registry definition, not invocations)

This file defines `ModuleAdapterRegistry` class itself. No compatibility issues.

### core_orchestrator.py ⚠

**Issues found:** 3 (minor - all use keyword args)

#### Issue 1: `analyze_single_plan()` → `report_assembler.generate_macro_convergence()`

- **Line:** ~150-160
- **Status:** `MISMATCH` (naming convention only)
- **Expected Signature:** `generate_macro_convergence(all_micro_answers: List, all_meso_clusters: List, plan_metadata: Dict) -> MacroLevelConvergence`
- **Called With:** Local variable `micro_answers` passed to parameter `all_micro_answers`
- **Impact:** None - uses keyword arguments
- **Remediation:** 
  ```python
  # Current (works fine):
  macro_convergence = self.report_assembler.generate_macro_convergence(
      all_micro_answers=micro_answers,  # OK as keyword arg
      all_meso_clusters=meso_clusters,
      plan_metadata={...}
  )
  
  # Optional improvement for consistency:
  all_micro_answers = micro_answers
  all_meso_clusters = meso_clusters
  macro_convergence = self.report_assembler.generate_macro_convergence(
      all_micro_answers, all_meso_clusters, plan_metadata
  )
  ```

#### Issue 2: `analyze_single_plan()` → `report_assembler.export_report()`

- **Line:** ~165-170
- **Status:** `MISMATCH` (naming convention only)
- **Expected Signature:** `export_report(micro_answers: List, meso_clusters: List, macro_convergence, output_path: Path) -> None`
- **Called With:** Variable `report_path` passed to parameter `output_path`
- **Impact:** None - uses keyword arguments
- **Remediation:**
  ```python
  # Current (works fine):
  self.report_assembler.export_report(
      micro_answers=micro_answers,
      meso_clusters=meso_clusters,
      macro_convergence=macro_convergence,
      output_path=report_path  # OK as keyword arg
  )
  
  # Optional improvement:
  output_path = output_dir / f"{plan_name}_complete_report.json"
  self.report_assembler.export_report(
      micro_answers, meso_clusters, macro_convergence, output_path
  )
  ```

#### Issue 3: `_generate_meso_clusters()` → `report_assembler.generate_meso_cluster()`

- **Line:** ~225
- **Status:** `MISMATCH` (naming convention only)
- **Expected Signature:** `generate_meso_cluster(cluster_name: str, cluster_description: str, micro_answers: List, cluster_definition: Dict) -> MesoLevelCluster`
- **Called With:** Loop variable `answers` passed to parameter `micro_answers`
- **Impact:** None - uses keyword arguments
- **Remediation:**
  ```python
  # Current (works fine):
  for policy_area, answers in by_policy.items():
      cluster = self.report_assembler.generate_meso_cluster(
          cluster_name=f"POLICY_{policy_area}",
          cluster_description=f"Cluster for policy area {policy_area}",
          micro_answers=answers,  # OK as keyword arg
          cluster_definition={...}
      )
  
  # Optional improvement:
  for policy_area, micro_answers_subset in by_policy.items():
      cluster = self.report_assembler.generate_meso_cluster(
          f"POLICY_{policy_area}",
          f"Cluster for policy area {policy_area}",
          micro_answers_subset,
          {...}
      )
  ```

## Interface Contracts Verified

### ✅ ModuleAdapterRegistry.execute_module_method()

**Signature:** `(module_name: str, method_name: str, args: List[Any], kwargs: Dict[str, Any]) -> ModuleResult`

**Callers verified:**
- `choreographer.py:361` ✓ Correct keyword arguments

### ✅ ExecutionChoreographer.execute_question_chain()

**Signature:** `(question_spec, plan_text: str, module_adapter_registry, circuit_breaker=None) -> Dict[str, ExecutionResult]`

**Callers verified:**
- `core_orchestrator.py:~130` ✓ Correct arguments

### ⚠ ReportAssembler Methods

- ✅ `generate_micro_answer()` - Compatible
- ⚠ `generate_meso_cluster()` - Compatible (with keyword args)
- ⚠ `generate_macro_convergence()` - Parameter name mismatch (mitigated by keyword args)
- ⚠ `export_report()` - Parameter name mismatch (mitigated by keyword args)

## Implementation Drift Analysis

### No Critical Drift Detected

**Verified:**
1. ✅ **All target methods exist** in their respective modules
2. ✅ **Argument counts match** between call sites and method signatures
3. ✅ **Return types align** with usage patterns (ExecutionResult, ModuleResult, MicroLevelAnswer, etc.)
4. ✅ **Error handling present** via try-except blocks and circuit breaker patterns

### Minor Drift: Naming Conventions

**Identified inconsistency:**
- Orchestrators use shorter variable names (`answers`, `micro_answers`, `report_path`)
- Adapters expect more explicit parameter names (`all_micro_answers`, `output_path`)

**Mitigation:** All calls use keyword arguments explicitly, ensuring correct parameter binding.

## Recommendations

### Priority 1: No Immediate Action Required ✓

All invocations work correctly at runtime. The identified mismatches are **code style issues**, not bugs.

### Priority 2: Optional Code Quality Improvements

1. **Standardize variable naming** to match parameter names:
   - Use `all_micro_answers` instead of `micro_answers` when calling `generate_macro_convergence()`
   - Use `output_path` instead of `report_path` when calling `export_report()`
   - Use descriptive loop variables matching parameter names

2. **Add type hints** to make interfaces more explicit

3. **Document naming conventions** in AGENTS.md or TONKOTSU.md

### Priority 3: Long-term Improvements

1. Implement automated signature compatibility tests in CI/CD
2. Add mypy or similar type checking to catch future drift
3. Create integration tests for orchestrator-adapter boundaries

## Conclusion

**Status:** ✅ **NO BLOCKING ISSUES**

All identified mismatches are **naming convention differences** that do not affect runtime because:
- ✅ All calls use **keyword arguments explicitly**
- ✅ All **target methods exist**
- ✅ All **argument counts match**
- ✅ All **type expectations align**

The codebase demonstrates **defensive programming** with consistent keyword argument usage. Recommended fixes are **optional quality improvements**, not bug fixes.

---

**Audit Methodology:** Static AST analysis of orchestrator→adapter invocations  
**Scope:** Orchestrator-to-adapter boundary only (adapter→source-module excluded per requirements)  
**Files Analyzed:** core_orchestrator.py, choreographer.py, circuit_breaker.py, report_assembly.py, question_router.py
