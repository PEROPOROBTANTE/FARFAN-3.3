[
  {
    "correction_id": 1,
    "adapter_name": "PolicyProcessorAdapter",
    "class_name": "BayesianEvidenceScorer",
    "method_name": "_calculate_shannon_entropy",
    "line_number": 337,
    "original_code": "scorer = self.BayesianEvidenceScorer(); entropy = scorer._calculate_shannon_entropy(distribution)",
    "corrected_code": "entropy = self.BayesianEvidenceScorer._calculate_shannon_entropy(distribution)",
    "justification": "_calculate_shannon_entropy is decorated with @staticmethod in policy_processor.py. Static methods should be called directly on the class without instantiating the class first. Removed unnecessary instantiation.",
    "source_reference": "policy_processor.py:314-315",
    "issue_type": "static_method_requires_no_instantiation"
  },
  {
    "correction_id": 2,
    "adapter_name": "AnalyzerOneAdapter",
    "class_name": "DocumentProcessor",
    "method_name": "load_pdf",
    "line_number": 2126,
    "original_code": "processor = self.DocumentProcessor(); text = processor.load_pdf(file_path)",
    "corrected_code": "text = self.DocumentProcessor.load_pdf(file_path)",
    "justification": "load_pdf is decorated with @staticmethod in Analyzer_one.py. Static methods should be called directly on the class without instantiating the class. Removed unnecessary instantiation.",
    "source_reference": "Analyzer_one.py:983-984",
    "issue_type": "static_method_requires_no_instantiation"
  },
  {
    "correction_id": 3,
    "adapter_name": "AnalyzerOneAdapter",
    "class_name": "DocumentProcessor",
    "method_name": "load_docx",
    "line_number": 2142,
    "original_code": "processor = self.DocumentProcessor(); text = processor.load_docx(file_path)",
    "corrected_code": "text = self.DocumentProcessor.load_docx(file_path)",
    "justification": "load_docx is decorated with @staticmethod in Analyzer_one.py. Static methods should be called directly on the class without instantiating the class. Removed unnecessary instantiation.",
    "source_reference": "Analyzer_one.py:1001-1002",
    "issue_type": "static_method_requires_no_instantiation"
  },
  {
    "correction_id": 4,
    "adapter_name": "AnalyzerOneAdapter",
    "class_name": "DocumentProcessor",
    "method_name": "segment_text",
    "line_number": 2158,
    "original_code": "processor = self.DocumentProcessor(); segments = processor.segment_text(text, method)",
    "corrected_code": "segments = self.DocumentProcessor.segment_text(text, method)",
    "justification": "segment_text is decorated with @staticmethod in Analyzer_one.py. Static methods should be called directly on the class without instantiating the class. Removed unnecessary instantiation.",
    "source_reference": "Analyzer_one.py:1018-1019",
    "issue_type": "static_method_requires_no_instantiation"
  },
  {
    "correction_id": 5,
    "adapter_name": "ModulosAdapter",
    "class_name": "AdvancedDAGValidator",
    "method_name": "_is_acyclic",
    "line_number": 6123,
    "original_code": "is_acyclic = self.AdvancedDAGValidator._is_acyclic(nodes)",
    "corrected_code": "is_acyclic = self.AdvancedDAGValidator._is_acyclic(nodes)",
    "justification": "_is_acyclic is decorated with @staticmethod in teoria_cambio.py. The call pattern is already correct (calling on class, not instance). Added clarifying comment.",
    "source_reference": "teoria_cambio.py:419-420",
    "issue_type": "correct_static_call_verified"
  },
  {
    "correction_id": 6,
    "adapter_name": "ModulosAdapter",
    "class_name": "AdvancedDAGValidator",
    "method_name": "_calculate_confidence_interval",
    "line_number": 6187,
    "original_code": "ci = self.AdvancedDAGValidator._calculate_confidence_interval(successes, trials, confidence)",
    "corrected_code": "ci = self.AdvancedDAGValidator._calculate_confidence_interval(successes, trials, confidence)",
    "justification": "_calculate_confidence_interval is decorated with @staticmethod in teoria_cambio.py. The call pattern is already correct (calling on class, not instance). Added clarifying comment.",
    "source_reference": "teoria_cambio.py:552-553",
    "issue_type": "correct_static_call_verified"
  },
  {
    "correction_id": 7,
    "adapter_name": "ModulosAdapter",
    "class_name": "AdvancedDAGValidator",
    "method_name": "_calculate_statistical_power",
    "line_number": 6210,
    "original_code": "power = self.AdvancedDAGValidator._calculate_statistical_power(s, n, alpha)",
    "corrected_code": "power = self.AdvancedDAGValidator._calculate_statistical_power(s, n, alpha)",
    "justification": "_calculate_statistical_power is decorated with @staticmethod in teoria_cambio.py. The call pattern is already correct (calling on class, not instance). Added clarifying comment.",
    "source_reference": "teoria_cambio.py:566-567",
    "issue_type": "correct_static_call_verified"
  },
  {
    "correction_id": 8,
    "adapter_name": "ModulosAdapter",
    "class_name": "AdvancedDAGValidator",
    "method_name": "_calculate_bayesian_posterior",
    "line_number": 6233,
    "original_code": "posterior = self.AdvancedDAGValidator._calculate_bayesian_posterior(likelihood, prior)",
    "corrected_code": "posterior = self.AdvancedDAGValidator._calculate_bayesian_posterior(likelihood, prior)",
    "justification": "_calculate_bayesian_posterior is decorated with @staticmethod in teoria_cambio.py. The call pattern is already correct (calling on class, not instance). Added clarifying comment.",
    "source_reference": "teoria_cambio.py:577-578",
    "issue_type": "correct_static_call_verified"
  },
  {
    "correction_id": 9,
    "adapter_name": "DerekBeachAdapter",
    "class_name": "BeachEvidentialTest",
    "method_name": "classify_test",
    "line_number": 4479,
    "original_code": "test_type = self.BeachEvidentialTest.classify_test(necessity, sufficiency)",
    "corrected_code": "test_type = self.BeachEvidentialTest.classify_test(necessity, sufficiency)",
    "justification": "classify_test is a @staticmethod. The call pattern is already correct (calling on class, not instance). Added clarifying comment and missing return statement.",
    "source_reference": "dereck_beach.py (staticmethod decorator present)",
    "issue_type": "correct_static_call_verified_and_return_added"
  },
  {
    "correction_id": 10,
    "adapter_name": "DerekBeachAdapter",
    "class_name": "BeachEvidentialTest",
    "method_name": "apply_test_logic",
    "line_number": 4484,
    "original_code": "posterior, interpretation = self.BeachEvidentialTest.apply_test_logic(test_type, evidence_found, prior, bayes_factor)",
    "corrected_code": "posterior, interpretation = self.BeachEvidentialTest.apply_test_logic(test_type, evidence_found, prior, bayes_factor)",
    "justification": "apply_test_logic is a @staticmethod. The call pattern is already correct (calling on class, not instance). Added clarifying comment and missing return statement.",
    "source_reference": "dereck_beach.py (staticmethod decorator present)",
    "issue_type": "correct_static_call_verified_and_return_added"
  },
  {
    "correction_id": 11,
    "adapter_name": "AnalyzerOneAdapter",
    "class_name": "ResultsExporter",
    "method_name": "export_to_json",
    "line_number": 2178,
    "original_code": "self.ResultsExporter.export_to_json(results, output_path)",
    "corrected_code": "self.ResultsExporter.export_to_json(results, output_path)",
    "justification": "export_to_json is decorated with @staticmethod in Analyzer_one.py. The call pattern is already correct - calling directly on class. No changes needed, confirmed correct implementation.",
    "source_reference": "Analyzer_one.py:1065-1066",
    "issue_type": "correct_static_call_verified"
  },
  {
    "correction_id": 12,
    "adapter_name": "AnalyzerOneAdapter",
    "class_name": "ResultsExporter",
    "method_name": "export_to_excel",
    "line_number": 2193,
    "original_code": "self.ResultsExporter.export_to_excel(results, output_path)",
    "corrected_code": "self.ResultsExporter.export_to_excel(results, output_path)",
    "justification": "export_to_excel is decorated with @staticmethod in Analyzer_one.py. The call pattern is already correct - calling directly on class. No changes needed, confirmed correct implementation.",
    "source_reference": "Analyzer_one.py:1075-1076",
    "issue_type": "correct_static_call_verified"
  },
  {
    "correction_id": 13,
    "adapter_name": "AnalyzerOneAdapter",
    "class_name": "ResultsExporter",
    "method_name": "export_summary_report",
    "line_number": 2208,
    "original_code": "self.ResultsExporter.export_summary_report(results, output_path)",
    "corrected_code": "self.ResultsExporter.export_summary_report(results, output_path)",
    "justification": "export_summary_report is decorated with @staticmethod in Analyzer_one.py. The call pattern is already correct - calling directly on class. No changes needed, confirmed correct implementation.",
    "source_reference": "Analyzer_one.py:1140-1141",
    "issue_type": "correct_static_call_verified"
  }
]
