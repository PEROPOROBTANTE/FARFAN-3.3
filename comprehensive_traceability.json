{
  "P1-D1-Q1": {
    "question_id": "P1-D1-Q1",
    "point": "P1",
    "dimension": "D1",
    "question_number": 1,
    "question_text": "Identify and analyze baseline conditions",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "policy_segmenter",
        "adapter_class": "PolicySegmenterAdapter",
        "method": "segment",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "plan_text"
          }
        ],
        "returns": {
          "type": "List[Dict[str, Any]]",
          "binding": "document_segments"
        },
        "source_module": "policy_segmenter.py",
        "source_class": "PolicySegmenterAdapter",
        "source_method": "segment",
        "purpose": "Segment document into analyzable chunks",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "plan_text"
            }
          ],
          "return_type": "List[Dict[str, Any]]",
          "source_file": "policy_segmenter.py"
        }
      },
      {
        "step": 2,
        "adapter": "policy_processor",
        "adapter_class": "PolicyProcessorAdapter",
        "method": "normalize_unicode",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "plan_text"
          }
        ],
        "returns": {
          "type": "str",
          "binding": "normalized_text"
        },
        "source_module": "policy_processor.py",
        "source_class": "PolicyProcessorAdapter",
        "source_method": "normalize_unicode",
        "purpose": "Normalize text encoding for consistent processing",
        "confidence_expected": 1.0,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "plan_text"
            }
          ],
          "return_type": "str",
          "source_file": "policy_processor.py"
        }
      },
      {
        "step": 3,
        "adapter": "semantic_chunking_policy",
        "adapter_class": "SemanticChunkingPolicyAdapter",
        "method": "chunk_document",
        "args": [
          {
            "name": "document",
            "type": "str",
            "source": "normalized_text"
          },
          {
            "name": "target_chunk_size",
            "type": "int",
            "value": 512
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "semantic_chunks"
        },
        "source_module": "semantic_chunking_policy.py",
        "source_class": "SemanticChunkingPolicyAdapter",
        "source_method": "chunk_document",
        "purpose": "Create semantic chunks preserving baseline context",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "document",
              "type": "str",
              "source": "normalized_text"
            },
            {
              "name": "target_chunk_size",
              "type": "int",
              "value": 512
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "semantic_chunking_policy.py"
        }
      },
      {
        "step": 4,
        "adapter": "policy_segmenter",
        "adapter_class": "PolicySegmenterAdapter",
        "method": "get_segmentation_report",
        "args": [],
        "returns": {
          "type": "Dict",
          "binding": "segmentation_metrics"
        },
        "source_module": "policy_segmenter.py",
        "source_class": "PolicySegmenterAdapter",
        "source_method": "get_segmentation_report",
        "purpose": "Get quality metrics for baseline segmentation",
        "confidence_expected": 0.9,
        "signature": {
          "parameters": [],
          "return_type": "Dict",
          "source_file": "policy_segmenter.py"
        }
      }
    ],
    "contributing_modules": [
      "policy_processor.py",
      "policy_segmenter.py",
      "semantic_chunking_policy.py"
    ],
    "primary_adapter": "policy_segmenter",
    "evidence_types": [
      "document_segments",
      "normalized_text",
      "segmentation_metrics",
      "semantic_chunks"
    ],
    "aggregation_strategy": "baseline_weighted",
    "confidence_threshold": 0.7,
    "total_steps": 4
  },
  "P2-D1-Q1": {
    "question_id": "P2-D1-Q1",
    "point": "P2",
    "dimension": "D1",
    "question_number": 1,
    "question_text": "Identify and analyze baseline conditions",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "policy_segmenter",
        "adapter_class": "PolicySegmenterAdapter",
        "method": "segment",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "plan_text"
          }
        ],
        "returns": {
          "type": "List[Dict[str, Any]]",
          "binding": "document_segments"
        },
        "source_module": "policy_segmenter.py",
        "source_class": "PolicySegmenterAdapter",
        "source_method": "segment",
        "purpose": "Segment document into analyzable chunks",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "plan_text"
            }
          ],
          "return_type": "List[Dict[str, Any]]",
          "source_file": "policy_segmenter.py"
        }
      },
      {
        "step": 2,
        "adapter": "policy_processor",
        "adapter_class": "PolicyProcessorAdapter",
        "method": "normalize_unicode",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "plan_text"
          }
        ],
        "returns": {
          "type": "str",
          "binding": "normalized_text"
        },
        "source_module": "policy_processor.py",
        "source_class": "PolicyProcessorAdapter",
        "source_method": "normalize_unicode",
        "purpose": "Normalize text encoding for consistent processing",
        "confidence_expected": 1.0,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "plan_text"
            }
          ],
          "return_type": "str",
          "source_file": "policy_processor.py"
        }
      },
      {
        "step": 3,
        "adapter": "semantic_chunking_policy",
        "adapter_class": "SemanticChunkingPolicyAdapter",
        "method": "chunk_document",
        "args": [
          {
            "name": "document",
            "type": "str",
            "source": "normalized_text"
          },
          {
            "name": "target_chunk_size",
            "type": "int",
            "value": 512
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "semantic_chunks"
        },
        "source_module": "semantic_chunking_policy.py",
        "source_class": "SemanticChunkingPolicyAdapter",
        "source_method": "chunk_document",
        "purpose": "Create semantic chunks preserving baseline context",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "document",
              "type": "str",
              "source": "normalized_text"
            },
            {
              "name": "target_chunk_size",
              "type": "int",
              "value": 512
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "semantic_chunking_policy.py"
        }
      },
      {
        "step": 4,
        "adapter": "policy_segmenter",
        "adapter_class": "PolicySegmenterAdapter",
        "method": "get_segmentation_report",
        "args": [],
        "returns": {
          "type": "Dict",
          "binding": "segmentation_metrics"
        },
        "source_module": "policy_segmenter.py",
        "source_class": "PolicySegmenterAdapter",
        "source_method": "get_segmentation_report",
        "purpose": "Get quality metrics for baseline segmentation",
        "confidence_expected": 0.9,
        "signature": {
          "parameters": [],
          "return_type": "Dict",
          "source_file": "policy_segmenter.py"
        }
      }
    ],
    "contributing_modules": [
      "policy_processor.py",
      "policy_segmenter.py",
      "semantic_chunking_policy.py"
    ],
    "primary_adapter": "policy_segmenter",
    "evidence_types": [
      "document_segments",
      "normalized_text",
      "segmentation_metrics",
      "semantic_chunks"
    ],
    "aggregation_strategy": "baseline_weighted",
    "confidence_threshold": 0.7,
    "total_steps": 4
  },
  "P3-D1-Q1": {
    "question_id": "P3-D1-Q1",
    "point": "P3",
    "dimension": "D1",
    "question_number": 1,
    "question_text": "Identify and analyze baseline conditions",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "policy_segmenter",
        "adapter_class": "PolicySegmenterAdapter",
        "method": "segment",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "plan_text"
          }
        ],
        "returns": {
          "type": "List[Dict[str, Any]]",
          "binding": "document_segments"
        },
        "source_module": "policy_segmenter.py",
        "source_class": "PolicySegmenterAdapter",
        "source_method": "segment",
        "purpose": "Segment document into analyzable chunks",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "plan_text"
            }
          ],
          "return_type": "List[Dict[str, Any]]",
          "source_file": "policy_segmenter.py"
        }
      },
      {
        "step": 2,
        "adapter": "policy_processor",
        "adapter_class": "PolicyProcessorAdapter",
        "method": "normalize_unicode",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "plan_text"
          }
        ],
        "returns": {
          "type": "str",
          "binding": "normalized_text"
        },
        "source_module": "policy_processor.py",
        "source_class": "PolicyProcessorAdapter",
        "source_method": "normalize_unicode",
        "purpose": "Normalize text encoding for consistent processing",
        "confidence_expected": 1.0,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "plan_text"
            }
          ],
          "return_type": "str",
          "source_file": "policy_processor.py"
        }
      },
      {
        "step": 3,
        "adapter": "semantic_chunking_policy",
        "adapter_class": "SemanticChunkingPolicyAdapter",
        "method": "chunk_document",
        "args": [
          {
            "name": "document",
            "type": "str",
            "source": "normalized_text"
          },
          {
            "name": "target_chunk_size",
            "type": "int",
            "value": 512
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "semantic_chunks"
        },
        "source_module": "semantic_chunking_policy.py",
        "source_class": "SemanticChunkingPolicyAdapter",
        "source_method": "chunk_document",
        "purpose": "Create semantic chunks preserving baseline context",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "document",
              "type": "str",
              "source": "normalized_text"
            },
            {
              "name": "target_chunk_size",
              "type": "int",
              "value": 512
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "semantic_chunking_policy.py"
        }
      },
      {
        "step": 4,
        "adapter": "policy_segmenter",
        "adapter_class": "PolicySegmenterAdapter",
        "method": "get_segmentation_report",
        "args": [],
        "returns": {
          "type": "Dict",
          "binding": "segmentation_metrics"
        },
        "source_module": "policy_segmenter.py",
        "source_class": "PolicySegmenterAdapter",
        "source_method": "get_segmentation_report",
        "purpose": "Get quality metrics for baseline segmentation",
        "confidence_expected": 0.9,
        "signature": {
          "parameters": [],
          "return_type": "Dict",
          "source_file": "policy_segmenter.py"
        }
      }
    ],
    "contributing_modules": [
      "policy_processor.py",
      "policy_segmenter.py",
      "semantic_chunking_policy.py"
    ],
    "primary_adapter": "policy_segmenter",
    "evidence_types": [
      "document_segments",
      "normalized_text",
      "segmentation_metrics",
      "semantic_chunks"
    ],
    "aggregation_strategy": "baseline_weighted",
    "confidence_threshold": 0.7,
    "total_steps": 4
  },
  "P4-D1-Q1": {
    "question_id": "P4-D1-Q1",
    "point": "P4",
    "dimension": "D1",
    "question_number": 1,
    "question_text": "Identify and analyze baseline conditions",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "policy_segmenter",
        "adapter_class": "PolicySegmenterAdapter",
        "method": "segment",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "plan_text"
          }
        ],
        "returns": {
          "type": "List[Dict[str, Any]]",
          "binding": "document_segments"
        },
        "source_module": "policy_segmenter.py",
        "source_class": "PolicySegmenterAdapter",
        "source_method": "segment",
        "purpose": "Segment document into analyzable chunks",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "plan_text"
            }
          ],
          "return_type": "List[Dict[str, Any]]",
          "source_file": "policy_segmenter.py"
        }
      },
      {
        "step": 2,
        "adapter": "policy_processor",
        "adapter_class": "PolicyProcessorAdapter",
        "method": "normalize_unicode",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "plan_text"
          }
        ],
        "returns": {
          "type": "str",
          "binding": "normalized_text"
        },
        "source_module": "policy_processor.py",
        "source_class": "PolicyProcessorAdapter",
        "source_method": "normalize_unicode",
        "purpose": "Normalize text encoding for consistent processing",
        "confidence_expected": 1.0,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "plan_text"
            }
          ],
          "return_type": "str",
          "source_file": "policy_processor.py"
        }
      },
      {
        "step": 3,
        "adapter": "semantic_chunking_policy",
        "adapter_class": "SemanticChunkingPolicyAdapter",
        "method": "chunk_document",
        "args": [
          {
            "name": "document",
            "type": "str",
            "source": "normalized_text"
          },
          {
            "name": "target_chunk_size",
            "type": "int",
            "value": 512
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "semantic_chunks"
        },
        "source_module": "semantic_chunking_policy.py",
        "source_class": "SemanticChunkingPolicyAdapter",
        "source_method": "chunk_document",
        "purpose": "Create semantic chunks preserving baseline context",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "document",
              "type": "str",
              "source": "normalized_text"
            },
            {
              "name": "target_chunk_size",
              "type": "int",
              "value": 512
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "semantic_chunking_policy.py"
        }
      },
      {
        "step": 4,
        "adapter": "policy_segmenter",
        "adapter_class": "PolicySegmenterAdapter",
        "method": "get_segmentation_report",
        "args": [],
        "returns": {
          "type": "Dict",
          "binding": "segmentation_metrics"
        },
        "source_module": "policy_segmenter.py",
        "source_class": "PolicySegmenterAdapter",
        "source_method": "get_segmentation_report",
        "purpose": "Get quality metrics for baseline segmentation",
        "confidence_expected": 0.9,
        "signature": {
          "parameters": [],
          "return_type": "Dict",
          "source_file": "policy_segmenter.py"
        }
      }
    ],
    "contributing_modules": [
      "policy_processor.py",
      "policy_segmenter.py",
      "semantic_chunking_policy.py"
    ],
    "primary_adapter": "policy_segmenter",
    "evidence_types": [
      "document_segments",
      "normalized_text",
      "segmentation_metrics",
      "semantic_chunks"
    ],
    "aggregation_strategy": "baseline_weighted",
    "confidence_threshold": 0.7,
    "total_steps": 4
  },
  "P5-D1-Q1": {
    "question_id": "P5-D1-Q1",
    "point": "P5",
    "dimension": "D1",
    "question_number": 1,
    "question_text": "Identify and analyze baseline conditions",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "policy_segmenter",
        "adapter_class": "PolicySegmenterAdapter",
        "method": "segment",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "plan_text"
          }
        ],
        "returns": {
          "type": "List[Dict[str, Any]]",
          "binding": "document_segments"
        },
        "source_module": "policy_segmenter.py",
        "source_class": "PolicySegmenterAdapter",
        "source_method": "segment",
        "purpose": "Segment document into analyzable chunks",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "plan_text"
            }
          ],
          "return_type": "List[Dict[str, Any]]",
          "source_file": "policy_segmenter.py"
        }
      },
      {
        "step": 2,
        "adapter": "policy_processor",
        "adapter_class": "PolicyProcessorAdapter",
        "method": "normalize_unicode",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "plan_text"
          }
        ],
        "returns": {
          "type": "str",
          "binding": "normalized_text"
        },
        "source_module": "policy_processor.py",
        "source_class": "PolicyProcessorAdapter",
        "source_method": "normalize_unicode",
        "purpose": "Normalize text encoding for consistent processing",
        "confidence_expected": 1.0,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "plan_text"
            }
          ],
          "return_type": "str",
          "source_file": "policy_processor.py"
        }
      },
      {
        "step": 3,
        "adapter": "semantic_chunking_policy",
        "adapter_class": "SemanticChunkingPolicyAdapter",
        "method": "chunk_document",
        "args": [
          {
            "name": "document",
            "type": "str",
            "source": "normalized_text"
          },
          {
            "name": "target_chunk_size",
            "type": "int",
            "value": 512
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "semantic_chunks"
        },
        "source_module": "semantic_chunking_policy.py",
        "source_class": "SemanticChunkingPolicyAdapter",
        "source_method": "chunk_document",
        "purpose": "Create semantic chunks preserving baseline context",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "document",
              "type": "str",
              "source": "normalized_text"
            },
            {
              "name": "target_chunk_size",
              "type": "int",
              "value": 512
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "semantic_chunking_policy.py"
        }
      },
      {
        "step": 4,
        "adapter": "policy_segmenter",
        "adapter_class": "PolicySegmenterAdapter",
        "method": "get_segmentation_report",
        "args": [],
        "returns": {
          "type": "Dict",
          "binding": "segmentation_metrics"
        },
        "source_module": "policy_segmenter.py",
        "source_class": "PolicySegmenterAdapter",
        "source_method": "get_segmentation_report",
        "purpose": "Get quality metrics for baseline segmentation",
        "confidence_expected": 0.9,
        "signature": {
          "parameters": [],
          "return_type": "Dict",
          "source_file": "policy_segmenter.py"
        }
      }
    ],
    "contributing_modules": [
      "policy_processor.py",
      "policy_segmenter.py",
      "semantic_chunking_policy.py"
    ],
    "primary_adapter": "policy_segmenter",
    "evidence_types": [
      "document_segments",
      "normalized_text",
      "segmentation_metrics",
      "semantic_chunks"
    ],
    "aggregation_strategy": "baseline_weighted",
    "confidence_threshold": 0.7,
    "total_steps": 4
  },
  "P6-D1-Q1": {
    "question_id": "P6-D1-Q1",
    "point": "P6",
    "dimension": "D1",
    "question_number": 1,
    "question_text": "Identify and analyze baseline conditions",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "policy_segmenter",
        "adapter_class": "PolicySegmenterAdapter",
        "method": "segment",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "plan_text"
          }
        ],
        "returns": {
          "type": "List[Dict[str, Any]]",
          "binding": "document_segments"
        },
        "source_module": "policy_segmenter.py",
        "source_class": "PolicySegmenterAdapter",
        "source_method": "segment",
        "purpose": "Segment document into analyzable chunks",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "plan_text"
            }
          ],
          "return_type": "List[Dict[str, Any]]",
          "source_file": "policy_segmenter.py"
        }
      },
      {
        "step": 2,
        "adapter": "policy_processor",
        "adapter_class": "PolicyProcessorAdapter",
        "method": "normalize_unicode",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "plan_text"
          }
        ],
        "returns": {
          "type": "str",
          "binding": "normalized_text"
        },
        "source_module": "policy_processor.py",
        "source_class": "PolicyProcessorAdapter",
        "source_method": "normalize_unicode",
        "purpose": "Normalize text encoding for consistent processing",
        "confidence_expected": 1.0,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "plan_text"
            }
          ],
          "return_type": "str",
          "source_file": "policy_processor.py"
        }
      },
      {
        "step": 3,
        "adapter": "semantic_chunking_policy",
        "adapter_class": "SemanticChunkingPolicyAdapter",
        "method": "chunk_document",
        "args": [
          {
            "name": "document",
            "type": "str",
            "source": "normalized_text"
          },
          {
            "name": "target_chunk_size",
            "type": "int",
            "value": 512
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "semantic_chunks"
        },
        "source_module": "semantic_chunking_policy.py",
        "source_class": "SemanticChunkingPolicyAdapter",
        "source_method": "chunk_document",
        "purpose": "Create semantic chunks preserving baseline context",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "document",
              "type": "str",
              "source": "normalized_text"
            },
            {
              "name": "target_chunk_size",
              "type": "int",
              "value": 512
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "semantic_chunking_policy.py"
        }
      },
      {
        "step": 4,
        "adapter": "policy_segmenter",
        "adapter_class": "PolicySegmenterAdapter",
        "method": "get_segmentation_report",
        "args": [],
        "returns": {
          "type": "Dict",
          "binding": "segmentation_metrics"
        },
        "source_module": "policy_segmenter.py",
        "source_class": "PolicySegmenterAdapter",
        "source_method": "get_segmentation_report",
        "purpose": "Get quality metrics for baseline segmentation",
        "confidence_expected": 0.9,
        "signature": {
          "parameters": [],
          "return_type": "Dict",
          "source_file": "policy_segmenter.py"
        }
      }
    ],
    "contributing_modules": [
      "policy_processor.py",
      "policy_segmenter.py",
      "semantic_chunking_policy.py"
    ],
    "primary_adapter": "policy_segmenter",
    "evidence_types": [
      "document_segments",
      "normalized_text",
      "segmentation_metrics",
      "semantic_chunks"
    ],
    "aggregation_strategy": "baseline_weighted",
    "confidence_threshold": 0.7,
    "total_steps": 4
  },
  "P7-D1-Q1": {
    "question_id": "P7-D1-Q1",
    "point": "P7",
    "dimension": "D1",
    "question_number": 1,
    "question_text": "Identify and analyze baseline conditions",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "policy_segmenter",
        "adapter_class": "PolicySegmenterAdapter",
        "method": "segment",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "plan_text"
          }
        ],
        "returns": {
          "type": "List[Dict[str, Any]]",
          "binding": "document_segments"
        },
        "source_module": "policy_segmenter.py",
        "source_class": "PolicySegmenterAdapter",
        "source_method": "segment",
        "purpose": "Segment document into analyzable chunks",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "plan_text"
            }
          ],
          "return_type": "List[Dict[str, Any]]",
          "source_file": "policy_segmenter.py"
        }
      },
      {
        "step": 2,
        "adapter": "policy_processor",
        "adapter_class": "PolicyProcessorAdapter",
        "method": "normalize_unicode",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "plan_text"
          }
        ],
        "returns": {
          "type": "str",
          "binding": "normalized_text"
        },
        "source_module": "policy_processor.py",
        "source_class": "PolicyProcessorAdapter",
        "source_method": "normalize_unicode",
        "purpose": "Normalize text encoding for consistent processing",
        "confidence_expected": 1.0,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "plan_text"
            }
          ],
          "return_type": "str",
          "source_file": "policy_processor.py"
        }
      },
      {
        "step": 3,
        "adapter": "semantic_chunking_policy",
        "adapter_class": "SemanticChunkingPolicyAdapter",
        "method": "chunk_document",
        "args": [
          {
            "name": "document",
            "type": "str",
            "source": "normalized_text"
          },
          {
            "name": "target_chunk_size",
            "type": "int",
            "value": 512
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "semantic_chunks"
        },
        "source_module": "semantic_chunking_policy.py",
        "source_class": "SemanticChunkingPolicyAdapter",
        "source_method": "chunk_document",
        "purpose": "Create semantic chunks preserving baseline context",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "document",
              "type": "str",
              "source": "normalized_text"
            },
            {
              "name": "target_chunk_size",
              "type": "int",
              "value": 512
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "semantic_chunking_policy.py"
        }
      },
      {
        "step": 4,
        "adapter": "policy_segmenter",
        "adapter_class": "PolicySegmenterAdapter",
        "method": "get_segmentation_report",
        "args": [],
        "returns": {
          "type": "Dict",
          "binding": "segmentation_metrics"
        },
        "source_module": "policy_segmenter.py",
        "source_class": "PolicySegmenterAdapter",
        "source_method": "get_segmentation_report",
        "purpose": "Get quality metrics for baseline segmentation",
        "confidence_expected": 0.9,
        "signature": {
          "parameters": [],
          "return_type": "Dict",
          "source_file": "policy_segmenter.py"
        }
      }
    ],
    "contributing_modules": [
      "policy_processor.py",
      "policy_segmenter.py",
      "semantic_chunking_policy.py"
    ],
    "primary_adapter": "policy_segmenter",
    "evidence_types": [
      "document_segments",
      "normalized_text",
      "segmentation_metrics",
      "semantic_chunks"
    ],
    "aggregation_strategy": "baseline_weighted",
    "confidence_threshold": 0.7,
    "total_steps": 4
  },
  "P8-D1-Q1": {
    "question_id": "P8-D1-Q1",
    "point": "P8",
    "dimension": "D1",
    "question_number": 1,
    "question_text": "Identify and analyze baseline conditions",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "policy_segmenter",
        "adapter_class": "PolicySegmenterAdapter",
        "method": "segment",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "plan_text"
          }
        ],
        "returns": {
          "type": "List[Dict[str, Any]]",
          "binding": "document_segments"
        },
        "source_module": "policy_segmenter.py",
        "source_class": "PolicySegmenterAdapter",
        "source_method": "segment",
        "purpose": "Segment document into analyzable chunks",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "plan_text"
            }
          ],
          "return_type": "List[Dict[str, Any]]",
          "source_file": "policy_segmenter.py"
        }
      },
      {
        "step": 2,
        "adapter": "policy_processor",
        "adapter_class": "PolicyProcessorAdapter",
        "method": "normalize_unicode",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "plan_text"
          }
        ],
        "returns": {
          "type": "str",
          "binding": "normalized_text"
        },
        "source_module": "policy_processor.py",
        "source_class": "PolicyProcessorAdapter",
        "source_method": "normalize_unicode",
        "purpose": "Normalize text encoding for consistent processing",
        "confidence_expected": 1.0,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "plan_text"
            }
          ],
          "return_type": "str",
          "source_file": "policy_processor.py"
        }
      },
      {
        "step": 3,
        "adapter": "semantic_chunking_policy",
        "adapter_class": "SemanticChunkingPolicyAdapter",
        "method": "chunk_document",
        "args": [
          {
            "name": "document",
            "type": "str",
            "source": "normalized_text"
          },
          {
            "name": "target_chunk_size",
            "type": "int",
            "value": 512
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "semantic_chunks"
        },
        "source_module": "semantic_chunking_policy.py",
        "source_class": "SemanticChunkingPolicyAdapter",
        "source_method": "chunk_document",
        "purpose": "Create semantic chunks preserving baseline context",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "document",
              "type": "str",
              "source": "normalized_text"
            },
            {
              "name": "target_chunk_size",
              "type": "int",
              "value": 512
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "semantic_chunking_policy.py"
        }
      },
      {
        "step": 4,
        "adapter": "policy_segmenter",
        "adapter_class": "PolicySegmenterAdapter",
        "method": "get_segmentation_report",
        "args": [],
        "returns": {
          "type": "Dict",
          "binding": "segmentation_metrics"
        },
        "source_module": "policy_segmenter.py",
        "source_class": "PolicySegmenterAdapter",
        "source_method": "get_segmentation_report",
        "purpose": "Get quality metrics for baseline segmentation",
        "confidence_expected": 0.9,
        "signature": {
          "parameters": [],
          "return_type": "Dict",
          "source_file": "policy_segmenter.py"
        }
      }
    ],
    "contributing_modules": [
      "policy_processor.py",
      "policy_segmenter.py",
      "semantic_chunking_policy.py"
    ],
    "primary_adapter": "policy_segmenter",
    "evidence_types": [
      "document_segments",
      "normalized_text",
      "segmentation_metrics",
      "semantic_chunks"
    ],
    "aggregation_strategy": "baseline_weighted",
    "confidence_threshold": 0.7,
    "total_steps": 4
  },
  "P9-D1-Q1": {
    "question_id": "P9-D1-Q1",
    "point": "P9",
    "dimension": "D1",
    "question_number": 1,
    "question_text": "Identify and analyze baseline conditions",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "policy_segmenter",
        "adapter_class": "PolicySegmenterAdapter",
        "method": "segment",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "plan_text"
          }
        ],
        "returns": {
          "type": "List[Dict[str, Any]]",
          "binding": "document_segments"
        },
        "source_module": "policy_segmenter.py",
        "source_class": "PolicySegmenterAdapter",
        "source_method": "segment",
        "purpose": "Segment document into analyzable chunks",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "plan_text"
            }
          ],
          "return_type": "List[Dict[str, Any]]",
          "source_file": "policy_segmenter.py"
        }
      },
      {
        "step": 2,
        "adapter": "policy_processor",
        "adapter_class": "PolicyProcessorAdapter",
        "method": "normalize_unicode",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "plan_text"
          }
        ],
        "returns": {
          "type": "str",
          "binding": "normalized_text"
        },
        "source_module": "policy_processor.py",
        "source_class": "PolicyProcessorAdapter",
        "source_method": "normalize_unicode",
        "purpose": "Normalize text encoding for consistent processing",
        "confidence_expected": 1.0,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "plan_text"
            }
          ],
          "return_type": "str",
          "source_file": "policy_processor.py"
        }
      },
      {
        "step": 3,
        "adapter": "semantic_chunking_policy",
        "adapter_class": "SemanticChunkingPolicyAdapter",
        "method": "chunk_document",
        "args": [
          {
            "name": "document",
            "type": "str",
            "source": "normalized_text"
          },
          {
            "name": "target_chunk_size",
            "type": "int",
            "value": 512
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "semantic_chunks"
        },
        "source_module": "semantic_chunking_policy.py",
        "source_class": "SemanticChunkingPolicyAdapter",
        "source_method": "chunk_document",
        "purpose": "Create semantic chunks preserving baseline context",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "document",
              "type": "str",
              "source": "normalized_text"
            },
            {
              "name": "target_chunk_size",
              "type": "int",
              "value": 512
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "semantic_chunking_policy.py"
        }
      },
      {
        "step": 4,
        "adapter": "policy_segmenter",
        "adapter_class": "PolicySegmenterAdapter",
        "method": "get_segmentation_report",
        "args": [],
        "returns": {
          "type": "Dict",
          "binding": "segmentation_metrics"
        },
        "source_module": "policy_segmenter.py",
        "source_class": "PolicySegmenterAdapter",
        "source_method": "get_segmentation_report",
        "purpose": "Get quality metrics for baseline segmentation",
        "confidence_expected": 0.9,
        "signature": {
          "parameters": [],
          "return_type": "Dict",
          "source_file": "policy_segmenter.py"
        }
      }
    ],
    "contributing_modules": [
      "policy_processor.py",
      "policy_segmenter.py",
      "semantic_chunking_policy.py"
    ],
    "primary_adapter": "policy_segmenter",
    "evidence_types": [
      "document_segments",
      "normalized_text",
      "segmentation_metrics",
      "semantic_chunks"
    ],
    "aggregation_strategy": "baseline_weighted",
    "confidence_threshold": 0.7,
    "total_steps": 4
  },
  "P10-D1-Q1": {
    "question_id": "P10-D1-Q1",
    "point": "P10",
    "dimension": "D1",
    "question_number": 1,
    "question_text": "Identify and analyze baseline conditions",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "policy_segmenter",
        "adapter_class": "PolicySegmenterAdapter",
        "method": "segment",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "plan_text"
          }
        ],
        "returns": {
          "type": "List[Dict[str, Any]]",
          "binding": "document_segments"
        },
        "source_module": "policy_segmenter.py",
        "source_class": "PolicySegmenterAdapter",
        "source_method": "segment",
        "purpose": "Segment document into analyzable chunks",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "plan_text"
            }
          ],
          "return_type": "List[Dict[str, Any]]",
          "source_file": "policy_segmenter.py"
        }
      },
      {
        "step": 2,
        "adapter": "policy_processor",
        "adapter_class": "PolicyProcessorAdapter",
        "method": "normalize_unicode",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "plan_text"
          }
        ],
        "returns": {
          "type": "str",
          "binding": "normalized_text"
        },
        "source_module": "policy_processor.py",
        "source_class": "PolicyProcessorAdapter",
        "source_method": "normalize_unicode",
        "purpose": "Normalize text encoding for consistent processing",
        "confidence_expected": 1.0,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "plan_text"
            }
          ],
          "return_type": "str",
          "source_file": "policy_processor.py"
        }
      },
      {
        "step": 3,
        "adapter": "semantic_chunking_policy",
        "adapter_class": "SemanticChunkingPolicyAdapter",
        "method": "chunk_document",
        "args": [
          {
            "name": "document",
            "type": "str",
            "source": "normalized_text"
          },
          {
            "name": "target_chunk_size",
            "type": "int",
            "value": 512
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "semantic_chunks"
        },
        "source_module": "semantic_chunking_policy.py",
        "source_class": "SemanticChunkingPolicyAdapter",
        "source_method": "chunk_document",
        "purpose": "Create semantic chunks preserving baseline context",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "document",
              "type": "str",
              "source": "normalized_text"
            },
            {
              "name": "target_chunk_size",
              "type": "int",
              "value": 512
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "semantic_chunking_policy.py"
        }
      },
      {
        "step": 4,
        "adapter": "policy_segmenter",
        "adapter_class": "PolicySegmenterAdapter",
        "method": "get_segmentation_report",
        "args": [],
        "returns": {
          "type": "Dict",
          "binding": "segmentation_metrics"
        },
        "source_module": "policy_segmenter.py",
        "source_class": "PolicySegmenterAdapter",
        "source_method": "get_segmentation_report",
        "purpose": "Get quality metrics for baseline segmentation",
        "confidence_expected": 0.9,
        "signature": {
          "parameters": [],
          "return_type": "Dict",
          "source_file": "policy_segmenter.py"
        }
      }
    ],
    "contributing_modules": [
      "policy_processor.py",
      "policy_segmenter.py",
      "semantic_chunking_policy.py"
    ],
    "primary_adapter": "policy_segmenter",
    "evidence_types": [
      "document_segments",
      "normalized_text",
      "segmentation_metrics",
      "semantic_chunks"
    ],
    "aggregation_strategy": "baseline_weighted",
    "confidence_threshold": 0.7,
    "total_steps": 4
  },
  "P1-D1-Q2": {
    "question_id": "P1-D1-Q2",
    "point": "P1",
    "dimension": "D1",
    "question_number": 2,
    "question_text": "Analyze gaps between current state and requirements",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "semantic_chunking_policy",
        "adapter_class": "SemanticChunkingPolicyAdapter",
        "method": "bayesian_evidence_integration",
        "args": [
          {
            "name": "chunks",
            "type": "List[Dict]",
            "source": "semantic_chunks"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "evidence_scores"
        },
        "source_module": "semantic_chunking_policy.py",
        "source_class": "SemanticChunkingPolicyAdapter",
        "source_method": "bayesian_evidence_integration",
        "purpose": "Integrate evidence from chunks with Bayesian scoring",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "chunks",
              "type": "List[Dict]",
              "source": "evidence_chunks"
            }
          ],
          "return_type": "Dict",
          "source_file": "semantic_chunking_policy.py"
        }
      },
      {
        "step": 2,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "extract_pdm_structure",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "pdm_structure"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "extract_pdm_structure",
        "purpose": "Extract P-D-Q structure for gap identification",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "Dict",
          "source_file": "emebedding_policy.py"
        }
      },
      {
        "step": 3,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "detect",
        "args": [
          {
            "name": "document",
            "type": "str",
            "source": "normalized_text"
          },
          {
            "name": "metadata",
            "type": "dict",
            "value": {
              "analysis_type": "gap_analysis"
            }
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "contradictions"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "detect",
        "purpose": "Detect contradictions indicating gaps",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [
            {
              "name": "document",
              "type": "str",
              "source": "normalized_text"
            },
            {
              "name": "metadata",
              "type": "dict",
              "value": {
                "analysis_type": "evidence_validation"
              }
            }
          ],
          "return_type": "Dict",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 4,
        "adapter": "analyzer_one",
        "adapter_class": "AnalyzerOneAdapter",
        "method": "analyze_semantic_coherence",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "coherence_analysis"
        },
        "source_module": "Analyzer_one.py",
        "source_class": "AnalyzerOneAdapter",
        "source_method": "analyze_semantic_coherence",
        "purpose": "Analyze semantic coherence to identify gaps",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "Dict",
          "source_file": "Analyzer_one.py"
        }
      }
    ],
    "contributing_modules": [
      "Analyzer_one.py",
      "contradiction_deteccion.py",
      "emebedding_policy.py",
      "semantic_chunking_policy.py"
    ],
    "primary_adapter": "semantic_chunking_policy",
    "evidence_types": [
      "coherence_analysis",
      "contradictions",
      "evidence_scores",
      "pdm_structure"
    ],
    "aggregation_strategy": "gap_identification",
    "confidence_threshold": 0.72,
    "total_steps": 4
  },
  "P2-D1-Q2": {
    "question_id": "P2-D1-Q2",
    "point": "P2",
    "dimension": "D1",
    "question_number": 2,
    "question_text": "Analyze gaps between current state and requirements",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "semantic_chunking_policy",
        "adapter_class": "SemanticChunkingPolicyAdapter",
        "method": "bayesian_evidence_integration",
        "args": [
          {
            "name": "chunks",
            "type": "List[Dict]",
            "source": "semantic_chunks"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "evidence_scores"
        },
        "source_module": "semantic_chunking_policy.py",
        "source_class": "SemanticChunkingPolicyAdapter",
        "source_method": "bayesian_evidence_integration",
        "purpose": "Integrate evidence from chunks with Bayesian scoring",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "chunks",
              "type": "List[Dict]",
              "source": "evidence_chunks"
            }
          ],
          "return_type": "Dict",
          "source_file": "semantic_chunking_policy.py"
        }
      },
      {
        "step": 2,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "extract_pdm_structure",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "pdm_structure"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "extract_pdm_structure",
        "purpose": "Extract P-D-Q structure for gap identification",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "Dict",
          "source_file": "emebedding_policy.py"
        }
      },
      {
        "step": 3,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "detect",
        "args": [
          {
            "name": "document",
            "type": "str",
            "source": "normalized_text"
          },
          {
            "name": "metadata",
            "type": "dict",
            "value": {
              "analysis_type": "gap_analysis"
            }
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "contradictions"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "detect",
        "purpose": "Detect contradictions indicating gaps",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [
            {
              "name": "document",
              "type": "str",
              "source": "normalized_text"
            },
            {
              "name": "metadata",
              "type": "dict",
              "value": {
                "analysis_type": "evidence_validation"
              }
            }
          ],
          "return_type": "Dict",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 4,
        "adapter": "analyzer_one",
        "adapter_class": "AnalyzerOneAdapter",
        "method": "analyze_semantic_coherence",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "coherence_analysis"
        },
        "source_module": "Analyzer_one.py",
        "source_class": "AnalyzerOneAdapter",
        "source_method": "analyze_semantic_coherence",
        "purpose": "Analyze semantic coherence to identify gaps",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "Dict",
          "source_file": "Analyzer_one.py"
        }
      }
    ],
    "contributing_modules": [
      "Analyzer_one.py",
      "contradiction_deteccion.py",
      "emebedding_policy.py",
      "semantic_chunking_policy.py"
    ],
    "primary_adapter": "semantic_chunking_policy",
    "evidence_types": [
      "coherence_analysis",
      "contradictions",
      "evidence_scores",
      "pdm_structure"
    ],
    "aggregation_strategy": "gap_identification",
    "confidence_threshold": 0.72,
    "total_steps": 4
  },
  "P3-D1-Q2": {
    "question_id": "P3-D1-Q2",
    "point": "P3",
    "dimension": "D1",
    "question_number": 2,
    "question_text": "Analyze gaps between current state and requirements",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "semantic_chunking_policy",
        "adapter_class": "SemanticChunkingPolicyAdapter",
        "method": "bayesian_evidence_integration",
        "args": [
          {
            "name": "chunks",
            "type": "List[Dict]",
            "source": "semantic_chunks"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "evidence_scores"
        },
        "source_module": "semantic_chunking_policy.py",
        "source_class": "SemanticChunkingPolicyAdapter",
        "source_method": "bayesian_evidence_integration",
        "purpose": "Integrate evidence from chunks with Bayesian scoring",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "chunks",
              "type": "List[Dict]",
              "source": "evidence_chunks"
            }
          ],
          "return_type": "Dict",
          "source_file": "semantic_chunking_policy.py"
        }
      },
      {
        "step": 2,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "extract_pdm_structure",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "pdm_structure"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "extract_pdm_structure",
        "purpose": "Extract P-D-Q structure for gap identification",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "Dict",
          "source_file": "emebedding_policy.py"
        }
      },
      {
        "step": 3,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "detect",
        "args": [
          {
            "name": "document",
            "type": "str",
            "source": "normalized_text"
          },
          {
            "name": "metadata",
            "type": "dict",
            "value": {
              "analysis_type": "gap_analysis"
            }
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "contradictions"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "detect",
        "purpose": "Detect contradictions indicating gaps",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [
            {
              "name": "document",
              "type": "str",
              "source": "normalized_text"
            },
            {
              "name": "metadata",
              "type": "dict",
              "value": {
                "analysis_type": "evidence_validation"
              }
            }
          ],
          "return_type": "Dict",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 4,
        "adapter": "analyzer_one",
        "adapter_class": "AnalyzerOneAdapter",
        "method": "analyze_semantic_coherence",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "coherence_analysis"
        },
        "source_module": "Analyzer_one.py",
        "source_class": "AnalyzerOneAdapter",
        "source_method": "analyze_semantic_coherence",
        "purpose": "Analyze semantic coherence to identify gaps",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "Dict",
          "source_file": "Analyzer_one.py"
        }
      }
    ],
    "contributing_modules": [
      "Analyzer_one.py",
      "contradiction_deteccion.py",
      "emebedding_policy.py",
      "semantic_chunking_policy.py"
    ],
    "primary_adapter": "semantic_chunking_policy",
    "evidence_types": [
      "coherence_analysis",
      "contradictions",
      "evidence_scores",
      "pdm_structure"
    ],
    "aggregation_strategy": "gap_identification",
    "confidence_threshold": 0.72,
    "total_steps": 4
  },
  "P4-D1-Q2": {
    "question_id": "P4-D1-Q2",
    "point": "P4",
    "dimension": "D1",
    "question_number": 2,
    "question_text": "Analyze gaps between current state and requirements",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "semantic_chunking_policy",
        "adapter_class": "SemanticChunkingPolicyAdapter",
        "method": "bayesian_evidence_integration",
        "args": [
          {
            "name": "chunks",
            "type": "List[Dict]",
            "source": "semantic_chunks"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "evidence_scores"
        },
        "source_module": "semantic_chunking_policy.py",
        "source_class": "SemanticChunkingPolicyAdapter",
        "source_method": "bayesian_evidence_integration",
        "purpose": "Integrate evidence from chunks with Bayesian scoring",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "chunks",
              "type": "List[Dict]",
              "source": "evidence_chunks"
            }
          ],
          "return_type": "Dict",
          "source_file": "semantic_chunking_policy.py"
        }
      },
      {
        "step": 2,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "extract_pdm_structure",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "pdm_structure"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "extract_pdm_structure",
        "purpose": "Extract P-D-Q structure for gap identification",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "Dict",
          "source_file": "emebedding_policy.py"
        }
      },
      {
        "step": 3,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "detect",
        "args": [
          {
            "name": "document",
            "type": "str",
            "source": "normalized_text"
          },
          {
            "name": "metadata",
            "type": "dict",
            "value": {
              "analysis_type": "gap_analysis"
            }
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "contradictions"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "detect",
        "purpose": "Detect contradictions indicating gaps",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [
            {
              "name": "document",
              "type": "str",
              "source": "normalized_text"
            },
            {
              "name": "metadata",
              "type": "dict",
              "value": {
                "analysis_type": "evidence_validation"
              }
            }
          ],
          "return_type": "Dict",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 4,
        "adapter": "analyzer_one",
        "adapter_class": "AnalyzerOneAdapter",
        "method": "analyze_semantic_coherence",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "coherence_analysis"
        },
        "source_module": "Analyzer_one.py",
        "source_class": "AnalyzerOneAdapter",
        "source_method": "analyze_semantic_coherence",
        "purpose": "Analyze semantic coherence to identify gaps",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "Dict",
          "source_file": "Analyzer_one.py"
        }
      }
    ],
    "contributing_modules": [
      "Analyzer_one.py",
      "contradiction_deteccion.py",
      "emebedding_policy.py",
      "semantic_chunking_policy.py"
    ],
    "primary_adapter": "semantic_chunking_policy",
    "evidence_types": [
      "coherence_analysis",
      "contradictions",
      "evidence_scores",
      "pdm_structure"
    ],
    "aggregation_strategy": "gap_identification",
    "confidence_threshold": 0.72,
    "total_steps": 4
  },
  "P5-D1-Q2": {
    "question_id": "P5-D1-Q2",
    "point": "P5",
    "dimension": "D1",
    "question_number": 2,
    "question_text": "Analyze gaps between current state and requirements",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "semantic_chunking_policy",
        "adapter_class": "SemanticChunkingPolicyAdapter",
        "method": "bayesian_evidence_integration",
        "args": [
          {
            "name": "chunks",
            "type": "List[Dict]",
            "source": "semantic_chunks"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "evidence_scores"
        },
        "source_module": "semantic_chunking_policy.py",
        "source_class": "SemanticChunkingPolicyAdapter",
        "source_method": "bayesian_evidence_integration",
        "purpose": "Integrate evidence from chunks with Bayesian scoring",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "chunks",
              "type": "List[Dict]",
              "source": "evidence_chunks"
            }
          ],
          "return_type": "Dict",
          "source_file": "semantic_chunking_policy.py"
        }
      },
      {
        "step": 2,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "extract_pdm_structure",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "pdm_structure"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "extract_pdm_structure",
        "purpose": "Extract P-D-Q structure for gap identification",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "Dict",
          "source_file": "emebedding_policy.py"
        }
      },
      {
        "step": 3,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "detect",
        "args": [
          {
            "name": "document",
            "type": "str",
            "source": "normalized_text"
          },
          {
            "name": "metadata",
            "type": "dict",
            "value": {
              "analysis_type": "gap_analysis"
            }
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "contradictions"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "detect",
        "purpose": "Detect contradictions indicating gaps",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [
            {
              "name": "document",
              "type": "str",
              "source": "normalized_text"
            },
            {
              "name": "metadata",
              "type": "dict",
              "value": {
                "analysis_type": "evidence_validation"
              }
            }
          ],
          "return_type": "Dict",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 4,
        "adapter": "analyzer_one",
        "adapter_class": "AnalyzerOneAdapter",
        "method": "analyze_semantic_coherence",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "coherence_analysis"
        },
        "source_module": "Analyzer_one.py",
        "source_class": "AnalyzerOneAdapter",
        "source_method": "analyze_semantic_coherence",
        "purpose": "Analyze semantic coherence to identify gaps",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "Dict",
          "source_file": "Analyzer_one.py"
        }
      }
    ],
    "contributing_modules": [
      "Analyzer_one.py",
      "contradiction_deteccion.py",
      "emebedding_policy.py",
      "semantic_chunking_policy.py"
    ],
    "primary_adapter": "semantic_chunking_policy",
    "evidence_types": [
      "coherence_analysis",
      "contradictions",
      "evidence_scores",
      "pdm_structure"
    ],
    "aggregation_strategy": "gap_identification",
    "confidence_threshold": 0.72,
    "total_steps": 4
  },
  "P6-D1-Q2": {
    "question_id": "P6-D1-Q2",
    "point": "P6",
    "dimension": "D1",
    "question_number": 2,
    "question_text": "Analyze gaps between current state and requirements",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "semantic_chunking_policy",
        "adapter_class": "SemanticChunkingPolicyAdapter",
        "method": "bayesian_evidence_integration",
        "args": [
          {
            "name": "chunks",
            "type": "List[Dict]",
            "source": "semantic_chunks"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "evidence_scores"
        },
        "source_module": "semantic_chunking_policy.py",
        "source_class": "SemanticChunkingPolicyAdapter",
        "source_method": "bayesian_evidence_integration",
        "purpose": "Integrate evidence from chunks with Bayesian scoring",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "chunks",
              "type": "List[Dict]",
              "source": "evidence_chunks"
            }
          ],
          "return_type": "Dict",
          "source_file": "semantic_chunking_policy.py"
        }
      },
      {
        "step": 2,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "extract_pdm_structure",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "pdm_structure"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "extract_pdm_structure",
        "purpose": "Extract P-D-Q structure for gap identification",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "Dict",
          "source_file": "emebedding_policy.py"
        }
      },
      {
        "step": 3,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "detect",
        "args": [
          {
            "name": "document",
            "type": "str",
            "source": "normalized_text"
          },
          {
            "name": "metadata",
            "type": "dict",
            "value": {
              "analysis_type": "gap_analysis"
            }
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "contradictions"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "detect",
        "purpose": "Detect contradictions indicating gaps",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [
            {
              "name": "document",
              "type": "str",
              "source": "normalized_text"
            },
            {
              "name": "metadata",
              "type": "dict",
              "value": {
                "analysis_type": "evidence_validation"
              }
            }
          ],
          "return_type": "Dict",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 4,
        "adapter": "analyzer_one",
        "adapter_class": "AnalyzerOneAdapter",
        "method": "analyze_semantic_coherence",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "coherence_analysis"
        },
        "source_module": "Analyzer_one.py",
        "source_class": "AnalyzerOneAdapter",
        "source_method": "analyze_semantic_coherence",
        "purpose": "Analyze semantic coherence to identify gaps",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "Dict",
          "source_file": "Analyzer_one.py"
        }
      }
    ],
    "contributing_modules": [
      "Analyzer_one.py",
      "contradiction_deteccion.py",
      "emebedding_policy.py",
      "semantic_chunking_policy.py"
    ],
    "primary_adapter": "semantic_chunking_policy",
    "evidence_types": [
      "coherence_analysis",
      "contradictions",
      "evidence_scores",
      "pdm_structure"
    ],
    "aggregation_strategy": "gap_identification",
    "confidence_threshold": 0.72,
    "total_steps": 4
  },
  "P7-D1-Q2": {
    "question_id": "P7-D1-Q2",
    "point": "P7",
    "dimension": "D1",
    "question_number": 2,
    "question_text": "Analyze gaps between current state and requirements",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "semantic_chunking_policy",
        "adapter_class": "SemanticChunkingPolicyAdapter",
        "method": "bayesian_evidence_integration",
        "args": [
          {
            "name": "chunks",
            "type": "List[Dict]",
            "source": "semantic_chunks"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "evidence_scores"
        },
        "source_module": "semantic_chunking_policy.py",
        "source_class": "SemanticChunkingPolicyAdapter",
        "source_method": "bayesian_evidence_integration",
        "purpose": "Integrate evidence from chunks with Bayesian scoring",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "chunks",
              "type": "List[Dict]",
              "source": "evidence_chunks"
            }
          ],
          "return_type": "Dict",
          "source_file": "semantic_chunking_policy.py"
        }
      },
      {
        "step": 2,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "extract_pdm_structure",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "pdm_structure"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "extract_pdm_structure",
        "purpose": "Extract P-D-Q structure for gap identification",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "Dict",
          "source_file": "emebedding_policy.py"
        }
      },
      {
        "step": 3,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "detect",
        "args": [
          {
            "name": "document",
            "type": "str",
            "source": "normalized_text"
          },
          {
            "name": "metadata",
            "type": "dict",
            "value": {
              "analysis_type": "gap_analysis"
            }
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "contradictions"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "detect",
        "purpose": "Detect contradictions indicating gaps",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [
            {
              "name": "document",
              "type": "str",
              "source": "normalized_text"
            },
            {
              "name": "metadata",
              "type": "dict",
              "value": {
                "analysis_type": "evidence_validation"
              }
            }
          ],
          "return_type": "Dict",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 4,
        "adapter": "analyzer_one",
        "adapter_class": "AnalyzerOneAdapter",
        "method": "analyze_semantic_coherence",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "coherence_analysis"
        },
        "source_module": "Analyzer_one.py",
        "source_class": "AnalyzerOneAdapter",
        "source_method": "analyze_semantic_coherence",
        "purpose": "Analyze semantic coherence to identify gaps",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "Dict",
          "source_file": "Analyzer_one.py"
        }
      }
    ],
    "contributing_modules": [
      "Analyzer_one.py",
      "contradiction_deteccion.py",
      "emebedding_policy.py",
      "semantic_chunking_policy.py"
    ],
    "primary_adapter": "semantic_chunking_policy",
    "evidence_types": [
      "coherence_analysis",
      "contradictions",
      "evidence_scores",
      "pdm_structure"
    ],
    "aggregation_strategy": "gap_identification",
    "confidence_threshold": 0.72,
    "total_steps": 4
  },
  "P8-D1-Q2": {
    "question_id": "P8-D1-Q2",
    "point": "P8",
    "dimension": "D1",
    "question_number": 2,
    "question_text": "Analyze gaps between current state and requirements",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "semantic_chunking_policy",
        "adapter_class": "SemanticChunkingPolicyAdapter",
        "method": "bayesian_evidence_integration",
        "args": [
          {
            "name": "chunks",
            "type": "List[Dict]",
            "source": "semantic_chunks"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "evidence_scores"
        },
        "source_module": "semantic_chunking_policy.py",
        "source_class": "SemanticChunkingPolicyAdapter",
        "source_method": "bayesian_evidence_integration",
        "purpose": "Integrate evidence from chunks with Bayesian scoring",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "chunks",
              "type": "List[Dict]",
              "source": "evidence_chunks"
            }
          ],
          "return_type": "Dict",
          "source_file": "semantic_chunking_policy.py"
        }
      },
      {
        "step": 2,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "extract_pdm_structure",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "pdm_structure"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "extract_pdm_structure",
        "purpose": "Extract P-D-Q structure for gap identification",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "Dict",
          "source_file": "emebedding_policy.py"
        }
      },
      {
        "step": 3,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "detect",
        "args": [
          {
            "name": "document",
            "type": "str",
            "source": "normalized_text"
          },
          {
            "name": "metadata",
            "type": "dict",
            "value": {
              "analysis_type": "gap_analysis"
            }
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "contradictions"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "detect",
        "purpose": "Detect contradictions indicating gaps",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [
            {
              "name": "document",
              "type": "str",
              "source": "normalized_text"
            },
            {
              "name": "metadata",
              "type": "dict",
              "value": {
                "analysis_type": "evidence_validation"
              }
            }
          ],
          "return_type": "Dict",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 4,
        "adapter": "analyzer_one",
        "adapter_class": "AnalyzerOneAdapter",
        "method": "analyze_semantic_coherence",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "coherence_analysis"
        },
        "source_module": "Analyzer_one.py",
        "source_class": "AnalyzerOneAdapter",
        "source_method": "analyze_semantic_coherence",
        "purpose": "Analyze semantic coherence to identify gaps",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "Dict",
          "source_file": "Analyzer_one.py"
        }
      }
    ],
    "contributing_modules": [
      "Analyzer_one.py",
      "contradiction_deteccion.py",
      "emebedding_policy.py",
      "semantic_chunking_policy.py"
    ],
    "primary_adapter": "semantic_chunking_policy",
    "evidence_types": [
      "coherence_analysis",
      "contradictions",
      "evidence_scores",
      "pdm_structure"
    ],
    "aggregation_strategy": "gap_identification",
    "confidence_threshold": 0.72,
    "total_steps": 4
  },
  "P9-D1-Q2": {
    "question_id": "P9-D1-Q2",
    "point": "P9",
    "dimension": "D1",
    "question_number": 2,
    "question_text": "Analyze gaps between current state and requirements",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "semantic_chunking_policy",
        "adapter_class": "SemanticChunkingPolicyAdapter",
        "method": "bayesian_evidence_integration",
        "args": [
          {
            "name": "chunks",
            "type": "List[Dict]",
            "source": "semantic_chunks"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "evidence_scores"
        },
        "source_module": "semantic_chunking_policy.py",
        "source_class": "SemanticChunkingPolicyAdapter",
        "source_method": "bayesian_evidence_integration",
        "purpose": "Integrate evidence from chunks with Bayesian scoring",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "chunks",
              "type": "List[Dict]",
              "source": "evidence_chunks"
            }
          ],
          "return_type": "Dict",
          "source_file": "semantic_chunking_policy.py"
        }
      },
      {
        "step": 2,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "extract_pdm_structure",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "pdm_structure"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "extract_pdm_structure",
        "purpose": "Extract P-D-Q structure for gap identification",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "Dict",
          "source_file": "emebedding_policy.py"
        }
      },
      {
        "step": 3,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "detect",
        "args": [
          {
            "name": "document",
            "type": "str",
            "source": "normalized_text"
          },
          {
            "name": "metadata",
            "type": "dict",
            "value": {
              "analysis_type": "gap_analysis"
            }
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "contradictions"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "detect",
        "purpose": "Detect contradictions indicating gaps",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [
            {
              "name": "document",
              "type": "str",
              "source": "normalized_text"
            },
            {
              "name": "metadata",
              "type": "dict",
              "value": {
                "analysis_type": "evidence_validation"
              }
            }
          ],
          "return_type": "Dict",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 4,
        "adapter": "analyzer_one",
        "adapter_class": "AnalyzerOneAdapter",
        "method": "analyze_semantic_coherence",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "coherence_analysis"
        },
        "source_module": "Analyzer_one.py",
        "source_class": "AnalyzerOneAdapter",
        "source_method": "analyze_semantic_coherence",
        "purpose": "Analyze semantic coherence to identify gaps",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "Dict",
          "source_file": "Analyzer_one.py"
        }
      }
    ],
    "contributing_modules": [
      "Analyzer_one.py",
      "contradiction_deteccion.py",
      "emebedding_policy.py",
      "semantic_chunking_policy.py"
    ],
    "primary_adapter": "semantic_chunking_policy",
    "evidence_types": [
      "coherence_analysis",
      "contradictions",
      "evidence_scores",
      "pdm_structure"
    ],
    "aggregation_strategy": "gap_identification",
    "confidence_threshold": 0.72,
    "total_steps": 4
  },
  "P10-D1-Q2": {
    "question_id": "P10-D1-Q2",
    "point": "P10",
    "dimension": "D1",
    "question_number": 2,
    "question_text": "Analyze gaps between current state and requirements",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "semantic_chunking_policy",
        "adapter_class": "SemanticChunkingPolicyAdapter",
        "method": "bayesian_evidence_integration",
        "args": [
          {
            "name": "chunks",
            "type": "List[Dict]",
            "source": "semantic_chunks"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "evidence_scores"
        },
        "source_module": "semantic_chunking_policy.py",
        "source_class": "SemanticChunkingPolicyAdapter",
        "source_method": "bayesian_evidence_integration",
        "purpose": "Integrate evidence from chunks with Bayesian scoring",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "chunks",
              "type": "List[Dict]",
              "source": "evidence_chunks"
            }
          ],
          "return_type": "Dict",
          "source_file": "semantic_chunking_policy.py"
        }
      },
      {
        "step": 2,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "extract_pdm_structure",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "pdm_structure"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "extract_pdm_structure",
        "purpose": "Extract P-D-Q structure for gap identification",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "Dict",
          "source_file": "emebedding_policy.py"
        }
      },
      {
        "step": 3,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "detect",
        "args": [
          {
            "name": "document",
            "type": "str",
            "source": "normalized_text"
          },
          {
            "name": "metadata",
            "type": "dict",
            "value": {
              "analysis_type": "gap_analysis"
            }
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "contradictions"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "detect",
        "purpose": "Detect contradictions indicating gaps",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [
            {
              "name": "document",
              "type": "str",
              "source": "normalized_text"
            },
            {
              "name": "metadata",
              "type": "dict",
              "value": {
                "analysis_type": "evidence_validation"
              }
            }
          ],
          "return_type": "Dict",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 4,
        "adapter": "analyzer_one",
        "adapter_class": "AnalyzerOneAdapter",
        "method": "analyze_semantic_coherence",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "coherence_analysis"
        },
        "source_module": "Analyzer_one.py",
        "source_class": "AnalyzerOneAdapter",
        "source_method": "analyze_semantic_coherence",
        "purpose": "Analyze semantic coherence to identify gaps",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "Dict",
          "source_file": "Analyzer_one.py"
        }
      }
    ],
    "contributing_modules": [
      "Analyzer_one.py",
      "contradiction_deteccion.py",
      "emebedding_policy.py",
      "semantic_chunking_policy.py"
    ],
    "primary_adapter": "semantic_chunking_policy",
    "evidence_types": [
      "coherence_analysis",
      "contradictions",
      "evidence_scores",
      "pdm_structure"
    ],
    "aggregation_strategy": "gap_identification",
    "confidence_threshold": 0.72,
    "total_steps": 4
  },
  "P1-D1-Q3": {
    "question_id": "P1-D1-Q3",
    "point": "P1",
    "dimension": "D1",
    "question_number": 3,
    "question_text": "Map available resources and capacities",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "financial_viability",
        "adapter_class": "FinancialViabilityAdapter",
        "method": "analyze_financial_feasibility",
        "args": [
          {
            "name": "tables",
            "type": "List",
            "source": "extracted_tables"
          },
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "financial_analysis"
        },
        "source_module": "financiero_viabilidad_tablas.py",
        "source_class": "FinancialViabilityAdapter",
        "source_method": "analyze_financial_feasibility",
        "purpose": "Analyze financial resources and feasibility",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [
            {
              "name": "tables",
              "type": "List",
              "source": "extracted_tables"
            },
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "Dict",
          "source_file": "financiero_viabilidad_tablas.py"
        }
      },
      {
        "step": 2,
        "adapter": "financial_viability",
        "adapter_class": "FinancialViabilityAdapter",
        "method": "identify_responsible_entities",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          },
          {
            "name": "tables",
            "type": "List",
            "source": "extracted_tables"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "responsible_entities"
        },
        "source_module": "financiero_viabilidad_tablas.py",
        "source_class": "FinancialViabilityAdapter",
        "source_method": "identify_responsible_entities",
        "purpose": "Identify entities responsible for resources",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            },
            {
              "name": "tables",
              "type": "List",
              "source": "extracted_tables"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "financiero_viabilidad_tablas.py"
        }
      },
      {
        "step": 3,
        "adapter": "policy_processor",
        "adapter_class": "PolicyProcessorAdapter",
        "method": "_extract_resource_mentions",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "resource_mentions"
        },
        "source_module": "policy_processor.py",
        "source_class": "PolicyProcessorAdapter",
        "source_method": "_extract_resource_mentions",
        "purpose": "Extract explicit resource mentions",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "policy_processor.py"
        }
      },
      {
        "step": 4,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "extract_numerical_claims",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "numerical_resources"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "extract_numerical_claims",
        "purpose": "Extract quantitative resource data",
        "confidence_expected": 0.9,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "emebedding_policy.py"
        }
      }
    ],
    "contributing_modules": [
      "emebedding_policy.py",
      "financiero_viabilidad_tablas.py",
      "policy_processor.py"
    ],
    "primary_adapter": "financial_viability",
    "evidence_types": [
      "financial_analysis",
      "numerical_resources",
      "resource_mentions",
      "responsible_entities"
    ],
    "aggregation_strategy": "resource_consolidation",
    "confidence_threshold": 0.75,
    "total_steps": 4
  },
  "P2-D1-Q3": {
    "question_id": "P2-D1-Q3",
    "point": "P2",
    "dimension": "D1",
    "question_number": 3,
    "question_text": "Map available resources and capacities",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "financial_viability",
        "adapter_class": "FinancialViabilityAdapter",
        "method": "analyze_financial_feasibility",
        "args": [
          {
            "name": "tables",
            "type": "List",
            "source": "extracted_tables"
          },
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "financial_analysis"
        },
        "source_module": "financiero_viabilidad_tablas.py",
        "source_class": "FinancialViabilityAdapter",
        "source_method": "analyze_financial_feasibility",
        "purpose": "Analyze financial resources and feasibility",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [
            {
              "name": "tables",
              "type": "List",
              "source": "extracted_tables"
            },
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "Dict",
          "source_file": "financiero_viabilidad_tablas.py"
        }
      },
      {
        "step": 2,
        "adapter": "financial_viability",
        "adapter_class": "FinancialViabilityAdapter",
        "method": "identify_responsible_entities",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          },
          {
            "name": "tables",
            "type": "List",
            "source": "extracted_tables"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "responsible_entities"
        },
        "source_module": "financiero_viabilidad_tablas.py",
        "source_class": "FinancialViabilityAdapter",
        "source_method": "identify_responsible_entities",
        "purpose": "Identify entities responsible for resources",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            },
            {
              "name": "tables",
              "type": "List",
              "source": "extracted_tables"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "financiero_viabilidad_tablas.py"
        }
      },
      {
        "step": 3,
        "adapter": "policy_processor",
        "adapter_class": "PolicyProcessorAdapter",
        "method": "_extract_resource_mentions",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "resource_mentions"
        },
        "source_module": "policy_processor.py",
        "source_class": "PolicyProcessorAdapter",
        "source_method": "_extract_resource_mentions",
        "purpose": "Extract explicit resource mentions",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "policy_processor.py"
        }
      },
      {
        "step": 4,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "extract_numerical_claims",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "numerical_resources"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "extract_numerical_claims",
        "purpose": "Extract quantitative resource data",
        "confidence_expected": 0.9,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "emebedding_policy.py"
        }
      }
    ],
    "contributing_modules": [
      "emebedding_policy.py",
      "financiero_viabilidad_tablas.py",
      "policy_processor.py"
    ],
    "primary_adapter": "financial_viability",
    "evidence_types": [
      "financial_analysis",
      "numerical_resources",
      "resource_mentions",
      "responsible_entities"
    ],
    "aggregation_strategy": "resource_consolidation",
    "confidence_threshold": 0.75,
    "total_steps": 4
  },
  "P3-D1-Q3": {
    "question_id": "P3-D1-Q3",
    "point": "P3",
    "dimension": "D1",
    "question_number": 3,
    "question_text": "Map available resources and capacities",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "financial_viability",
        "adapter_class": "FinancialViabilityAdapter",
        "method": "analyze_financial_feasibility",
        "args": [
          {
            "name": "tables",
            "type": "List",
            "source": "extracted_tables"
          },
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "financial_analysis"
        },
        "source_module": "financiero_viabilidad_tablas.py",
        "source_class": "FinancialViabilityAdapter",
        "source_method": "analyze_financial_feasibility",
        "purpose": "Analyze financial resources and feasibility",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [
            {
              "name": "tables",
              "type": "List",
              "source": "extracted_tables"
            },
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "Dict",
          "source_file": "financiero_viabilidad_tablas.py"
        }
      },
      {
        "step": 2,
        "adapter": "financial_viability",
        "adapter_class": "FinancialViabilityAdapter",
        "method": "identify_responsible_entities",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          },
          {
            "name": "tables",
            "type": "List",
            "source": "extracted_tables"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "responsible_entities"
        },
        "source_module": "financiero_viabilidad_tablas.py",
        "source_class": "FinancialViabilityAdapter",
        "source_method": "identify_responsible_entities",
        "purpose": "Identify entities responsible for resources",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            },
            {
              "name": "tables",
              "type": "List",
              "source": "extracted_tables"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "financiero_viabilidad_tablas.py"
        }
      },
      {
        "step": 3,
        "adapter": "policy_processor",
        "adapter_class": "PolicyProcessorAdapter",
        "method": "_extract_resource_mentions",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "resource_mentions"
        },
        "source_module": "policy_processor.py",
        "source_class": "PolicyProcessorAdapter",
        "source_method": "_extract_resource_mentions",
        "purpose": "Extract explicit resource mentions",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "policy_processor.py"
        }
      },
      {
        "step": 4,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "extract_numerical_claims",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "numerical_resources"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "extract_numerical_claims",
        "purpose": "Extract quantitative resource data",
        "confidence_expected": 0.9,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "emebedding_policy.py"
        }
      }
    ],
    "contributing_modules": [
      "emebedding_policy.py",
      "financiero_viabilidad_tablas.py",
      "policy_processor.py"
    ],
    "primary_adapter": "financial_viability",
    "evidence_types": [
      "financial_analysis",
      "numerical_resources",
      "resource_mentions",
      "responsible_entities"
    ],
    "aggregation_strategy": "resource_consolidation",
    "confidence_threshold": 0.75,
    "total_steps": 4
  },
  "P4-D1-Q3": {
    "question_id": "P4-D1-Q3",
    "point": "P4",
    "dimension": "D1",
    "question_number": 3,
    "question_text": "Map available resources and capacities",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "financial_viability",
        "adapter_class": "FinancialViabilityAdapter",
        "method": "analyze_financial_feasibility",
        "args": [
          {
            "name": "tables",
            "type": "List",
            "source": "extracted_tables"
          },
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "financial_analysis"
        },
        "source_module": "financiero_viabilidad_tablas.py",
        "source_class": "FinancialViabilityAdapter",
        "source_method": "analyze_financial_feasibility",
        "purpose": "Analyze financial resources and feasibility",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [
            {
              "name": "tables",
              "type": "List",
              "source": "extracted_tables"
            },
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "Dict",
          "source_file": "financiero_viabilidad_tablas.py"
        }
      },
      {
        "step": 2,
        "adapter": "financial_viability",
        "adapter_class": "FinancialViabilityAdapter",
        "method": "identify_responsible_entities",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          },
          {
            "name": "tables",
            "type": "List",
            "source": "extracted_tables"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "responsible_entities"
        },
        "source_module": "financiero_viabilidad_tablas.py",
        "source_class": "FinancialViabilityAdapter",
        "source_method": "identify_responsible_entities",
        "purpose": "Identify entities responsible for resources",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            },
            {
              "name": "tables",
              "type": "List",
              "source": "extracted_tables"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "financiero_viabilidad_tablas.py"
        }
      },
      {
        "step": 3,
        "adapter": "policy_processor",
        "adapter_class": "PolicyProcessorAdapter",
        "method": "_extract_resource_mentions",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "resource_mentions"
        },
        "source_module": "policy_processor.py",
        "source_class": "PolicyProcessorAdapter",
        "source_method": "_extract_resource_mentions",
        "purpose": "Extract explicit resource mentions",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "policy_processor.py"
        }
      },
      {
        "step": 4,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "extract_numerical_claims",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "numerical_resources"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "extract_numerical_claims",
        "purpose": "Extract quantitative resource data",
        "confidence_expected": 0.9,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "emebedding_policy.py"
        }
      }
    ],
    "contributing_modules": [
      "emebedding_policy.py",
      "financiero_viabilidad_tablas.py",
      "policy_processor.py"
    ],
    "primary_adapter": "financial_viability",
    "evidence_types": [
      "financial_analysis",
      "numerical_resources",
      "resource_mentions",
      "responsible_entities"
    ],
    "aggregation_strategy": "resource_consolidation",
    "confidence_threshold": 0.75,
    "total_steps": 4
  },
  "P5-D1-Q3": {
    "question_id": "P5-D1-Q3",
    "point": "P5",
    "dimension": "D1",
    "question_number": 3,
    "question_text": "Map available resources and capacities",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "financial_viability",
        "adapter_class": "FinancialViabilityAdapter",
        "method": "analyze_financial_feasibility",
        "args": [
          {
            "name": "tables",
            "type": "List",
            "source": "extracted_tables"
          },
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "financial_analysis"
        },
        "source_module": "financiero_viabilidad_tablas.py",
        "source_class": "FinancialViabilityAdapter",
        "source_method": "analyze_financial_feasibility",
        "purpose": "Analyze financial resources and feasibility",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [
            {
              "name": "tables",
              "type": "List",
              "source": "extracted_tables"
            },
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "Dict",
          "source_file": "financiero_viabilidad_tablas.py"
        }
      },
      {
        "step": 2,
        "adapter": "financial_viability",
        "adapter_class": "FinancialViabilityAdapter",
        "method": "identify_responsible_entities",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          },
          {
            "name": "tables",
            "type": "List",
            "source": "extracted_tables"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "responsible_entities"
        },
        "source_module": "financiero_viabilidad_tablas.py",
        "source_class": "FinancialViabilityAdapter",
        "source_method": "identify_responsible_entities",
        "purpose": "Identify entities responsible for resources",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            },
            {
              "name": "tables",
              "type": "List",
              "source": "extracted_tables"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "financiero_viabilidad_tablas.py"
        }
      },
      {
        "step": 3,
        "adapter": "policy_processor",
        "adapter_class": "PolicyProcessorAdapter",
        "method": "_extract_resource_mentions",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "resource_mentions"
        },
        "source_module": "policy_processor.py",
        "source_class": "PolicyProcessorAdapter",
        "source_method": "_extract_resource_mentions",
        "purpose": "Extract explicit resource mentions",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "policy_processor.py"
        }
      },
      {
        "step": 4,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "extract_numerical_claims",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "numerical_resources"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "extract_numerical_claims",
        "purpose": "Extract quantitative resource data",
        "confidence_expected": 0.9,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "emebedding_policy.py"
        }
      }
    ],
    "contributing_modules": [
      "emebedding_policy.py",
      "financiero_viabilidad_tablas.py",
      "policy_processor.py"
    ],
    "primary_adapter": "financial_viability",
    "evidence_types": [
      "financial_analysis",
      "numerical_resources",
      "resource_mentions",
      "responsible_entities"
    ],
    "aggregation_strategy": "resource_consolidation",
    "confidence_threshold": 0.75,
    "total_steps": 4
  },
  "P6-D1-Q3": {
    "question_id": "P6-D1-Q3",
    "point": "P6",
    "dimension": "D1",
    "question_number": 3,
    "question_text": "Map available resources and capacities",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "financial_viability",
        "adapter_class": "FinancialViabilityAdapter",
        "method": "analyze_financial_feasibility",
        "args": [
          {
            "name": "tables",
            "type": "List",
            "source": "extracted_tables"
          },
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "financial_analysis"
        },
        "source_module": "financiero_viabilidad_tablas.py",
        "source_class": "FinancialViabilityAdapter",
        "source_method": "analyze_financial_feasibility",
        "purpose": "Analyze financial resources and feasibility",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [
            {
              "name": "tables",
              "type": "List",
              "source": "extracted_tables"
            },
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "Dict",
          "source_file": "financiero_viabilidad_tablas.py"
        }
      },
      {
        "step": 2,
        "adapter": "financial_viability",
        "adapter_class": "FinancialViabilityAdapter",
        "method": "identify_responsible_entities",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          },
          {
            "name": "tables",
            "type": "List",
            "source": "extracted_tables"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "responsible_entities"
        },
        "source_module": "financiero_viabilidad_tablas.py",
        "source_class": "FinancialViabilityAdapter",
        "source_method": "identify_responsible_entities",
        "purpose": "Identify entities responsible for resources",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            },
            {
              "name": "tables",
              "type": "List",
              "source": "extracted_tables"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "financiero_viabilidad_tablas.py"
        }
      },
      {
        "step": 3,
        "adapter": "policy_processor",
        "adapter_class": "PolicyProcessorAdapter",
        "method": "_extract_resource_mentions",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "resource_mentions"
        },
        "source_module": "policy_processor.py",
        "source_class": "PolicyProcessorAdapter",
        "source_method": "_extract_resource_mentions",
        "purpose": "Extract explicit resource mentions",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "policy_processor.py"
        }
      },
      {
        "step": 4,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "extract_numerical_claims",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "numerical_resources"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "extract_numerical_claims",
        "purpose": "Extract quantitative resource data",
        "confidence_expected": 0.9,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "emebedding_policy.py"
        }
      }
    ],
    "contributing_modules": [
      "emebedding_policy.py",
      "financiero_viabilidad_tablas.py",
      "policy_processor.py"
    ],
    "primary_adapter": "financial_viability",
    "evidence_types": [
      "financial_analysis",
      "numerical_resources",
      "resource_mentions",
      "responsible_entities"
    ],
    "aggregation_strategy": "resource_consolidation",
    "confidence_threshold": 0.75,
    "total_steps": 4
  },
  "P7-D1-Q3": {
    "question_id": "P7-D1-Q3",
    "point": "P7",
    "dimension": "D1",
    "question_number": 3,
    "question_text": "Map available resources and capacities",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "financial_viability",
        "adapter_class": "FinancialViabilityAdapter",
        "method": "analyze_financial_feasibility",
        "args": [
          {
            "name": "tables",
            "type": "List",
            "source": "extracted_tables"
          },
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "financial_analysis"
        },
        "source_module": "financiero_viabilidad_tablas.py",
        "source_class": "FinancialViabilityAdapter",
        "source_method": "analyze_financial_feasibility",
        "purpose": "Analyze financial resources and feasibility",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [
            {
              "name": "tables",
              "type": "List",
              "source": "extracted_tables"
            },
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "Dict",
          "source_file": "financiero_viabilidad_tablas.py"
        }
      },
      {
        "step": 2,
        "adapter": "financial_viability",
        "adapter_class": "FinancialViabilityAdapter",
        "method": "identify_responsible_entities",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          },
          {
            "name": "tables",
            "type": "List",
            "source": "extracted_tables"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "responsible_entities"
        },
        "source_module": "financiero_viabilidad_tablas.py",
        "source_class": "FinancialViabilityAdapter",
        "source_method": "identify_responsible_entities",
        "purpose": "Identify entities responsible for resources",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            },
            {
              "name": "tables",
              "type": "List",
              "source": "extracted_tables"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "financiero_viabilidad_tablas.py"
        }
      },
      {
        "step": 3,
        "adapter": "policy_processor",
        "adapter_class": "PolicyProcessorAdapter",
        "method": "_extract_resource_mentions",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "resource_mentions"
        },
        "source_module": "policy_processor.py",
        "source_class": "PolicyProcessorAdapter",
        "source_method": "_extract_resource_mentions",
        "purpose": "Extract explicit resource mentions",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "policy_processor.py"
        }
      },
      {
        "step": 4,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "extract_numerical_claims",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "numerical_resources"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "extract_numerical_claims",
        "purpose": "Extract quantitative resource data",
        "confidence_expected": 0.9,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "emebedding_policy.py"
        }
      }
    ],
    "contributing_modules": [
      "emebedding_policy.py",
      "financiero_viabilidad_tablas.py",
      "policy_processor.py"
    ],
    "primary_adapter": "financial_viability",
    "evidence_types": [
      "financial_analysis",
      "numerical_resources",
      "resource_mentions",
      "responsible_entities"
    ],
    "aggregation_strategy": "resource_consolidation",
    "confidence_threshold": 0.75,
    "total_steps": 4
  },
  "P8-D1-Q3": {
    "question_id": "P8-D1-Q3",
    "point": "P8",
    "dimension": "D1",
    "question_number": 3,
    "question_text": "Map available resources and capacities",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "financial_viability",
        "adapter_class": "FinancialViabilityAdapter",
        "method": "analyze_financial_feasibility",
        "args": [
          {
            "name": "tables",
            "type": "List",
            "source": "extracted_tables"
          },
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "financial_analysis"
        },
        "source_module": "financiero_viabilidad_tablas.py",
        "source_class": "FinancialViabilityAdapter",
        "source_method": "analyze_financial_feasibility",
        "purpose": "Analyze financial resources and feasibility",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [
            {
              "name": "tables",
              "type": "List",
              "source": "extracted_tables"
            },
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "Dict",
          "source_file": "financiero_viabilidad_tablas.py"
        }
      },
      {
        "step": 2,
        "adapter": "financial_viability",
        "adapter_class": "FinancialViabilityAdapter",
        "method": "identify_responsible_entities",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          },
          {
            "name": "tables",
            "type": "List",
            "source": "extracted_tables"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "responsible_entities"
        },
        "source_module": "financiero_viabilidad_tablas.py",
        "source_class": "FinancialViabilityAdapter",
        "source_method": "identify_responsible_entities",
        "purpose": "Identify entities responsible for resources",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            },
            {
              "name": "tables",
              "type": "List",
              "source": "extracted_tables"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "financiero_viabilidad_tablas.py"
        }
      },
      {
        "step": 3,
        "adapter": "policy_processor",
        "adapter_class": "PolicyProcessorAdapter",
        "method": "_extract_resource_mentions",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "resource_mentions"
        },
        "source_module": "policy_processor.py",
        "source_class": "PolicyProcessorAdapter",
        "source_method": "_extract_resource_mentions",
        "purpose": "Extract explicit resource mentions",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "policy_processor.py"
        }
      },
      {
        "step": 4,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "extract_numerical_claims",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "numerical_resources"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "extract_numerical_claims",
        "purpose": "Extract quantitative resource data",
        "confidence_expected": 0.9,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "emebedding_policy.py"
        }
      }
    ],
    "contributing_modules": [
      "emebedding_policy.py",
      "financiero_viabilidad_tablas.py",
      "policy_processor.py"
    ],
    "primary_adapter": "financial_viability",
    "evidence_types": [
      "financial_analysis",
      "numerical_resources",
      "resource_mentions",
      "responsible_entities"
    ],
    "aggregation_strategy": "resource_consolidation",
    "confidence_threshold": 0.75,
    "total_steps": 4
  },
  "P9-D1-Q3": {
    "question_id": "P9-D1-Q3",
    "point": "P9",
    "dimension": "D1",
    "question_number": 3,
    "question_text": "Map available resources and capacities",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "financial_viability",
        "adapter_class": "FinancialViabilityAdapter",
        "method": "analyze_financial_feasibility",
        "args": [
          {
            "name": "tables",
            "type": "List",
            "source": "extracted_tables"
          },
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "financial_analysis"
        },
        "source_module": "financiero_viabilidad_tablas.py",
        "source_class": "FinancialViabilityAdapter",
        "source_method": "analyze_financial_feasibility",
        "purpose": "Analyze financial resources and feasibility",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [
            {
              "name": "tables",
              "type": "List",
              "source": "extracted_tables"
            },
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "Dict",
          "source_file": "financiero_viabilidad_tablas.py"
        }
      },
      {
        "step": 2,
        "adapter": "financial_viability",
        "adapter_class": "FinancialViabilityAdapter",
        "method": "identify_responsible_entities",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          },
          {
            "name": "tables",
            "type": "List",
            "source": "extracted_tables"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "responsible_entities"
        },
        "source_module": "financiero_viabilidad_tablas.py",
        "source_class": "FinancialViabilityAdapter",
        "source_method": "identify_responsible_entities",
        "purpose": "Identify entities responsible for resources",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            },
            {
              "name": "tables",
              "type": "List",
              "source": "extracted_tables"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "financiero_viabilidad_tablas.py"
        }
      },
      {
        "step": 3,
        "adapter": "policy_processor",
        "adapter_class": "PolicyProcessorAdapter",
        "method": "_extract_resource_mentions",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "resource_mentions"
        },
        "source_module": "policy_processor.py",
        "source_class": "PolicyProcessorAdapter",
        "source_method": "_extract_resource_mentions",
        "purpose": "Extract explicit resource mentions",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "policy_processor.py"
        }
      },
      {
        "step": 4,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "extract_numerical_claims",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "numerical_resources"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "extract_numerical_claims",
        "purpose": "Extract quantitative resource data",
        "confidence_expected": 0.9,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "emebedding_policy.py"
        }
      }
    ],
    "contributing_modules": [
      "emebedding_policy.py",
      "financiero_viabilidad_tablas.py",
      "policy_processor.py"
    ],
    "primary_adapter": "financial_viability",
    "evidence_types": [
      "financial_analysis",
      "numerical_resources",
      "resource_mentions",
      "responsible_entities"
    ],
    "aggregation_strategy": "resource_consolidation",
    "confidence_threshold": 0.75,
    "total_steps": 4
  },
  "P10-D1-Q3": {
    "question_id": "P10-D1-Q3",
    "point": "P10",
    "dimension": "D1",
    "question_number": 3,
    "question_text": "Map available resources and capacities",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "financial_viability",
        "adapter_class": "FinancialViabilityAdapter",
        "method": "analyze_financial_feasibility",
        "args": [
          {
            "name": "tables",
            "type": "List",
            "source": "extracted_tables"
          },
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "financial_analysis"
        },
        "source_module": "financiero_viabilidad_tablas.py",
        "source_class": "FinancialViabilityAdapter",
        "source_method": "analyze_financial_feasibility",
        "purpose": "Analyze financial resources and feasibility",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [
            {
              "name": "tables",
              "type": "List",
              "source": "extracted_tables"
            },
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "Dict",
          "source_file": "financiero_viabilidad_tablas.py"
        }
      },
      {
        "step": 2,
        "adapter": "financial_viability",
        "adapter_class": "FinancialViabilityAdapter",
        "method": "identify_responsible_entities",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          },
          {
            "name": "tables",
            "type": "List",
            "source": "extracted_tables"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "responsible_entities"
        },
        "source_module": "financiero_viabilidad_tablas.py",
        "source_class": "FinancialViabilityAdapter",
        "source_method": "identify_responsible_entities",
        "purpose": "Identify entities responsible for resources",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            },
            {
              "name": "tables",
              "type": "List",
              "source": "extracted_tables"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "financiero_viabilidad_tablas.py"
        }
      },
      {
        "step": 3,
        "adapter": "policy_processor",
        "adapter_class": "PolicyProcessorAdapter",
        "method": "_extract_resource_mentions",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "resource_mentions"
        },
        "source_module": "policy_processor.py",
        "source_class": "PolicyProcessorAdapter",
        "source_method": "_extract_resource_mentions",
        "purpose": "Extract explicit resource mentions",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "policy_processor.py"
        }
      },
      {
        "step": 4,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "extract_numerical_claims",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "numerical_resources"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "extract_numerical_claims",
        "purpose": "Extract quantitative resource data",
        "confidence_expected": 0.9,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "emebedding_policy.py"
        }
      }
    ],
    "contributing_modules": [
      "emebedding_policy.py",
      "financiero_viabilidad_tablas.py",
      "policy_processor.py"
    ],
    "primary_adapter": "financial_viability",
    "evidence_types": [
      "financial_analysis",
      "numerical_resources",
      "resource_mentions",
      "responsible_entities"
    ],
    "aggregation_strategy": "resource_consolidation",
    "confidence_threshold": 0.75,
    "total_steps": 4
  },
  "P1-D1-Q4": {
    "question_id": "P1-D1-Q4",
    "point": "P1",
    "dimension": "D1",
    "question_number": 4,
    "question_text": "Assess institutional capacity and readiness",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "financial_viability",
        "adapter_class": "FinancialViabilityAdapter",
        "method": "_classify_entity_type",
        "args": [
          {
            "name": "entity",
            "type": "str",
            "source": "entity_name"
          }
        ],
        "returns": {
          "type": "str",
          "binding": "entity_classification"
        },
        "source_module": "financiero_viabilidad_tablas.py",
        "source_class": "FinancialViabilityAdapter",
        "source_method": "_classify_entity_type",
        "purpose": "Classify institutional entity types",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "entity",
              "type": "str",
              "source": "entity_name"
            }
          ],
          "return_type": "str",
          "source_file": "financiero_viabilidad_tablas.py"
        }
      },
      {
        "step": 2,
        "adapter": "analyzer_one",
        "adapter_class": "AnalyzerOneAdapter",
        "method": "calculate_performance_scores",
        "args": [
          {
            "name": "indicators",
            "type": "List[Dict]",
            "source": "extracted_indicators"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "performance_scores"
        },
        "source_module": "Analyzer_one.py",
        "source_class": "AnalyzerOneAdapter",
        "source_method": "calculate_performance_scores",
        "purpose": "Calculate institutional performance metrics",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "indicators",
              "type": "List[Dict]",
              "source": "extracted_indicators"
            }
          ],
          "return_type": "Dict",
          "source_file": "Analyzer_one.py"
        }
      },
      {
        "step": 3,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "assess_mechanism_capacity",
        "args": [
          {
            "name": "mechanism",
            "type": "Dict",
            "source": "institutional_mechanism"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "capacity_assessment"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "assess_mechanism_capacity",
        "purpose": "Assess capacity of institutional mechanisms",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [
            {
              "name": "mechanism",
              "type": "Dict",
              "source": "institutional_mechanism"
            }
          ],
          "return_type": "Dict",
          "source_file": "dereck_beach.py"
        }
      },
      {
        "step": 4,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "calculate_bayesian_confidence",
        "args": [
          {
            "name": "priors",
            "type": "Dict",
            "source": "prior_assessments"
          },
          {
            "name": "evidence",
            "type": "List",
            "source": "capacity_evidence"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "capacity_confidence"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "calculate_bayesian_confidence",
        "purpose": "Calculate Bayesian confidence in capacity",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "priors",
              "type": "Dict",
              "source": "outcome_priors"
            },
            {
              "name": "evidence",
              "type": "List",
              "source": "measurement_evidence"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      }
    ],
    "contributing_modules": [
      "Analyzer_one.py",
      "dereck_beach.py",
      "financiero_viabilidad_tablas.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "financial_viability",
    "evidence_types": [
      "capacity_assessment",
      "capacity_confidence",
      "entity_classification",
      "performance_scores"
    ],
    "aggregation_strategy": "capacity_weighted_average",
    "confidence_threshold": 0.78,
    "total_steps": 4
  },
  "P2-D1-Q4": {
    "question_id": "P2-D1-Q4",
    "point": "P2",
    "dimension": "D1",
    "question_number": 4,
    "question_text": "Assess institutional capacity and readiness",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "financial_viability",
        "adapter_class": "FinancialViabilityAdapter",
        "method": "_classify_entity_type",
        "args": [
          {
            "name": "entity",
            "type": "str",
            "source": "entity_name"
          }
        ],
        "returns": {
          "type": "str",
          "binding": "entity_classification"
        },
        "source_module": "financiero_viabilidad_tablas.py",
        "source_class": "FinancialViabilityAdapter",
        "source_method": "_classify_entity_type",
        "purpose": "Classify institutional entity types",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "entity",
              "type": "str",
              "source": "entity_name"
            }
          ],
          "return_type": "str",
          "source_file": "financiero_viabilidad_tablas.py"
        }
      },
      {
        "step": 2,
        "adapter": "analyzer_one",
        "adapter_class": "AnalyzerOneAdapter",
        "method": "calculate_performance_scores",
        "args": [
          {
            "name": "indicators",
            "type": "List[Dict]",
            "source": "extracted_indicators"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "performance_scores"
        },
        "source_module": "Analyzer_one.py",
        "source_class": "AnalyzerOneAdapter",
        "source_method": "calculate_performance_scores",
        "purpose": "Calculate institutional performance metrics",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "indicators",
              "type": "List[Dict]",
              "source": "extracted_indicators"
            }
          ],
          "return_type": "Dict",
          "source_file": "Analyzer_one.py"
        }
      },
      {
        "step": 3,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "assess_mechanism_capacity",
        "args": [
          {
            "name": "mechanism",
            "type": "Dict",
            "source": "institutional_mechanism"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "capacity_assessment"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "assess_mechanism_capacity",
        "purpose": "Assess capacity of institutional mechanisms",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [
            {
              "name": "mechanism",
              "type": "Dict",
              "source": "institutional_mechanism"
            }
          ],
          "return_type": "Dict",
          "source_file": "dereck_beach.py"
        }
      },
      {
        "step": 4,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "calculate_bayesian_confidence",
        "args": [
          {
            "name": "priors",
            "type": "Dict",
            "source": "prior_assessments"
          },
          {
            "name": "evidence",
            "type": "List",
            "source": "capacity_evidence"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "capacity_confidence"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "calculate_bayesian_confidence",
        "purpose": "Calculate Bayesian confidence in capacity",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "priors",
              "type": "Dict",
              "source": "outcome_priors"
            },
            {
              "name": "evidence",
              "type": "List",
              "source": "measurement_evidence"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      }
    ],
    "contributing_modules": [
      "Analyzer_one.py",
      "dereck_beach.py",
      "financiero_viabilidad_tablas.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "financial_viability",
    "evidence_types": [
      "capacity_assessment",
      "capacity_confidence",
      "entity_classification",
      "performance_scores"
    ],
    "aggregation_strategy": "capacity_weighted_average",
    "confidence_threshold": 0.78,
    "total_steps": 4
  },
  "P3-D1-Q4": {
    "question_id": "P3-D1-Q4",
    "point": "P3",
    "dimension": "D1",
    "question_number": 4,
    "question_text": "Assess institutional capacity and readiness",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "financial_viability",
        "adapter_class": "FinancialViabilityAdapter",
        "method": "_classify_entity_type",
        "args": [
          {
            "name": "entity",
            "type": "str",
            "source": "entity_name"
          }
        ],
        "returns": {
          "type": "str",
          "binding": "entity_classification"
        },
        "source_module": "financiero_viabilidad_tablas.py",
        "source_class": "FinancialViabilityAdapter",
        "source_method": "_classify_entity_type",
        "purpose": "Classify institutional entity types",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "entity",
              "type": "str",
              "source": "entity_name"
            }
          ],
          "return_type": "str",
          "source_file": "financiero_viabilidad_tablas.py"
        }
      },
      {
        "step": 2,
        "adapter": "analyzer_one",
        "adapter_class": "AnalyzerOneAdapter",
        "method": "calculate_performance_scores",
        "args": [
          {
            "name": "indicators",
            "type": "List[Dict]",
            "source": "extracted_indicators"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "performance_scores"
        },
        "source_module": "Analyzer_one.py",
        "source_class": "AnalyzerOneAdapter",
        "source_method": "calculate_performance_scores",
        "purpose": "Calculate institutional performance metrics",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "indicators",
              "type": "List[Dict]",
              "source": "extracted_indicators"
            }
          ],
          "return_type": "Dict",
          "source_file": "Analyzer_one.py"
        }
      },
      {
        "step": 3,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "assess_mechanism_capacity",
        "args": [
          {
            "name": "mechanism",
            "type": "Dict",
            "source": "institutional_mechanism"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "capacity_assessment"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "assess_mechanism_capacity",
        "purpose": "Assess capacity of institutional mechanisms",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [
            {
              "name": "mechanism",
              "type": "Dict",
              "source": "institutional_mechanism"
            }
          ],
          "return_type": "Dict",
          "source_file": "dereck_beach.py"
        }
      },
      {
        "step": 4,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "calculate_bayesian_confidence",
        "args": [
          {
            "name": "priors",
            "type": "Dict",
            "source": "prior_assessments"
          },
          {
            "name": "evidence",
            "type": "List",
            "source": "capacity_evidence"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "capacity_confidence"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "calculate_bayesian_confidence",
        "purpose": "Calculate Bayesian confidence in capacity",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "priors",
              "type": "Dict",
              "source": "outcome_priors"
            },
            {
              "name": "evidence",
              "type": "List",
              "source": "measurement_evidence"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      }
    ],
    "contributing_modules": [
      "Analyzer_one.py",
      "dereck_beach.py",
      "financiero_viabilidad_tablas.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "financial_viability",
    "evidence_types": [
      "capacity_assessment",
      "capacity_confidence",
      "entity_classification",
      "performance_scores"
    ],
    "aggregation_strategy": "capacity_weighted_average",
    "confidence_threshold": 0.78,
    "total_steps": 4
  },
  "P4-D1-Q4": {
    "question_id": "P4-D1-Q4",
    "point": "P4",
    "dimension": "D1",
    "question_number": 4,
    "question_text": "Assess institutional capacity and readiness",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "financial_viability",
        "adapter_class": "FinancialViabilityAdapter",
        "method": "_classify_entity_type",
        "args": [
          {
            "name": "entity",
            "type": "str",
            "source": "entity_name"
          }
        ],
        "returns": {
          "type": "str",
          "binding": "entity_classification"
        },
        "source_module": "financiero_viabilidad_tablas.py",
        "source_class": "FinancialViabilityAdapter",
        "source_method": "_classify_entity_type",
        "purpose": "Classify institutional entity types",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "entity",
              "type": "str",
              "source": "entity_name"
            }
          ],
          "return_type": "str",
          "source_file": "financiero_viabilidad_tablas.py"
        }
      },
      {
        "step": 2,
        "adapter": "analyzer_one",
        "adapter_class": "AnalyzerOneAdapter",
        "method": "calculate_performance_scores",
        "args": [
          {
            "name": "indicators",
            "type": "List[Dict]",
            "source": "extracted_indicators"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "performance_scores"
        },
        "source_module": "Analyzer_one.py",
        "source_class": "AnalyzerOneAdapter",
        "source_method": "calculate_performance_scores",
        "purpose": "Calculate institutional performance metrics",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "indicators",
              "type": "List[Dict]",
              "source": "extracted_indicators"
            }
          ],
          "return_type": "Dict",
          "source_file": "Analyzer_one.py"
        }
      },
      {
        "step": 3,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "assess_mechanism_capacity",
        "args": [
          {
            "name": "mechanism",
            "type": "Dict",
            "source": "institutional_mechanism"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "capacity_assessment"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "assess_mechanism_capacity",
        "purpose": "Assess capacity of institutional mechanisms",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [
            {
              "name": "mechanism",
              "type": "Dict",
              "source": "institutional_mechanism"
            }
          ],
          "return_type": "Dict",
          "source_file": "dereck_beach.py"
        }
      },
      {
        "step": 4,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "calculate_bayesian_confidence",
        "args": [
          {
            "name": "priors",
            "type": "Dict",
            "source": "prior_assessments"
          },
          {
            "name": "evidence",
            "type": "List",
            "source": "capacity_evidence"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "capacity_confidence"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "calculate_bayesian_confidence",
        "purpose": "Calculate Bayesian confidence in capacity",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "priors",
              "type": "Dict",
              "source": "outcome_priors"
            },
            {
              "name": "evidence",
              "type": "List",
              "source": "measurement_evidence"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      }
    ],
    "contributing_modules": [
      "Analyzer_one.py",
      "dereck_beach.py",
      "financiero_viabilidad_tablas.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "financial_viability",
    "evidence_types": [
      "capacity_assessment",
      "capacity_confidence",
      "entity_classification",
      "performance_scores"
    ],
    "aggregation_strategy": "capacity_weighted_average",
    "confidence_threshold": 0.78,
    "total_steps": 4
  },
  "P5-D1-Q4": {
    "question_id": "P5-D1-Q4",
    "point": "P5",
    "dimension": "D1",
    "question_number": 4,
    "question_text": "Assess institutional capacity and readiness",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "financial_viability",
        "adapter_class": "FinancialViabilityAdapter",
        "method": "_classify_entity_type",
        "args": [
          {
            "name": "entity",
            "type": "str",
            "source": "entity_name"
          }
        ],
        "returns": {
          "type": "str",
          "binding": "entity_classification"
        },
        "source_module": "financiero_viabilidad_tablas.py",
        "source_class": "FinancialViabilityAdapter",
        "source_method": "_classify_entity_type",
        "purpose": "Classify institutional entity types",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "entity",
              "type": "str",
              "source": "entity_name"
            }
          ],
          "return_type": "str",
          "source_file": "financiero_viabilidad_tablas.py"
        }
      },
      {
        "step": 2,
        "adapter": "analyzer_one",
        "adapter_class": "AnalyzerOneAdapter",
        "method": "calculate_performance_scores",
        "args": [
          {
            "name": "indicators",
            "type": "List[Dict]",
            "source": "extracted_indicators"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "performance_scores"
        },
        "source_module": "Analyzer_one.py",
        "source_class": "AnalyzerOneAdapter",
        "source_method": "calculate_performance_scores",
        "purpose": "Calculate institutional performance metrics",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "indicators",
              "type": "List[Dict]",
              "source": "extracted_indicators"
            }
          ],
          "return_type": "Dict",
          "source_file": "Analyzer_one.py"
        }
      },
      {
        "step": 3,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "assess_mechanism_capacity",
        "args": [
          {
            "name": "mechanism",
            "type": "Dict",
            "source": "institutional_mechanism"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "capacity_assessment"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "assess_mechanism_capacity",
        "purpose": "Assess capacity of institutional mechanisms",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [
            {
              "name": "mechanism",
              "type": "Dict",
              "source": "institutional_mechanism"
            }
          ],
          "return_type": "Dict",
          "source_file": "dereck_beach.py"
        }
      },
      {
        "step": 4,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "calculate_bayesian_confidence",
        "args": [
          {
            "name": "priors",
            "type": "Dict",
            "source": "prior_assessments"
          },
          {
            "name": "evidence",
            "type": "List",
            "source": "capacity_evidence"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "capacity_confidence"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "calculate_bayesian_confidence",
        "purpose": "Calculate Bayesian confidence in capacity",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "priors",
              "type": "Dict",
              "source": "outcome_priors"
            },
            {
              "name": "evidence",
              "type": "List",
              "source": "measurement_evidence"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      }
    ],
    "contributing_modules": [
      "Analyzer_one.py",
      "dereck_beach.py",
      "financiero_viabilidad_tablas.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "financial_viability",
    "evidence_types": [
      "capacity_assessment",
      "capacity_confidence",
      "entity_classification",
      "performance_scores"
    ],
    "aggregation_strategy": "capacity_weighted_average",
    "confidence_threshold": 0.78,
    "total_steps": 4
  },
  "P6-D1-Q4": {
    "question_id": "P6-D1-Q4",
    "point": "P6",
    "dimension": "D1",
    "question_number": 4,
    "question_text": "Assess institutional capacity and readiness",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "financial_viability",
        "adapter_class": "FinancialViabilityAdapter",
        "method": "_classify_entity_type",
        "args": [
          {
            "name": "entity",
            "type": "str",
            "source": "entity_name"
          }
        ],
        "returns": {
          "type": "str",
          "binding": "entity_classification"
        },
        "source_module": "financiero_viabilidad_tablas.py",
        "source_class": "FinancialViabilityAdapter",
        "source_method": "_classify_entity_type",
        "purpose": "Classify institutional entity types",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "entity",
              "type": "str",
              "source": "entity_name"
            }
          ],
          "return_type": "str",
          "source_file": "financiero_viabilidad_tablas.py"
        }
      },
      {
        "step": 2,
        "adapter": "analyzer_one",
        "adapter_class": "AnalyzerOneAdapter",
        "method": "calculate_performance_scores",
        "args": [
          {
            "name": "indicators",
            "type": "List[Dict]",
            "source": "extracted_indicators"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "performance_scores"
        },
        "source_module": "Analyzer_one.py",
        "source_class": "AnalyzerOneAdapter",
        "source_method": "calculate_performance_scores",
        "purpose": "Calculate institutional performance metrics",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "indicators",
              "type": "List[Dict]",
              "source": "extracted_indicators"
            }
          ],
          "return_type": "Dict",
          "source_file": "Analyzer_one.py"
        }
      },
      {
        "step": 3,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "assess_mechanism_capacity",
        "args": [
          {
            "name": "mechanism",
            "type": "Dict",
            "source": "institutional_mechanism"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "capacity_assessment"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "assess_mechanism_capacity",
        "purpose": "Assess capacity of institutional mechanisms",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [
            {
              "name": "mechanism",
              "type": "Dict",
              "source": "institutional_mechanism"
            }
          ],
          "return_type": "Dict",
          "source_file": "dereck_beach.py"
        }
      },
      {
        "step": 4,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "calculate_bayesian_confidence",
        "args": [
          {
            "name": "priors",
            "type": "Dict",
            "source": "prior_assessments"
          },
          {
            "name": "evidence",
            "type": "List",
            "source": "capacity_evidence"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "capacity_confidence"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "calculate_bayesian_confidence",
        "purpose": "Calculate Bayesian confidence in capacity",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "priors",
              "type": "Dict",
              "source": "outcome_priors"
            },
            {
              "name": "evidence",
              "type": "List",
              "source": "measurement_evidence"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      }
    ],
    "contributing_modules": [
      "Analyzer_one.py",
      "dereck_beach.py",
      "financiero_viabilidad_tablas.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "financial_viability",
    "evidence_types": [
      "capacity_assessment",
      "capacity_confidence",
      "entity_classification",
      "performance_scores"
    ],
    "aggregation_strategy": "capacity_weighted_average",
    "confidence_threshold": 0.78,
    "total_steps": 4
  },
  "P7-D1-Q4": {
    "question_id": "P7-D1-Q4",
    "point": "P7",
    "dimension": "D1",
    "question_number": 4,
    "question_text": "Assess institutional capacity and readiness",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "financial_viability",
        "adapter_class": "FinancialViabilityAdapter",
        "method": "_classify_entity_type",
        "args": [
          {
            "name": "entity",
            "type": "str",
            "source": "entity_name"
          }
        ],
        "returns": {
          "type": "str",
          "binding": "entity_classification"
        },
        "source_module": "financiero_viabilidad_tablas.py",
        "source_class": "FinancialViabilityAdapter",
        "source_method": "_classify_entity_type",
        "purpose": "Classify institutional entity types",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "entity",
              "type": "str",
              "source": "entity_name"
            }
          ],
          "return_type": "str",
          "source_file": "financiero_viabilidad_tablas.py"
        }
      },
      {
        "step": 2,
        "adapter": "analyzer_one",
        "adapter_class": "AnalyzerOneAdapter",
        "method": "calculate_performance_scores",
        "args": [
          {
            "name": "indicators",
            "type": "List[Dict]",
            "source": "extracted_indicators"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "performance_scores"
        },
        "source_module": "Analyzer_one.py",
        "source_class": "AnalyzerOneAdapter",
        "source_method": "calculate_performance_scores",
        "purpose": "Calculate institutional performance metrics",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "indicators",
              "type": "List[Dict]",
              "source": "extracted_indicators"
            }
          ],
          "return_type": "Dict",
          "source_file": "Analyzer_one.py"
        }
      },
      {
        "step": 3,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "assess_mechanism_capacity",
        "args": [
          {
            "name": "mechanism",
            "type": "Dict",
            "source": "institutional_mechanism"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "capacity_assessment"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "assess_mechanism_capacity",
        "purpose": "Assess capacity of institutional mechanisms",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [
            {
              "name": "mechanism",
              "type": "Dict",
              "source": "institutional_mechanism"
            }
          ],
          "return_type": "Dict",
          "source_file": "dereck_beach.py"
        }
      },
      {
        "step": 4,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "calculate_bayesian_confidence",
        "args": [
          {
            "name": "priors",
            "type": "Dict",
            "source": "prior_assessments"
          },
          {
            "name": "evidence",
            "type": "List",
            "source": "capacity_evidence"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "capacity_confidence"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "calculate_bayesian_confidence",
        "purpose": "Calculate Bayesian confidence in capacity",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "priors",
              "type": "Dict",
              "source": "outcome_priors"
            },
            {
              "name": "evidence",
              "type": "List",
              "source": "measurement_evidence"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      }
    ],
    "contributing_modules": [
      "Analyzer_one.py",
      "dereck_beach.py",
      "financiero_viabilidad_tablas.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "financial_viability",
    "evidence_types": [
      "capacity_assessment",
      "capacity_confidence",
      "entity_classification",
      "performance_scores"
    ],
    "aggregation_strategy": "capacity_weighted_average",
    "confidence_threshold": 0.78,
    "total_steps": 4
  },
  "P8-D1-Q4": {
    "question_id": "P8-D1-Q4",
    "point": "P8",
    "dimension": "D1",
    "question_number": 4,
    "question_text": "Assess institutional capacity and readiness",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "financial_viability",
        "adapter_class": "FinancialViabilityAdapter",
        "method": "_classify_entity_type",
        "args": [
          {
            "name": "entity",
            "type": "str",
            "source": "entity_name"
          }
        ],
        "returns": {
          "type": "str",
          "binding": "entity_classification"
        },
        "source_module": "financiero_viabilidad_tablas.py",
        "source_class": "FinancialViabilityAdapter",
        "source_method": "_classify_entity_type",
        "purpose": "Classify institutional entity types",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "entity",
              "type": "str",
              "source": "entity_name"
            }
          ],
          "return_type": "str",
          "source_file": "financiero_viabilidad_tablas.py"
        }
      },
      {
        "step": 2,
        "adapter": "analyzer_one",
        "adapter_class": "AnalyzerOneAdapter",
        "method": "calculate_performance_scores",
        "args": [
          {
            "name": "indicators",
            "type": "List[Dict]",
            "source": "extracted_indicators"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "performance_scores"
        },
        "source_module": "Analyzer_one.py",
        "source_class": "AnalyzerOneAdapter",
        "source_method": "calculate_performance_scores",
        "purpose": "Calculate institutional performance metrics",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "indicators",
              "type": "List[Dict]",
              "source": "extracted_indicators"
            }
          ],
          "return_type": "Dict",
          "source_file": "Analyzer_one.py"
        }
      },
      {
        "step": 3,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "assess_mechanism_capacity",
        "args": [
          {
            "name": "mechanism",
            "type": "Dict",
            "source": "institutional_mechanism"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "capacity_assessment"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "assess_mechanism_capacity",
        "purpose": "Assess capacity of institutional mechanisms",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [
            {
              "name": "mechanism",
              "type": "Dict",
              "source": "institutional_mechanism"
            }
          ],
          "return_type": "Dict",
          "source_file": "dereck_beach.py"
        }
      },
      {
        "step": 4,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "calculate_bayesian_confidence",
        "args": [
          {
            "name": "priors",
            "type": "Dict",
            "source": "prior_assessments"
          },
          {
            "name": "evidence",
            "type": "List",
            "source": "capacity_evidence"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "capacity_confidence"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "calculate_bayesian_confidence",
        "purpose": "Calculate Bayesian confidence in capacity",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "priors",
              "type": "Dict",
              "source": "outcome_priors"
            },
            {
              "name": "evidence",
              "type": "List",
              "source": "measurement_evidence"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      }
    ],
    "contributing_modules": [
      "Analyzer_one.py",
      "dereck_beach.py",
      "financiero_viabilidad_tablas.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "financial_viability",
    "evidence_types": [
      "capacity_assessment",
      "capacity_confidence",
      "entity_classification",
      "performance_scores"
    ],
    "aggregation_strategy": "capacity_weighted_average",
    "confidence_threshold": 0.78,
    "total_steps": 4
  },
  "P9-D1-Q4": {
    "question_id": "P9-D1-Q4",
    "point": "P9",
    "dimension": "D1",
    "question_number": 4,
    "question_text": "Assess institutional capacity and readiness",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "financial_viability",
        "adapter_class": "FinancialViabilityAdapter",
        "method": "_classify_entity_type",
        "args": [
          {
            "name": "entity",
            "type": "str",
            "source": "entity_name"
          }
        ],
        "returns": {
          "type": "str",
          "binding": "entity_classification"
        },
        "source_module": "financiero_viabilidad_tablas.py",
        "source_class": "FinancialViabilityAdapter",
        "source_method": "_classify_entity_type",
        "purpose": "Classify institutional entity types",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "entity",
              "type": "str",
              "source": "entity_name"
            }
          ],
          "return_type": "str",
          "source_file": "financiero_viabilidad_tablas.py"
        }
      },
      {
        "step": 2,
        "adapter": "analyzer_one",
        "adapter_class": "AnalyzerOneAdapter",
        "method": "calculate_performance_scores",
        "args": [
          {
            "name": "indicators",
            "type": "List[Dict]",
            "source": "extracted_indicators"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "performance_scores"
        },
        "source_module": "Analyzer_one.py",
        "source_class": "AnalyzerOneAdapter",
        "source_method": "calculate_performance_scores",
        "purpose": "Calculate institutional performance metrics",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "indicators",
              "type": "List[Dict]",
              "source": "extracted_indicators"
            }
          ],
          "return_type": "Dict",
          "source_file": "Analyzer_one.py"
        }
      },
      {
        "step": 3,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "assess_mechanism_capacity",
        "args": [
          {
            "name": "mechanism",
            "type": "Dict",
            "source": "institutional_mechanism"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "capacity_assessment"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "assess_mechanism_capacity",
        "purpose": "Assess capacity of institutional mechanisms",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [
            {
              "name": "mechanism",
              "type": "Dict",
              "source": "institutional_mechanism"
            }
          ],
          "return_type": "Dict",
          "source_file": "dereck_beach.py"
        }
      },
      {
        "step": 4,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "calculate_bayesian_confidence",
        "args": [
          {
            "name": "priors",
            "type": "Dict",
            "source": "prior_assessments"
          },
          {
            "name": "evidence",
            "type": "List",
            "source": "capacity_evidence"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "capacity_confidence"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "calculate_bayesian_confidence",
        "purpose": "Calculate Bayesian confidence in capacity",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "priors",
              "type": "Dict",
              "source": "outcome_priors"
            },
            {
              "name": "evidence",
              "type": "List",
              "source": "measurement_evidence"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      }
    ],
    "contributing_modules": [
      "Analyzer_one.py",
      "dereck_beach.py",
      "financiero_viabilidad_tablas.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "financial_viability",
    "evidence_types": [
      "capacity_assessment",
      "capacity_confidence",
      "entity_classification",
      "performance_scores"
    ],
    "aggregation_strategy": "capacity_weighted_average",
    "confidence_threshold": 0.78,
    "total_steps": 4
  },
  "P10-D1-Q4": {
    "question_id": "P10-D1-Q4",
    "point": "P10",
    "dimension": "D1",
    "question_number": 4,
    "question_text": "Assess institutional capacity and readiness",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "financial_viability",
        "adapter_class": "FinancialViabilityAdapter",
        "method": "_classify_entity_type",
        "args": [
          {
            "name": "entity",
            "type": "str",
            "source": "entity_name"
          }
        ],
        "returns": {
          "type": "str",
          "binding": "entity_classification"
        },
        "source_module": "financiero_viabilidad_tablas.py",
        "source_class": "FinancialViabilityAdapter",
        "source_method": "_classify_entity_type",
        "purpose": "Classify institutional entity types",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "entity",
              "type": "str",
              "source": "entity_name"
            }
          ],
          "return_type": "str",
          "source_file": "financiero_viabilidad_tablas.py"
        }
      },
      {
        "step": 2,
        "adapter": "analyzer_one",
        "adapter_class": "AnalyzerOneAdapter",
        "method": "calculate_performance_scores",
        "args": [
          {
            "name": "indicators",
            "type": "List[Dict]",
            "source": "extracted_indicators"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "performance_scores"
        },
        "source_module": "Analyzer_one.py",
        "source_class": "AnalyzerOneAdapter",
        "source_method": "calculate_performance_scores",
        "purpose": "Calculate institutional performance metrics",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "indicators",
              "type": "List[Dict]",
              "source": "extracted_indicators"
            }
          ],
          "return_type": "Dict",
          "source_file": "Analyzer_one.py"
        }
      },
      {
        "step": 3,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "assess_mechanism_capacity",
        "args": [
          {
            "name": "mechanism",
            "type": "Dict",
            "source": "institutional_mechanism"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "capacity_assessment"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "assess_mechanism_capacity",
        "purpose": "Assess capacity of institutional mechanisms",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [
            {
              "name": "mechanism",
              "type": "Dict",
              "source": "institutional_mechanism"
            }
          ],
          "return_type": "Dict",
          "source_file": "dereck_beach.py"
        }
      },
      {
        "step": 4,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "calculate_bayesian_confidence",
        "args": [
          {
            "name": "priors",
            "type": "Dict",
            "source": "prior_assessments"
          },
          {
            "name": "evidence",
            "type": "List",
            "source": "capacity_evidence"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "capacity_confidence"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "calculate_bayesian_confidence",
        "purpose": "Calculate Bayesian confidence in capacity",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "priors",
              "type": "Dict",
              "source": "outcome_priors"
            },
            {
              "name": "evidence",
              "type": "List",
              "source": "measurement_evidence"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      }
    ],
    "contributing_modules": [
      "Analyzer_one.py",
      "dereck_beach.py",
      "financiero_viabilidad_tablas.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "financial_viability",
    "evidence_types": [
      "capacity_assessment",
      "capacity_confidence",
      "entity_classification",
      "performance_scores"
    ],
    "aggregation_strategy": "capacity_weighted_average",
    "confidence_threshold": 0.78,
    "total_steps": 4
  },
  "P1-D1-Q5": {
    "question_id": "P1-D1-Q5",
    "point": "P1",
    "dimension": "D1",
    "question_number": 5,
    "question_text": "Validate baseline data quality and completeness",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_detect_numerical_inconsistencies",
        "args": [],
        "returns": {
          "type": "List[Dict]",
          "binding": "numerical_inconsistencies"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_detect_numerical_inconsistencies",
        "purpose": "Detect numerical inconsistencies in baseline",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [],
          "return_type": "List[Dict]",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 2,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_calculate_coherence_metrics",
        "args": [],
        "returns": {
          "type": "Dict",
          "binding": "coherence_metrics"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_calculate_coherence_metrics",
        "purpose": "Calculate overall coherence of baseline",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [],
          "return_type": "Dict",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 3,
        "adapter": "policy_segmenter",
        "adapter_class": "PolicySegmenterAdapter",
        "method": "_compute_consistency_score",
        "args": [
          {
            "name": "segments",
            "type": "List",
            "source": "document_segments"
          }
        ],
        "returns": {
          "type": "float",
          "binding": "consistency_score"
        },
        "source_module": "policy_segmenter.py",
        "source_class": "PolicySegmenterAdapter",
        "source_method": "_compute_consistency_score",
        "purpose": "Compute consistency across baseline segments",
        "confidence_expected": 0.9,
        "signature": {
          "parameters": [
            {
              "name": "segments",
              "type": "List",
              "source": "document_segments"
            }
          ],
          "return_type": "float",
          "source_file": "policy_segmenter.py"
        }
      },
      {
        "step": 4,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "verify_temporal_consistency",
        "args": [
          {
            "name": "statements",
            "type": "List[Dict]",
            "source": "temporal_statements"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "temporal_validation"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "verify_temporal_consistency",
        "purpose": "Verify temporal consistency in baseline",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "statements",
              "type": "List[Dict]",
              "source": "temporal_statements"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      }
    ],
    "contributing_modules": [
      "contradiction_deteccion.py",
      "policy_segmenter.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "contradiction_detection",
    "evidence_types": [
      "coherence_metrics",
      "consistency_score",
      "numerical_inconsistencies",
      "temporal_validation"
    ],
    "aggregation_strategy": "validation_consensus",
    "confidence_threshold": 0.82,
    "total_steps": 4
  },
  "P2-D1-Q5": {
    "question_id": "P2-D1-Q5",
    "point": "P2",
    "dimension": "D1",
    "question_number": 5,
    "question_text": "Validate baseline data quality and completeness",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_detect_numerical_inconsistencies",
        "args": [],
        "returns": {
          "type": "List[Dict]",
          "binding": "numerical_inconsistencies"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_detect_numerical_inconsistencies",
        "purpose": "Detect numerical inconsistencies in baseline",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [],
          "return_type": "List[Dict]",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 2,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_calculate_coherence_metrics",
        "args": [],
        "returns": {
          "type": "Dict",
          "binding": "coherence_metrics"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_calculate_coherence_metrics",
        "purpose": "Calculate overall coherence of baseline",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [],
          "return_type": "Dict",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 3,
        "adapter": "policy_segmenter",
        "adapter_class": "PolicySegmenterAdapter",
        "method": "_compute_consistency_score",
        "args": [
          {
            "name": "segments",
            "type": "List",
            "source": "document_segments"
          }
        ],
        "returns": {
          "type": "float",
          "binding": "consistency_score"
        },
        "source_module": "policy_segmenter.py",
        "source_class": "PolicySegmenterAdapter",
        "source_method": "_compute_consistency_score",
        "purpose": "Compute consistency across baseline segments",
        "confidence_expected": 0.9,
        "signature": {
          "parameters": [
            {
              "name": "segments",
              "type": "List",
              "source": "document_segments"
            }
          ],
          "return_type": "float",
          "source_file": "policy_segmenter.py"
        }
      },
      {
        "step": 4,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "verify_temporal_consistency",
        "args": [
          {
            "name": "statements",
            "type": "List[Dict]",
            "source": "temporal_statements"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "temporal_validation"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "verify_temporal_consistency",
        "purpose": "Verify temporal consistency in baseline",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "statements",
              "type": "List[Dict]",
              "source": "temporal_statements"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      }
    ],
    "contributing_modules": [
      "contradiction_deteccion.py",
      "policy_segmenter.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "contradiction_detection",
    "evidence_types": [
      "coherence_metrics",
      "consistency_score",
      "numerical_inconsistencies",
      "temporal_validation"
    ],
    "aggregation_strategy": "validation_consensus",
    "confidence_threshold": 0.82,
    "total_steps": 4
  },
  "P3-D1-Q5": {
    "question_id": "P3-D1-Q5",
    "point": "P3",
    "dimension": "D1",
    "question_number": 5,
    "question_text": "Validate baseline data quality and completeness",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_detect_numerical_inconsistencies",
        "args": [],
        "returns": {
          "type": "List[Dict]",
          "binding": "numerical_inconsistencies"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_detect_numerical_inconsistencies",
        "purpose": "Detect numerical inconsistencies in baseline",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [],
          "return_type": "List[Dict]",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 2,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_calculate_coherence_metrics",
        "args": [],
        "returns": {
          "type": "Dict",
          "binding": "coherence_metrics"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_calculate_coherence_metrics",
        "purpose": "Calculate overall coherence of baseline",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [],
          "return_type": "Dict",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 3,
        "adapter": "policy_segmenter",
        "adapter_class": "PolicySegmenterAdapter",
        "method": "_compute_consistency_score",
        "args": [
          {
            "name": "segments",
            "type": "List",
            "source": "document_segments"
          }
        ],
        "returns": {
          "type": "float",
          "binding": "consistency_score"
        },
        "source_module": "policy_segmenter.py",
        "source_class": "PolicySegmenterAdapter",
        "source_method": "_compute_consistency_score",
        "purpose": "Compute consistency across baseline segments",
        "confidence_expected": 0.9,
        "signature": {
          "parameters": [
            {
              "name": "segments",
              "type": "List",
              "source": "document_segments"
            }
          ],
          "return_type": "float",
          "source_file": "policy_segmenter.py"
        }
      },
      {
        "step": 4,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "verify_temporal_consistency",
        "args": [
          {
            "name": "statements",
            "type": "List[Dict]",
            "source": "temporal_statements"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "temporal_validation"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "verify_temporal_consistency",
        "purpose": "Verify temporal consistency in baseline",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "statements",
              "type": "List[Dict]",
              "source": "temporal_statements"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      }
    ],
    "contributing_modules": [
      "contradiction_deteccion.py",
      "policy_segmenter.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "contradiction_detection",
    "evidence_types": [
      "coherence_metrics",
      "consistency_score",
      "numerical_inconsistencies",
      "temporal_validation"
    ],
    "aggregation_strategy": "validation_consensus",
    "confidence_threshold": 0.82,
    "total_steps": 4
  },
  "P4-D1-Q5": {
    "question_id": "P4-D1-Q5",
    "point": "P4",
    "dimension": "D1",
    "question_number": 5,
    "question_text": "Validate baseline data quality and completeness",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_detect_numerical_inconsistencies",
        "args": [],
        "returns": {
          "type": "List[Dict]",
          "binding": "numerical_inconsistencies"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_detect_numerical_inconsistencies",
        "purpose": "Detect numerical inconsistencies in baseline",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [],
          "return_type": "List[Dict]",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 2,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_calculate_coherence_metrics",
        "args": [],
        "returns": {
          "type": "Dict",
          "binding": "coherence_metrics"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_calculate_coherence_metrics",
        "purpose": "Calculate overall coherence of baseline",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [],
          "return_type": "Dict",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 3,
        "adapter": "policy_segmenter",
        "adapter_class": "PolicySegmenterAdapter",
        "method": "_compute_consistency_score",
        "args": [
          {
            "name": "segments",
            "type": "List",
            "source": "document_segments"
          }
        ],
        "returns": {
          "type": "float",
          "binding": "consistency_score"
        },
        "source_module": "policy_segmenter.py",
        "source_class": "PolicySegmenterAdapter",
        "source_method": "_compute_consistency_score",
        "purpose": "Compute consistency across baseline segments",
        "confidence_expected": 0.9,
        "signature": {
          "parameters": [
            {
              "name": "segments",
              "type": "List",
              "source": "document_segments"
            }
          ],
          "return_type": "float",
          "source_file": "policy_segmenter.py"
        }
      },
      {
        "step": 4,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "verify_temporal_consistency",
        "args": [
          {
            "name": "statements",
            "type": "List[Dict]",
            "source": "temporal_statements"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "temporal_validation"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "verify_temporal_consistency",
        "purpose": "Verify temporal consistency in baseline",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "statements",
              "type": "List[Dict]",
              "source": "temporal_statements"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      }
    ],
    "contributing_modules": [
      "contradiction_deteccion.py",
      "policy_segmenter.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "contradiction_detection",
    "evidence_types": [
      "coherence_metrics",
      "consistency_score",
      "numerical_inconsistencies",
      "temporal_validation"
    ],
    "aggregation_strategy": "validation_consensus",
    "confidence_threshold": 0.82,
    "total_steps": 4
  },
  "P5-D1-Q5": {
    "question_id": "P5-D1-Q5",
    "point": "P5",
    "dimension": "D1",
    "question_number": 5,
    "question_text": "Validate baseline data quality and completeness",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_detect_numerical_inconsistencies",
        "args": [],
        "returns": {
          "type": "List[Dict]",
          "binding": "numerical_inconsistencies"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_detect_numerical_inconsistencies",
        "purpose": "Detect numerical inconsistencies in baseline",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [],
          "return_type": "List[Dict]",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 2,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_calculate_coherence_metrics",
        "args": [],
        "returns": {
          "type": "Dict",
          "binding": "coherence_metrics"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_calculate_coherence_metrics",
        "purpose": "Calculate overall coherence of baseline",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [],
          "return_type": "Dict",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 3,
        "adapter": "policy_segmenter",
        "adapter_class": "PolicySegmenterAdapter",
        "method": "_compute_consistency_score",
        "args": [
          {
            "name": "segments",
            "type": "List",
            "source": "document_segments"
          }
        ],
        "returns": {
          "type": "float",
          "binding": "consistency_score"
        },
        "source_module": "policy_segmenter.py",
        "source_class": "PolicySegmenterAdapter",
        "source_method": "_compute_consistency_score",
        "purpose": "Compute consistency across baseline segments",
        "confidence_expected": 0.9,
        "signature": {
          "parameters": [
            {
              "name": "segments",
              "type": "List",
              "source": "document_segments"
            }
          ],
          "return_type": "float",
          "source_file": "policy_segmenter.py"
        }
      },
      {
        "step": 4,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "verify_temporal_consistency",
        "args": [
          {
            "name": "statements",
            "type": "List[Dict]",
            "source": "temporal_statements"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "temporal_validation"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "verify_temporal_consistency",
        "purpose": "Verify temporal consistency in baseline",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "statements",
              "type": "List[Dict]",
              "source": "temporal_statements"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      }
    ],
    "contributing_modules": [
      "contradiction_deteccion.py",
      "policy_segmenter.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "contradiction_detection",
    "evidence_types": [
      "coherence_metrics",
      "consistency_score",
      "numerical_inconsistencies",
      "temporal_validation"
    ],
    "aggregation_strategy": "validation_consensus",
    "confidence_threshold": 0.82,
    "total_steps": 4
  },
  "P6-D1-Q5": {
    "question_id": "P6-D1-Q5",
    "point": "P6",
    "dimension": "D1",
    "question_number": 5,
    "question_text": "Validate baseline data quality and completeness",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_detect_numerical_inconsistencies",
        "args": [],
        "returns": {
          "type": "List[Dict]",
          "binding": "numerical_inconsistencies"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_detect_numerical_inconsistencies",
        "purpose": "Detect numerical inconsistencies in baseline",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [],
          "return_type": "List[Dict]",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 2,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_calculate_coherence_metrics",
        "args": [],
        "returns": {
          "type": "Dict",
          "binding": "coherence_metrics"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_calculate_coherence_metrics",
        "purpose": "Calculate overall coherence of baseline",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [],
          "return_type": "Dict",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 3,
        "adapter": "policy_segmenter",
        "adapter_class": "PolicySegmenterAdapter",
        "method": "_compute_consistency_score",
        "args": [
          {
            "name": "segments",
            "type": "List",
            "source": "document_segments"
          }
        ],
        "returns": {
          "type": "float",
          "binding": "consistency_score"
        },
        "source_module": "policy_segmenter.py",
        "source_class": "PolicySegmenterAdapter",
        "source_method": "_compute_consistency_score",
        "purpose": "Compute consistency across baseline segments",
        "confidence_expected": 0.9,
        "signature": {
          "parameters": [
            {
              "name": "segments",
              "type": "List",
              "source": "document_segments"
            }
          ],
          "return_type": "float",
          "source_file": "policy_segmenter.py"
        }
      },
      {
        "step": 4,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "verify_temporal_consistency",
        "args": [
          {
            "name": "statements",
            "type": "List[Dict]",
            "source": "temporal_statements"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "temporal_validation"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "verify_temporal_consistency",
        "purpose": "Verify temporal consistency in baseline",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "statements",
              "type": "List[Dict]",
              "source": "temporal_statements"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      }
    ],
    "contributing_modules": [
      "contradiction_deteccion.py",
      "policy_segmenter.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "contradiction_detection",
    "evidence_types": [
      "coherence_metrics",
      "consistency_score",
      "numerical_inconsistencies",
      "temporal_validation"
    ],
    "aggregation_strategy": "validation_consensus",
    "confidence_threshold": 0.82,
    "total_steps": 4
  },
  "P7-D1-Q5": {
    "question_id": "P7-D1-Q5",
    "point": "P7",
    "dimension": "D1",
    "question_number": 5,
    "question_text": "Validate baseline data quality and completeness",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_detect_numerical_inconsistencies",
        "args": [],
        "returns": {
          "type": "List[Dict]",
          "binding": "numerical_inconsistencies"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_detect_numerical_inconsistencies",
        "purpose": "Detect numerical inconsistencies in baseline",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [],
          "return_type": "List[Dict]",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 2,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_calculate_coherence_metrics",
        "args": [],
        "returns": {
          "type": "Dict",
          "binding": "coherence_metrics"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_calculate_coherence_metrics",
        "purpose": "Calculate overall coherence of baseline",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [],
          "return_type": "Dict",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 3,
        "adapter": "policy_segmenter",
        "adapter_class": "PolicySegmenterAdapter",
        "method": "_compute_consistency_score",
        "args": [
          {
            "name": "segments",
            "type": "List",
            "source": "document_segments"
          }
        ],
        "returns": {
          "type": "float",
          "binding": "consistency_score"
        },
        "source_module": "policy_segmenter.py",
        "source_class": "PolicySegmenterAdapter",
        "source_method": "_compute_consistency_score",
        "purpose": "Compute consistency across baseline segments",
        "confidence_expected": 0.9,
        "signature": {
          "parameters": [
            {
              "name": "segments",
              "type": "List",
              "source": "document_segments"
            }
          ],
          "return_type": "float",
          "source_file": "policy_segmenter.py"
        }
      },
      {
        "step": 4,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "verify_temporal_consistency",
        "args": [
          {
            "name": "statements",
            "type": "List[Dict]",
            "source": "temporal_statements"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "temporal_validation"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "verify_temporal_consistency",
        "purpose": "Verify temporal consistency in baseline",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "statements",
              "type": "List[Dict]",
              "source": "temporal_statements"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      }
    ],
    "contributing_modules": [
      "contradiction_deteccion.py",
      "policy_segmenter.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "contradiction_detection",
    "evidence_types": [
      "coherence_metrics",
      "consistency_score",
      "numerical_inconsistencies",
      "temporal_validation"
    ],
    "aggregation_strategy": "validation_consensus",
    "confidence_threshold": 0.82,
    "total_steps": 4
  },
  "P8-D1-Q5": {
    "question_id": "P8-D1-Q5",
    "point": "P8",
    "dimension": "D1",
    "question_number": 5,
    "question_text": "Validate baseline data quality and completeness",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_detect_numerical_inconsistencies",
        "args": [],
        "returns": {
          "type": "List[Dict]",
          "binding": "numerical_inconsistencies"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_detect_numerical_inconsistencies",
        "purpose": "Detect numerical inconsistencies in baseline",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [],
          "return_type": "List[Dict]",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 2,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_calculate_coherence_metrics",
        "args": [],
        "returns": {
          "type": "Dict",
          "binding": "coherence_metrics"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_calculate_coherence_metrics",
        "purpose": "Calculate overall coherence of baseline",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [],
          "return_type": "Dict",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 3,
        "adapter": "policy_segmenter",
        "adapter_class": "PolicySegmenterAdapter",
        "method": "_compute_consistency_score",
        "args": [
          {
            "name": "segments",
            "type": "List",
            "source": "document_segments"
          }
        ],
        "returns": {
          "type": "float",
          "binding": "consistency_score"
        },
        "source_module": "policy_segmenter.py",
        "source_class": "PolicySegmenterAdapter",
        "source_method": "_compute_consistency_score",
        "purpose": "Compute consistency across baseline segments",
        "confidence_expected": 0.9,
        "signature": {
          "parameters": [
            {
              "name": "segments",
              "type": "List",
              "source": "document_segments"
            }
          ],
          "return_type": "float",
          "source_file": "policy_segmenter.py"
        }
      },
      {
        "step": 4,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "verify_temporal_consistency",
        "args": [
          {
            "name": "statements",
            "type": "List[Dict]",
            "source": "temporal_statements"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "temporal_validation"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "verify_temporal_consistency",
        "purpose": "Verify temporal consistency in baseline",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "statements",
              "type": "List[Dict]",
              "source": "temporal_statements"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      }
    ],
    "contributing_modules": [
      "contradiction_deteccion.py",
      "policy_segmenter.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "contradiction_detection",
    "evidence_types": [
      "coherence_metrics",
      "consistency_score",
      "numerical_inconsistencies",
      "temporal_validation"
    ],
    "aggregation_strategy": "validation_consensus",
    "confidence_threshold": 0.82,
    "total_steps": 4
  },
  "P9-D1-Q5": {
    "question_id": "P9-D1-Q5",
    "point": "P9",
    "dimension": "D1",
    "question_number": 5,
    "question_text": "Validate baseline data quality and completeness",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_detect_numerical_inconsistencies",
        "args": [],
        "returns": {
          "type": "List[Dict]",
          "binding": "numerical_inconsistencies"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_detect_numerical_inconsistencies",
        "purpose": "Detect numerical inconsistencies in baseline",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [],
          "return_type": "List[Dict]",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 2,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_calculate_coherence_metrics",
        "args": [],
        "returns": {
          "type": "Dict",
          "binding": "coherence_metrics"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_calculate_coherence_metrics",
        "purpose": "Calculate overall coherence of baseline",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [],
          "return_type": "Dict",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 3,
        "adapter": "policy_segmenter",
        "adapter_class": "PolicySegmenterAdapter",
        "method": "_compute_consistency_score",
        "args": [
          {
            "name": "segments",
            "type": "List",
            "source": "document_segments"
          }
        ],
        "returns": {
          "type": "float",
          "binding": "consistency_score"
        },
        "source_module": "policy_segmenter.py",
        "source_class": "PolicySegmenterAdapter",
        "source_method": "_compute_consistency_score",
        "purpose": "Compute consistency across baseline segments",
        "confidence_expected": 0.9,
        "signature": {
          "parameters": [
            {
              "name": "segments",
              "type": "List",
              "source": "document_segments"
            }
          ],
          "return_type": "float",
          "source_file": "policy_segmenter.py"
        }
      },
      {
        "step": 4,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "verify_temporal_consistency",
        "args": [
          {
            "name": "statements",
            "type": "List[Dict]",
            "source": "temporal_statements"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "temporal_validation"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "verify_temporal_consistency",
        "purpose": "Verify temporal consistency in baseline",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "statements",
              "type": "List[Dict]",
              "source": "temporal_statements"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      }
    ],
    "contributing_modules": [
      "contradiction_deteccion.py",
      "policy_segmenter.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "contradiction_detection",
    "evidence_types": [
      "coherence_metrics",
      "consistency_score",
      "numerical_inconsistencies",
      "temporal_validation"
    ],
    "aggregation_strategy": "validation_consensus",
    "confidence_threshold": 0.82,
    "total_steps": 4
  },
  "P10-D1-Q5": {
    "question_id": "P10-D1-Q5",
    "point": "P10",
    "dimension": "D1",
    "question_number": 5,
    "question_text": "Validate baseline data quality and completeness",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_detect_numerical_inconsistencies",
        "args": [],
        "returns": {
          "type": "List[Dict]",
          "binding": "numerical_inconsistencies"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_detect_numerical_inconsistencies",
        "purpose": "Detect numerical inconsistencies in baseline",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [],
          "return_type": "List[Dict]",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 2,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_calculate_coherence_metrics",
        "args": [],
        "returns": {
          "type": "Dict",
          "binding": "coherence_metrics"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_calculate_coherence_metrics",
        "purpose": "Calculate overall coherence of baseline",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [],
          "return_type": "Dict",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 3,
        "adapter": "policy_segmenter",
        "adapter_class": "PolicySegmenterAdapter",
        "method": "_compute_consistency_score",
        "args": [
          {
            "name": "segments",
            "type": "List",
            "source": "document_segments"
          }
        ],
        "returns": {
          "type": "float",
          "binding": "consistency_score"
        },
        "source_module": "policy_segmenter.py",
        "source_class": "PolicySegmenterAdapter",
        "source_method": "_compute_consistency_score",
        "purpose": "Compute consistency across baseline segments",
        "confidence_expected": 0.9,
        "signature": {
          "parameters": [
            {
              "name": "segments",
              "type": "List",
              "source": "document_segments"
            }
          ],
          "return_type": "float",
          "source_file": "policy_segmenter.py"
        }
      },
      {
        "step": 4,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "verify_temporal_consistency",
        "args": [
          {
            "name": "statements",
            "type": "List[Dict]",
            "source": "temporal_statements"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "temporal_validation"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "verify_temporal_consistency",
        "purpose": "Verify temporal consistency in baseline",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "statements",
              "type": "List[Dict]",
              "source": "temporal_statements"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      }
    ],
    "contributing_modules": [
      "contradiction_deteccion.py",
      "policy_segmenter.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "contradiction_detection",
    "evidence_types": [
      "coherence_metrics",
      "consistency_score",
      "numerical_inconsistencies",
      "temporal_validation"
    ],
    "aggregation_strategy": "validation_consensus",
    "confidence_threshold": 0.82,
    "total_steps": 4
  },
  "P1-D2-Q1": {
    "question_id": "P1-D2-Q1",
    "point": "P1",
    "dimension": "D2",
    "question_number": 1,
    "question_text": "Identify and catalog key processes",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "identify_pdm_processes",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "identified_processes"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "identify_pdm_processes",
        "purpose": "Identify processes using P-D-Q notation",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "emebedding_policy.py"
        }
      },
      {
        "step": 2,
        "adapter": "policy_processor",
        "adapter_class": "PolicyProcessorAdapter",
        "method": "process",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "policy_analysis"
        },
        "source_module": "policy_processor.py",
        "source_class": "PolicyProcessorAdapter",
        "source_method": "process",
        "purpose": "Process and analyze policy implementation",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "Dict",
          "source_file": "policy_processor.py"
        }
      },
      {
        "step": 3,
        "adapter": "semantic_chunking_policy",
        "adapter_class": "SemanticChunkingPolicyAdapter",
        "method": "detect_pdm_structure",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "pdm_structure_detected"
        },
        "source_module": "semantic_chunking_policy.py",
        "source_class": "SemanticChunkingPolicyAdapter",
        "source_method": "detect_pdm_structure",
        "purpose": "Detect PDM structure in processes",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "Dict",
          "source_file": "semantic_chunking_policy.py"
        }
      },
      {
        "step": 4,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "identify_causal_mechanisms",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "causal_mechanisms"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "identify_causal_mechanisms",
        "purpose": "Identify causal mechanisms in processes",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "dereck_beach.py"
        }
      }
    ],
    "contributing_modules": [
      "dereck_beach.py",
      "emebedding_policy.py",
      "policy_processor.py",
      "semantic_chunking_policy.py"
    ],
    "primary_adapter": "embedding_policy",
    "evidence_types": [
      "causal_mechanisms",
      "identified_processes",
      "pdm_structure_detected",
      "policy_analysis"
    ],
    "aggregation_strategy": "process_synthesis",
    "confidence_threshold": 0.75,
    "total_steps": 4
  },
  "P2-D2-Q1": {
    "question_id": "P2-D2-Q1",
    "point": "P2",
    "dimension": "D2",
    "question_number": 1,
    "question_text": "Identify and catalog key processes",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "identify_pdm_processes",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "identified_processes"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "identify_pdm_processes",
        "purpose": "Identify processes using P-D-Q notation",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "emebedding_policy.py"
        }
      },
      {
        "step": 2,
        "adapter": "policy_processor",
        "adapter_class": "PolicyProcessorAdapter",
        "method": "process",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "policy_analysis"
        },
        "source_module": "policy_processor.py",
        "source_class": "PolicyProcessorAdapter",
        "source_method": "process",
        "purpose": "Process and analyze policy implementation",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "Dict",
          "source_file": "policy_processor.py"
        }
      },
      {
        "step": 3,
        "adapter": "semantic_chunking_policy",
        "adapter_class": "SemanticChunkingPolicyAdapter",
        "method": "detect_pdm_structure",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "pdm_structure_detected"
        },
        "source_module": "semantic_chunking_policy.py",
        "source_class": "SemanticChunkingPolicyAdapter",
        "source_method": "detect_pdm_structure",
        "purpose": "Detect PDM structure in processes",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "Dict",
          "source_file": "semantic_chunking_policy.py"
        }
      },
      {
        "step": 4,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "identify_causal_mechanisms",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "causal_mechanisms"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "identify_causal_mechanisms",
        "purpose": "Identify causal mechanisms in processes",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "dereck_beach.py"
        }
      }
    ],
    "contributing_modules": [
      "dereck_beach.py",
      "emebedding_policy.py",
      "policy_processor.py",
      "semantic_chunking_policy.py"
    ],
    "primary_adapter": "embedding_policy",
    "evidence_types": [
      "causal_mechanisms",
      "identified_processes",
      "pdm_structure_detected",
      "policy_analysis"
    ],
    "aggregation_strategy": "process_synthesis",
    "confidence_threshold": 0.75,
    "total_steps": 4
  },
  "P3-D2-Q1": {
    "question_id": "P3-D2-Q1",
    "point": "P3",
    "dimension": "D2",
    "question_number": 1,
    "question_text": "Identify and catalog key processes",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "identify_pdm_processes",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "identified_processes"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "identify_pdm_processes",
        "purpose": "Identify processes using P-D-Q notation",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "emebedding_policy.py"
        }
      },
      {
        "step": 2,
        "adapter": "policy_processor",
        "adapter_class": "PolicyProcessorAdapter",
        "method": "process",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "policy_analysis"
        },
        "source_module": "policy_processor.py",
        "source_class": "PolicyProcessorAdapter",
        "source_method": "process",
        "purpose": "Process and analyze policy implementation",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "Dict",
          "source_file": "policy_processor.py"
        }
      },
      {
        "step": 3,
        "adapter": "semantic_chunking_policy",
        "adapter_class": "SemanticChunkingPolicyAdapter",
        "method": "detect_pdm_structure",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "pdm_structure_detected"
        },
        "source_module": "semantic_chunking_policy.py",
        "source_class": "SemanticChunkingPolicyAdapter",
        "source_method": "detect_pdm_structure",
        "purpose": "Detect PDM structure in processes",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "Dict",
          "source_file": "semantic_chunking_policy.py"
        }
      },
      {
        "step": 4,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "identify_causal_mechanisms",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "causal_mechanisms"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "identify_causal_mechanisms",
        "purpose": "Identify causal mechanisms in processes",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "dereck_beach.py"
        }
      }
    ],
    "contributing_modules": [
      "dereck_beach.py",
      "emebedding_policy.py",
      "policy_processor.py",
      "semantic_chunking_policy.py"
    ],
    "primary_adapter": "embedding_policy",
    "evidence_types": [
      "causal_mechanisms",
      "identified_processes",
      "pdm_structure_detected",
      "policy_analysis"
    ],
    "aggregation_strategy": "process_synthesis",
    "confidence_threshold": 0.75,
    "total_steps": 4
  },
  "P4-D2-Q1": {
    "question_id": "P4-D2-Q1",
    "point": "P4",
    "dimension": "D2",
    "question_number": 1,
    "question_text": "Identify and catalog key processes",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "identify_pdm_processes",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "identified_processes"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "identify_pdm_processes",
        "purpose": "Identify processes using P-D-Q notation",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "emebedding_policy.py"
        }
      },
      {
        "step": 2,
        "adapter": "policy_processor",
        "adapter_class": "PolicyProcessorAdapter",
        "method": "process",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "policy_analysis"
        },
        "source_module": "policy_processor.py",
        "source_class": "PolicyProcessorAdapter",
        "source_method": "process",
        "purpose": "Process and analyze policy implementation",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "Dict",
          "source_file": "policy_processor.py"
        }
      },
      {
        "step": 3,
        "adapter": "semantic_chunking_policy",
        "adapter_class": "SemanticChunkingPolicyAdapter",
        "method": "detect_pdm_structure",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "pdm_structure_detected"
        },
        "source_module": "semantic_chunking_policy.py",
        "source_class": "SemanticChunkingPolicyAdapter",
        "source_method": "detect_pdm_structure",
        "purpose": "Detect PDM structure in processes",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "Dict",
          "source_file": "semantic_chunking_policy.py"
        }
      },
      {
        "step": 4,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "identify_causal_mechanisms",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "causal_mechanisms"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "identify_causal_mechanisms",
        "purpose": "Identify causal mechanisms in processes",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "dereck_beach.py"
        }
      }
    ],
    "contributing_modules": [
      "dereck_beach.py",
      "emebedding_policy.py",
      "policy_processor.py",
      "semantic_chunking_policy.py"
    ],
    "primary_adapter": "embedding_policy",
    "evidence_types": [
      "causal_mechanisms",
      "identified_processes",
      "pdm_structure_detected",
      "policy_analysis"
    ],
    "aggregation_strategy": "process_synthesis",
    "confidence_threshold": 0.75,
    "total_steps": 4
  },
  "P5-D2-Q1": {
    "question_id": "P5-D2-Q1",
    "point": "P5",
    "dimension": "D2",
    "question_number": 1,
    "question_text": "Identify and catalog key processes",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "identify_pdm_processes",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "identified_processes"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "identify_pdm_processes",
        "purpose": "Identify processes using P-D-Q notation",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "emebedding_policy.py"
        }
      },
      {
        "step": 2,
        "adapter": "policy_processor",
        "adapter_class": "PolicyProcessorAdapter",
        "method": "process",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "policy_analysis"
        },
        "source_module": "policy_processor.py",
        "source_class": "PolicyProcessorAdapter",
        "source_method": "process",
        "purpose": "Process and analyze policy implementation",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "Dict",
          "source_file": "policy_processor.py"
        }
      },
      {
        "step": 3,
        "adapter": "semantic_chunking_policy",
        "adapter_class": "SemanticChunkingPolicyAdapter",
        "method": "detect_pdm_structure",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "pdm_structure_detected"
        },
        "source_module": "semantic_chunking_policy.py",
        "source_class": "SemanticChunkingPolicyAdapter",
        "source_method": "detect_pdm_structure",
        "purpose": "Detect PDM structure in processes",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "Dict",
          "source_file": "semantic_chunking_policy.py"
        }
      },
      {
        "step": 4,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "identify_causal_mechanisms",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "causal_mechanisms"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "identify_causal_mechanisms",
        "purpose": "Identify causal mechanisms in processes",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "dereck_beach.py"
        }
      }
    ],
    "contributing_modules": [
      "dereck_beach.py",
      "emebedding_policy.py",
      "policy_processor.py",
      "semantic_chunking_policy.py"
    ],
    "primary_adapter": "embedding_policy",
    "evidence_types": [
      "causal_mechanisms",
      "identified_processes",
      "pdm_structure_detected",
      "policy_analysis"
    ],
    "aggregation_strategy": "process_synthesis",
    "confidence_threshold": 0.75,
    "total_steps": 4
  },
  "P6-D2-Q1": {
    "question_id": "P6-D2-Q1",
    "point": "P6",
    "dimension": "D2",
    "question_number": 1,
    "question_text": "Identify and catalog key processes",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "identify_pdm_processes",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "identified_processes"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "identify_pdm_processes",
        "purpose": "Identify processes using P-D-Q notation",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "emebedding_policy.py"
        }
      },
      {
        "step": 2,
        "adapter": "policy_processor",
        "adapter_class": "PolicyProcessorAdapter",
        "method": "process",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "policy_analysis"
        },
        "source_module": "policy_processor.py",
        "source_class": "PolicyProcessorAdapter",
        "source_method": "process",
        "purpose": "Process and analyze policy implementation",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "Dict",
          "source_file": "policy_processor.py"
        }
      },
      {
        "step": 3,
        "adapter": "semantic_chunking_policy",
        "adapter_class": "SemanticChunkingPolicyAdapter",
        "method": "detect_pdm_structure",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "pdm_structure_detected"
        },
        "source_module": "semantic_chunking_policy.py",
        "source_class": "SemanticChunkingPolicyAdapter",
        "source_method": "detect_pdm_structure",
        "purpose": "Detect PDM structure in processes",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "Dict",
          "source_file": "semantic_chunking_policy.py"
        }
      },
      {
        "step": 4,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "identify_causal_mechanisms",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "causal_mechanisms"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "identify_causal_mechanisms",
        "purpose": "Identify causal mechanisms in processes",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "dereck_beach.py"
        }
      }
    ],
    "contributing_modules": [
      "dereck_beach.py",
      "emebedding_policy.py",
      "policy_processor.py",
      "semantic_chunking_policy.py"
    ],
    "primary_adapter": "embedding_policy",
    "evidence_types": [
      "causal_mechanisms",
      "identified_processes",
      "pdm_structure_detected",
      "policy_analysis"
    ],
    "aggregation_strategy": "process_synthesis",
    "confidence_threshold": 0.75,
    "total_steps": 4
  },
  "P7-D2-Q1": {
    "question_id": "P7-D2-Q1",
    "point": "P7",
    "dimension": "D2",
    "question_number": 1,
    "question_text": "Identify and catalog key processes",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "identify_pdm_processes",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "identified_processes"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "identify_pdm_processes",
        "purpose": "Identify processes using P-D-Q notation",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "emebedding_policy.py"
        }
      },
      {
        "step": 2,
        "adapter": "policy_processor",
        "adapter_class": "PolicyProcessorAdapter",
        "method": "process",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "policy_analysis"
        },
        "source_module": "policy_processor.py",
        "source_class": "PolicyProcessorAdapter",
        "source_method": "process",
        "purpose": "Process and analyze policy implementation",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "Dict",
          "source_file": "policy_processor.py"
        }
      },
      {
        "step": 3,
        "adapter": "semantic_chunking_policy",
        "adapter_class": "SemanticChunkingPolicyAdapter",
        "method": "detect_pdm_structure",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "pdm_structure_detected"
        },
        "source_module": "semantic_chunking_policy.py",
        "source_class": "SemanticChunkingPolicyAdapter",
        "source_method": "detect_pdm_structure",
        "purpose": "Detect PDM structure in processes",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "Dict",
          "source_file": "semantic_chunking_policy.py"
        }
      },
      {
        "step": 4,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "identify_causal_mechanisms",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "causal_mechanisms"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "identify_causal_mechanisms",
        "purpose": "Identify causal mechanisms in processes",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "dereck_beach.py"
        }
      }
    ],
    "contributing_modules": [
      "dereck_beach.py",
      "emebedding_policy.py",
      "policy_processor.py",
      "semantic_chunking_policy.py"
    ],
    "primary_adapter": "embedding_policy",
    "evidence_types": [
      "causal_mechanisms",
      "identified_processes",
      "pdm_structure_detected",
      "policy_analysis"
    ],
    "aggregation_strategy": "process_synthesis",
    "confidence_threshold": 0.75,
    "total_steps": 4
  },
  "P8-D2-Q1": {
    "question_id": "P8-D2-Q1",
    "point": "P8",
    "dimension": "D2",
    "question_number": 1,
    "question_text": "Identify and catalog key processes",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "identify_pdm_processes",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "identified_processes"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "identify_pdm_processes",
        "purpose": "Identify processes using P-D-Q notation",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "emebedding_policy.py"
        }
      },
      {
        "step": 2,
        "adapter": "policy_processor",
        "adapter_class": "PolicyProcessorAdapter",
        "method": "process",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "policy_analysis"
        },
        "source_module": "policy_processor.py",
        "source_class": "PolicyProcessorAdapter",
        "source_method": "process",
        "purpose": "Process and analyze policy implementation",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "Dict",
          "source_file": "policy_processor.py"
        }
      },
      {
        "step": 3,
        "adapter": "semantic_chunking_policy",
        "adapter_class": "SemanticChunkingPolicyAdapter",
        "method": "detect_pdm_structure",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "pdm_structure_detected"
        },
        "source_module": "semantic_chunking_policy.py",
        "source_class": "SemanticChunkingPolicyAdapter",
        "source_method": "detect_pdm_structure",
        "purpose": "Detect PDM structure in processes",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "Dict",
          "source_file": "semantic_chunking_policy.py"
        }
      },
      {
        "step": 4,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "identify_causal_mechanisms",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "causal_mechanisms"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "identify_causal_mechanisms",
        "purpose": "Identify causal mechanisms in processes",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "dereck_beach.py"
        }
      }
    ],
    "contributing_modules": [
      "dereck_beach.py",
      "emebedding_policy.py",
      "policy_processor.py",
      "semantic_chunking_policy.py"
    ],
    "primary_adapter": "embedding_policy",
    "evidence_types": [
      "causal_mechanisms",
      "identified_processes",
      "pdm_structure_detected",
      "policy_analysis"
    ],
    "aggregation_strategy": "process_synthesis",
    "confidence_threshold": 0.75,
    "total_steps": 4
  },
  "P9-D2-Q1": {
    "question_id": "P9-D2-Q1",
    "point": "P9",
    "dimension": "D2",
    "question_number": 1,
    "question_text": "Identify and catalog key processes",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "identify_pdm_processes",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "identified_processes"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "identify_pdm_processes",
        "purpose": "Identify processes using P-D-Q notation",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "emebedding_policy.py"
        }
      },
      {
        "step": 2,
        "adapter": "policy_processor",
        "adapter_class": "PolicyProcessorAdapter",
        "method": "process",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "policy_analysis"
        },
        "source_module": "policy_processor.py",
        "source_class": "PolicyProcessorAdapter",
        "source_method": "process",
        "purpose": "Process and analyze policy implementation",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "Dict",
          "source_file": "policy_processor.py"
        }
      },
      {
        "step": 3,
        "adapter": "semantic_chunking_policy",
        "adapter_class": "SemanticChunkingPolicyAdapter",
        "method": "detect_pdm_structure",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "pdm_structure_detected"
        },
        "source_module": "semantic_chunking_policy.py",
        "source_class": "SemanticChunkingPolicyAdapter",
        "source_method": "detect_pdm_structure",
        "purpose": "Detect PDM structure in processes",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "Dict",
          "source_file": "semantic_chunking_policy.py"
        }
      },
      {
        "step": 4,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "identify_causal_mechanisms",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "causal_mechanisms"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "identify_causal_mechanisms",
        "purpose": "Identify causal mechanisms in processes",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "dereck_beach.py"
        }
      }
    ],
    "contributing_modules": [
      "dereck_beach.py",
      "emebedding_policy.py",
      "policy_processor.py",
      "semantic_chunking_policy.py"
    ],
    "primary_adapter": "embedding_policy",
    "evidence_types": [
      "causal_mechanisms",
      "identified_processes",
      "pdm_structure_detected",
      "policy_analysis"
    ],
    "aggregation_strategy": "process_synthesis",
    "confidence_threshold": 0.75,
    "total_steps": 4
  },
  "P10-D2-Q1": {
    "question_id": "P10-D2-Q1",
    "point": "P10",
    "dimension": "D2",
    "question_number": 1,
    "question_text": "Identify and catalog key processes",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "identify_pdm_processes",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "identified_processes"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "identify_pdm_processes",
        "purpose": "Identify processes using P-D-Q notation",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "emebedding_policy.py"
        }
      },
      {
        "step": 2,
        "adapter": "policy_processor",
        "adapter_class": "PolicyProcessorAdapter",
        "method": "process",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "policy_analysis"
        },
        "source_module": "policy_processor.py",
        "source_class": "PolicyProcessorAdapter",
        "source_method": "process",
        "purpose": "Process and analyze policy implementation",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "Dict",
          "source_file": "policy_processor.py"
        }
      },
      {
        "step": 3,
        "adapter": "semantic_chunking_policy",
        "adapter_class": "SemanticChunkingPolicyAdapter",
        "method": "detect_pdm_structure",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "pdm_structure_detected"
        },
        "source_module": "semantic_chunking_policy.py",
        "source_class": "SemanticChunkingPolicyAdapter",
        "source_method": "detect_pdm_structure",
        "purpose": "Detect PDM structure in processes",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "Dict",
          "source_file": "semantic_chunking_policy.py"
        }
      },
      {
        "step": 4,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "identify_causal_mechanisms",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "causal_mechanisms"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "identify_causal_mechanisms",
        "purpose": "Identify causal mechanisms in processes",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "dereck_beach.py"
        }
      }
    ],
    "contributing_modules": [
      "dereck_beach.py",
      "emebedding_policy.py",
      "policy_processor.py",
      "semantic_chunking_policy.py"
    ],
    "primary_adapter": "embedding_policy",
    "evidence_types": [
      "causal_mechanisms",
      "identified_processes",
      "pdm_structure_detected",
      "policy_analysis"
    ],
    "aggregation_strategy": "process_synthesis",
    "confidence_threshold": 0.75,
    "total_steps": 4
  },
  "P1-D2-Q2": {
    "question_id": "P1-D2-Q2",
    "point": "P1",
    "dimension": "D2",
    "question_number": 2,
    "question_text": "Analyze and validate process sequences",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "extract_temporal_markers",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "temporal_markers"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "extract_temporal_markers",
        "purpose": "Extract temporal sequence markers",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 2,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_detect_temporal_conflicts",
        "args": [],
        "returns": {
          "type": "List[Dict]",
          "binding": "temporal_conflicts"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_detect_temporal_conflicts",
        "purpose": "Detect conflicts in process sequencing",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [],
          "return_type": "List[Dict]",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 3,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "construct_causal_dag",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          },
          {
            "name": "indicators",
            "type": "List",
            "source": "process_indicators"
          }
        ],
        "returns": {
          "type": "nx.DiGraph",
          "binding": "process_dag"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "construct_causal_dag",
        "purpose": "Construct DAG of process dependencies",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            },
            {
              "name": "indicators",
              "type": "List",
              "source": "all_indicators"
            }
          ],
          "return_type": "nx.DiGraph",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 4,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "validate_causal_chain",
        "args": [
          {
            "name": "chain",
            "type": "List[Dict]",
            "source": "process_sequence"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "chain_validation"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "validate_causal_chain",
        "purpose": "Validate logical sequence of processes",
        "confidence_expected": 0.82,
        "signature": {
          "parameters": [
            {
              "name": "chain",
              "type": "List[Dict]",
              "source": "process_sequence"
            }
          ],
          "return_type": "Dict",
          "source_file": "dereck_beach.py"
        }
      }
    ],
    "contributing_modules": [
      "contradiction_deteccion.py",
      "dereck_beach.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "teoria_cambio",
    "evidence_types": [
      "chain_validation",
      "process_dag",
      "temporal_conflicts",
      "temporal_markers"
    ],
    "aggregation_strategy": "sequence_validation",
    "confidence_threshold": 0.8,
    "total_steps": 4
  },
  "P2-D2-Q2": {
    "question_id": "P2-D2-Q2",
    "point": "P2",
    "dimension": "D2",
    "question_number": 2,
    "question_text": "Analyze and validate process sequences",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "extract_temporal_markers",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "temporal_markers"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "extract_temporal_markers",
        "purpose": "Extract temporal sequence markers",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 2,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_detect_temporal_conflicts",
        "args": [],
        "returns": {
          "type": "List[Dict]",
          "binding": "temporal_conflicts"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_detect_temporal_conflicts",
        "purpose": "Detect conflicts in process sequencing",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [],
          "return_type": "List[Dict]",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 3,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "construct_causal_dag",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          },
          {
            "name": "indicators",
            "type": "List",
            "source": "process_indicators"
          }
        ],
        "returns": {
          "type": "nx.DiGraph",
          "binding": "process_dag"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "construct_causal_dag",
        "purpose": "Construct DAG of process dependencies",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            },
            {
              "name": "indicators",
              "type": "List",
              "source": "all_indicators"
            }
          ],
          "return_type": "nx.DiGraph",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 4,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "validate_causal_chain",
        "args": [
          {
            "name": "chain",
            "type": "List[Dict]",
            "source": "process_sequence"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "chain_validation"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "validate_causal_chain",
        "purpose": "Validate logical sequence of processes",
        "confidence_expected": 0.82,
        "signature": {
          "parameters": [
            {
              "name": "chain",
              "type": "List[Dict]",
              "source": "process_sequence"
            }
          ],
          "return_type": "Dict",
          "source_file": "dereck_beach.py"
        }
      }
    ],
    "contributing_modules": [
      "contradiction_deteccion.py",
      "dereck_beach.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "teoria_cambio",
    "evidence_types": [
      "chain_validation",
      "process_dag",
      "temporal_conflicts",
      "temporal_markers"
    ],
    "aggregation_strategy": "sequence_validation",
    "confidence_threshold": 0.8,
    "total_steps": 4
  },
  "P3-D2-Q2": {
    "question_id": "P3-D2-Q2",
    "point": "P3",
    "dimension": "D2",
    "question_number": 2,
    "question_text": "Analyze and validate process sequences",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "extract_temporal_markers",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "temporal_markers"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "extract_temporal_markers",
        "purpose": "Extract temporal sequence markers",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 2,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_detect_temporal_conflicts",
        "args": [],
        "returns": {
          "type": "List[Dict]",
          "binding": "temporal_conflicts"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_detect_temporal_conflicts",
        "purpose": "Detect conflicts in process sequencing",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [],
          "return_type": "List[Dict]",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 3,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "construct_causal_dag",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          },
          {
            "name": "indicators",
            "type": "List",
            "source": "process_indicators"
          }
        ],
        "returns": {
          "type": "nx.DiGraph",
          "binding": "process_dag"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "construct_causal_dag",
        "purpose": "Construct DAG of process dependencies",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            },
            {
              "name": "indicators",
              "type": "List",
              "source": "all_indicators"
            }
          ],
          "return_type": "nx.DiGraph",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 4,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "validate_causal_chain",
        "args": [
          {
            "name": "chain",
            "type": "List[Dict]",
            "source": "process_sequence"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "chain_validation"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "validate_causal_chain",
        "purpose": "Validate logical sequence of processes",
        "confidence_expected": 0.82,
        "signature": {
          "parameters": [
            {
              "name": "chain",
              "type": "List[Dict]",
              "source": "process_sequence"
            }
          ],
          "return_type": "Dict",
          "source_file": "dereck_beach.py"
        }
      }
    ],
    "contributing_modules": [
      "contradiction_deteccion.py",
      "dereck_beach.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "teoria_cambio",
    "evidence_types": [
      "chain_validation",
      "process_dag",
      "temporal_conflicts",
      "temporal_markers"
    ],
    "aggregation_strategy": "sequence_validation",
    "confidence_threshold": 0.8,
    "total_steps": 4
  },
  "P4-D2-Q2": {
    "question_id": "P4-D2-Q2",
    "point": "P4",
    "dimension": "D2",
    "question_number": 2,
    "question_text": "Analyze and validate process sequences",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "extract_temporal_markers",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "temporal_markers"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "extract_temporal_markers",
        "purpose": "Extract temporal sequence markers",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 2,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_detect_temporal_conflicts",
        "args": [],
        "returns": {
          "type": "List[Dict]",
          "binding": "temporal_conflicts"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_detect_temporal_conflicts",
        "purpose": "Detect conflicts in process sequencing",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [],
          "return_type": "List[Dict]",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 3,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "construct_causal_dag",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          },
          {
            "name": "indicators",
            "type": "List",
            "source": "process_indicators"
          }
        ],
        "returns": {
          "type": "nx.DiGraph",
          "binding": "process_dag"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "construct_causal_dag",
        "purpose": "Construct DAG of process dependencies",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            },
            {
              "name": "indicators",
              "type": "List",
              "source": "all_indicators"
            }
          ],
          "return_type": "nx.DiGraph",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 4,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "validate_causal_chain",
        "args": [
          {
            "name": "chain",
            "type": "List[Dict]",
            "source": "process_sequence"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "chain_validation"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "validate_causal_chain",
        "purpose": "Validate logical sequence of processes",
        "confidence_expected": 0.82,
        "signature": {
          "parameters": [
            {
              "name": "chain",
              "type": "List[Dict]",
              "source": "process_sequence"
            }
          ],
          "return_type": "Dict",
          "source_file": "dereck_beach.py"
        }
      }
    ],
    "contributing_modules": [
      "contradiction_deteccion.py",
      "dereck_beach.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "teoria_cambio",
    "evidence_types": [
      "chain_validation",
      "process_dag",
      "temporal_conflicts",
      "temporal_markers"
    ],
    "aggregation_strategy": "sequence_validation",
    "confidence_threshold": 0.8,
    "total_steps": 4
  },
  "P5-D2-Q2": {
    "question_id": "P5-D2-Q2",
    "point": "P5",
    "dimension": "D2",
    "question_number": 2,
    "question_text": "Analyze and validate process sequences",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "extract_temporal_markers",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "temporal_markers"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "extract_temporal_markers",
        "purpose": "Extract temporal sequence markers",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 2,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_detect_temporal_conflicts",
        "args": [],
        "returns": {
          "type": "List[Dict]",
          "binding": "temporal_conflicts"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_detect_temporal_conflicts",
        "purpose": "Detect conflicts in process sequencing",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [],
          "return_type": "List[Dict]",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 3,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "construct_causal_dag",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          },
          {
            "name": "indicators",
            "type": "List",
            "source": "process_indicators"
          }
        ],
        "returns": {
          "type": "nx.DiGraph",
          "binding": "process_dag"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "construct_causal_dag",
        "purpose": "Construct DAG of process dependencies",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            },
            {
              "name": "indicators",
              "type": "List",
              "source": "all_indicators"
            }
          ],
          "return_type": "nx.DiGraph",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 4,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "validate_causal_chain",
        "args": [
          {
            "name": "chain",
            "type": "List[Dict]",
            "source": "process_sequence"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "chain_validation"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "validate_causal_chain",
        "purpose": "Validate logical sequence of processes",
        "confidence_expected": 0.82,
        "signature": {
          "parameters": [
            {
              "name": "chain",
              "type": "List[Dict]",
              "source": "process_sequence"
            }
          ],
          "return_type": "Dict",
          "source_file": "dereck_beach.py"
        }
      }
    ],
    "contributing_modules": [
      "contradiction_deteccion.py",
      "dereck_beach.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "teoria_cambio",
    "evidence_types": [
      "chain_validation",
      "process_dag",
      "temporal_conflicts",
      "temporal_markers"
    ],
    "aggregation_strategy": "sequence_validation",
    "confidence_threshold": 0.8,
    "total_steps": 4
  },
  "P6-D2-Q2": {
    "question_id": "P6-D2-Q2",
    "point": "P6",
    "dimension": "D2",
    "question_number": 2,
    "question_text": "Analyze and validate process sequences",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "extract_temporal_markers",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "temporal_markers"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "extract_temporal_markers",
        "purpose": "Extract temporal sequence markers",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 2,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_detect_temporal_conflicts",
        "args": [],
        "returns": {
          "type": "List[Dict]",
          "binding": "temporal_conflicts"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_detect_temporal_conflicts",
        "purpose": "Detect conflicts in process sequencing",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [],
          "return_type": "List[Dict]",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 3,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "construct_causal_dag",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          },
          {
            "name": "indicators",
            "type": "List",
            "source": "process_indicators"
          }
        ],
        "returns": {
          "type": "nx.DiGraph",
          "binding": "process_dag"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "construct_causal_dag",
        "purpose": "Construct DAG of process dependencies",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            },
            {
              "name": "indicators",
              "type": "List",
              "source": "all_indicators"
            }
          ],
          "return_type": "nx.DiGraph",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 4,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "validate_causal_chain",
        "args": [
          {
            "name": "chain",
            "type": "List[Dict]",
            "source": "process_sequence"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "chain_validation"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "validate_causal_chain",
        "purpose": "Validate logical sequence of processes",
        "confidence_expected": 0.82,
        "signature": {
          "parameters": [
            {
              "name": "chain",
              "type": "List[Dict]",
              "source": "process_sequence"
            }
          ],
          "return_type": "Dict",
          "source_file": "dereck_beach.py"
        }
      }
    ],
    "contributing_modules": [
      "contradiction_deteccion.py",
      "dereck_beach.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "teoria_cambio",
    "evidence_types": [
      "chain_validation",
      "process_dag",
      "temporal_conflicts",
      "temporal_markers"
    ],
    "aggregation_strategy": "sequence_validation",
    "confidence_threshold": 0.8,
    "total_steps": 4
  },
  "P7-D2-Q2": {
    "question_id": "P7-D2-Q2",
    "point": "P7",
    "dimension": "D2",
    "question_number": 2,
    "question_text": "Analyze and validate process sequences",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "extract_temporal_markers",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "temporal_markers"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "extract_temporal_markers",
        "purpose": "Extract temporal sequence markers",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 2,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_detect_temporal_conflicts",
        "args": [],
        "returns": {
          "type": "List[Dict]",
          "binding": "temporal_conflicts"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_detect_temporal_conflicts",
        "purpose": "Detect conflicts in process sequencing",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [],
          "return_type": "List[Dict]",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 3,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "construct_causal_dag",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          },
          {
            "name": "indicators",
            "type": "List",
            "source": "process_indicators"
          }
        ],
        "returns": {
          "type": "nx.DiGraph",
          "binding": "process_dag"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "construct_causal_dag",
        "purpose": "Construct DAG of process dependencies",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            },
            {
              "name": "indicators",
              "type": "List",
              "source": "all_indicators"
            }
          ],
          "return_type": "nx.DiGraph",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 4,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "validate_causal_chain",
        "args": [
          {
            "name": "chain",
            "type": "List[Dict]",
            "source": "process_sequence"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "chain_validation"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "validate_causal_chain",
        "purpose": "Validate logical sequence of processes",
        "confidence_expected": 0.82,
        "signature": {
          "parameters": [
            {
              "name": "chain",
              "type": "List[Dict]",
              "source": "process_sequence"
            }
          ],
          "return_type": "Dict",
          "source_file": "dereck_beach.py"
        }
      }
    ],
    "contributing_modules": [
      "contradiction_deteccion.py",
      "dereck_beach.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "teoria_cambio",
    "evidence_types": [
      "chain_validation",
      "process_dag",
      "temporal_conflicts",
      "temporal_markers"
    ],
    "aggregation_strategy": "sequence_validation",
    "confidence_threshold": 0.8,
    "total_steps": 4
  },
  "P8-D2-Q2": {
    "question_id": "P8-D2-Q2",
    "point": "P8",
    "dimension": "D2",
    "question_number": 2,
    "question_text": "Analyze and validate process sequences",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "extract_temporal_markers",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "temporal_markers"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "extract_temporal_markers",
        "purpose": "Extract temporal sequence markers",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 2,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_detect_temporal_conflicts",
        "args": [],
        "returns": {
          "type": "List[Dict]",
          "binding": "temporal_conflicts"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_detect_temporal_conflicts",
        "purpose": "Detect conflicts in process sequencing",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [],
          "return_type": "List[Dict]",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 3,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "construct_causal_dag",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          },
          {
            "name": "indicators",
            "type": "List",
            "source": "process_indicators"
          }
        ],
        "returns": {
          "type": "nx.DiGraph",
          "binding": "process_dag"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "construct_causal_dag",
        "purpose": "Construct DAG of process dependencies",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            },
            {
              "name": "indicators",
              "type": "List",
              "source": "all_indicators"
            }
          ],
          "return_type": "nx.DiGraph",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 4,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "validate_causal_chain",
        "args": [
          {
            "name": "chain",
            "type": "List[Dict]",
            "source": "process_sequence"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "chain_validation"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "validate_causal_chain",
        "purpose": "Validate logical sequence of processes",
        "confidence_expected": 0.82,
        "signature": {
          "parameters": [
            {
              "name": "chain",
              "type": "List[Dict]",
              "source": "process_sequence"
            }
          ],
          "return_type": "Dict",
          "source_file": "dereck_beach.py"
        }
      }
    ],
    "contributing_modules": [
      "contradiction_deteccion.py",
      "dereck_beach.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "teoria_cambio",
    "evidence_types": [
      "chain_validation",
      "process_dag",
      "temporal_conflicts",
      "temporal_markers"
    ],
    "aggregation_strategy": "sequence_validation",
    "confidence_threshold": 0.8,
    "total_steps": 4
  },
  "P9-D2-Q2": {
    "question_id": "P9-D2-Q2",
    "point": "P9",
    "dimension": "D2",
    "question_number": 2,
    "question_text": "Analyze and validate process sequences",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "extract_temporal_markers",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "temporal_markers"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "extract_temporal_markers",
        "purpose": "Extract temporal sequence markers",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 2,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_detect_temporal_conflicts",
        "args": [],
        "returns": {
          "type": "List[Dict]",
          "binding": "temporal_conflicts"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_detect_temporal_conflicts",
        "purpose": "Detect conflicts in process sequencing",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [],
          "return_type": "List[Dict]",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 3,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "construct_causal_dag",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          },
          {
            "name": "indicators",
            "type": "List",
            "source": "process_indicators"
          }
        ],
        "returns": {
          "type": "nx.DiGraph",
          "binding": "process_dag"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "construct_causal_dag",
        "purpose": "Construct DAG of process dependencies",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            },
            {
              "name": "indicators",
              "type": "List",
              "source": "all_indicators"
            }
          ],
          "return_type": "nx.DiGraph",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 4,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "validate_causal_chain",
        "args": [
          {
            "name": "chain",
            "type": "List[Dict]",
            "source": "process_sequence"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "chain_validation"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "validate_causal_chain",
        "purpose": "Validate logical sequence of processes",
        "confidence_expected": 0.82,
        "signature": {
          "parameters": [
            {
              "name": "chain",
              "type": "List[Dict]",
              "source": "process_sequence"
            }
          ],
          "return_type": "Dict",
          "source_file": "dereck_beach.py"
        }
      }
    ],
    "contributing_modules": [
      "contradiction_deteccion.py",
      "dereck_beach.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "teoria_cambio",
    "evidence_types": [
      "chain_validation",
      "process_dag",
      "temporal_conflicts",
      "temporal_markers"
    ],
    "aggregation_strategy": "sequence_validation",
    "confidence_threshold": 0.8,
    "total_steps": 4
  },
  "P10-D2-Q2": {
    "question_id": "P10-D2-Q2",
    "point": "P10",
    "dimension": "D2",
    "question_number": 2,
    "question_text": "Analyze and validate process sequences",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "extract_temporal_markers",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "temporal_markers"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "extract_temporal_markers",
        "purpose": "Extract temporal sequence markers",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 2,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_detect_temporal_conflicts",
        "args": [],
        "returns": {
          "type": "List[Dict]",
          "binding": "temporal_conflicts"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_detect_temporal_conflicts",
        "purpose": "Detect conflicts in process sequencing",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [],
          "return_type": "List[Dict]",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 3,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "construct_causal_dag",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          },
          {
            "name": "indicators",
            "type": "List",
            "source": "process_indicators"
          }
        ],
        "returns": {
          "type": "nx.DiGraph",
          "binding": "process_dag"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "construct_causal_dag",
        "purpose": "Construct DAG of process dependencies",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            },
            {
              "name": "indicators",
              "type": "List",
              "source": "all_indicators"
            }
          ],
          "return_type": "nx.DiGraph",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 4,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "validate_causal_chain",
        "args": [
          {
            "name": "chain",
            "type": "List[Dict]",
            "source": "process_sequence"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "chain_validation"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "validate_causal_chain",
        "purpose": "Validate logical sequence of processes",
        "confidence_expected": 0.82,
        "signature": {
          "parameters": [
            {
              "name": "chain",
              "type": "List[Dict]",
              "source": "process_sequence"
            }
          ],
          "return_type": "Dict",
          "source_file": "dereck_beach.py"
        }
      }
    ],
    "contributing_modules": [
      "contradiction_deteccion.py",
      "dereck_beach.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "teoria_cambio",
    "evidence_types": [
      "chain_validation",
      "process_dag",
      "temporal_conflicts",
      "temporal_markers"
    ],
    "aggregation_strategy": "sequence_validation",
    "confidence_threshold": 0.8,
    "total_steps": 4
  },
  "P1-D2-Q3": {
    "question_id": "P1-D2-Q3",
    "point": "P1",
    "dimension": "D2",
    "question_number": 3,
    "question_text": "Assess quality and robustness of processes",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "analyzer_one",
        "adapter_class": "AnalyzerOneAdapter",
        "method": "assess_implementation_quality",
        "args": [
          {
            "name": "plan_text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "quality_assessment"
        },
        "source_module": "Analyzer_one.py",
        "source_class": "AnalyzerOneAdapter",
        "source_method": "assess_implementation_quality",
        "purpose": "Assess overall process quality",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "plan_text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "Dict",
          "source_file": "Analyzer_one.py"
        }
      },
      {
        "step": 2,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "calculate_robustness_score",
        "args": [
          {
            "name": "mechanism",
            "type": "Dict",
            "source": "process_mechanism"
          }
        ],
        "returns": {
          "type": "float",
          "binding": "robustness_score"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "calculate_robustness_score",
        "purpose": "Calculate process robustness",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "mechanism",
              "type": "Dict",
              "source": "process_mechanism"
            }
          ],
          "return_type": "float",
          "source_file": "dereck_beach.py"
        }
      },
      {
        "step": 3,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_calculate_syntactic_complexity",
        "args": [],
        "returns": {
          "type": "float",
          "binding": "complexity_score"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_calculate_syntactic_complexity",
        "purpose": "Measure process complexity",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [],
          "return_type": "float",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 4,
        "adapter": "financial_viability",
        "adapter_class": "FinancialViabilityAdapter",
        "method": "calculate_quality_score",
        "args": [
          {
            "name": "financial",
            "type": "Dict",
            "source": "financial_data"
          },
          {
            "name": "entities",
            "type": "List",
            "source": "responsible_entities"
          },
          {
            "name": "causal_dag",
            "type": "nx.DiGraph",
            "source": "process_dag"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "comprehensive_quality"
        },
        "source_module": "financiero_viabilidad_tablas.py",
        "source_class": "FinancialViabilityAdapter",
        "source_method": "calculate_quality_score",
        "purpose": "Calculate comprehensive quality score",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "financial",
              "type": "Dict",
              "source": "financial_data"
            },
            {
              "name": "entities",
              "type": "List",
              "source": "responsible_entities"
            },
            {
              "name": "causal_dag",
              "type": "nx.DiGraph",
              "source": "process_dag"
            }
          ],
          "return_type": "Dict",
          "source_file": "financiero_viabilidad_tablas.py"
        }
      }
    ],
    "contributing_modules": [
      "Analyzer_one.py",
      "contradiction_deteccion.py",
      "dereck_beach.py",
      "financiero_viabilidad_tablas.py"
    ],
    "primary_adapter": "analyzer_one",
    "evidence_types": [
      "complexity_score",
      "comprehensive_quality",
      "quality_assessment",
      "robustness_score"
    ],
    "aggregation_strategy": "quality_composite",
    "confidence_threshold": 0.78,
    "total_steps": 4
  },
  "P2-D2-Q3": {
    "question_id": "P2-D2-Q3",
    "point": "P2",
    "dimension": "D2",
    "question_number": 3,
    "question_text": "Assess quality and robustness of processes",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "analyzer_one",
        "adapter_class": "AnalyzerOneAdapter",
        "method": "assess_implementation_quality",
        "args": [
          {
            "name": "plan_text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "quality_assessment"
        },
        "source_module": "Analyzer_one.py",
        "source_class": "AnalyzerOneAdapter",
        "source_method": "assess_implementation_quality",
        "purpose": "Assess overall process quality",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "plan_text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "Dict",
          "source_file": "Analyzer_one.py"
        }
      },
      {
        "step": 2,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "calculate_robustness_score",
        "args": [
          {
            "name": "mechanism",
            "type": "Dict",
            "source": "process_mechanism"
          }
        ],
        "returns": {
          "type": "float",
          "binding": "robustness_score"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "calculate_robustness_score",
        "purpose": "Calculate process robustness",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "mechanism",
              "type": "Dict",
              "source": "process_mechanism"
            }
          ],
          "return_type": "float",
          "source_file": "dereck_beach.py"
        }
      },
      {
        "step": 3,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_calculate_syntactic_complexity",
        "args": [],
        "returns": {
          "type": "float",
          "binding": "complexity_score"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_calculate_syntactic_complexity",
        "purpose": "Measure process complexity",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [],
          "return_type": "float",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 4,
        "adapter": "financial_viability",
        "adapter_class": "FinancialViabilityAdapter",
        "method": "calculate_quality_score",
        "args": [
          {
            "name": "financial",
            "type": "Dict",
            "source": "financial_data"
          },
          {
            "name": "entities",
            "type": "List",
            "source": "responsible_entities"
          },
          {
            "name": "causal_dag",
            "type": "nx.DiGraph",
            "source": "process_dag"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "comprehensive_quality"
        },
        "source_module": "financiero_viabilidad_tablas.py",
        "source_class": "FinancialViabilityAdapter",
        "source_method": "calculate_quality_score",
        "purpose": "Calculate comprehensive quality score",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "financial",
              "type": "Dict",
              "source": "financial_data"
            },
            {
              "name": "entities",
              "type": "List",
              "source": "responsible_entities"
            },
            {
              "name": "causal_dag",
              "type": "nx.DiGraph",
              "source": "process_dag"
            }
          ],
          "return_type": "Dict",
          "source_file": "financiero_viabilidad_tablas.py"
        }
      }
    ],
    "contributing_modules": [
      "Analyzer_one.py",
      "contradiction_deteccion.py",
      "dereck_beach.py",
      "financiero_viabilidad_tablas.py"
    ],
    "primary_adapter": "analyzer_one",
    "evidence_types": [
      "complexity_score",
      "comprehensive_quality",
      "quality_assessment",
      "robustness_score"
    ],
    "aggregation_strategy": "quality_composite",
    "confidence_threshold": 0.78,
    "total_steps": 4
  },
  "P3-D2-Q3": {
    "question_id": "P3-D2-Q3",
    "point": "P3",
    "dimension": "D2",
    "question_number": 3,
    "question_text": "Assess quality and robustness of processes",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "analyzer_one",
        "adapter_class": "AnalyzerOneAdapter",
        "method": "assess_implementation_quality",
        "args": [
          {
            "name": "plan_text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "quality_assessment"
        },
        "source_module": "Analyzer_one.py",
        "source_class": "AnalyzerOneAdapter",
        "source_method": "assess_implementation_quality",
        "purpose": "Assess overall process quality",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "plan_text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "Dict",
          "source_file": "Analyzer_one.py"
        }
      },
      {
        "step": 2,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "calculate_robustness_score",
        "args": [
          {
            "name": "mechanism",
            "type": "Dict",
            "source": "process_mechanism"
          }
        ],
        "returns": {
          "type": "float",
          "binding": "robustness_score"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "calculate_robustness_score",
        "purpose": "Calculate process robustness",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "mechanism",
              "type": "Dict",
              "source": "process_mechanism"
            }
          ],
          "return_type": "float",
          "source_file": "dereck_beach.py"
        }
      },
      {
        "step": 3,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_calculate_syntactic_complexity",
        "args": [],
        "returns": {
          "type": "float",
          "binding": "complexity_score"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_calculate_syntactic_complexity",
        "purpose": "Measure process complexity",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [],
          "return_type": "float",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 4,
        "adapter": "financial_viability",
        "adapter_class": "FinancialViabilityAdapter",
        "method": "calculate_quality_score",
        "args": [
          {
            "name": "financial",
            "type": "Dict",
            "source": "financial_data"
          },
          {
            "name": "entities",
            "type": "List",
            "source": "responsible_entities"
          },
          {
            "name": "causal_dag",
            "type": "nx.DiGraph",
            "source": "process_dag"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "comprehensive_quality"
        },
        "source_module": "financiero_viabilidad_tablas.py",
        "source_class": "FinancialViabilityAdapter",
        "source_method": "calculate_quality_score",
        "purpose": "Calculate comprehensive quality score",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "financial",
              "type": "Dict",
              "source": "financial_data"
            },
            {
              "name": "entities",
              "type": "List",
              "source": "responsible_entities"
            },
            {
              "name": "causal_dag",
              "type": "nx.DiGraph",
              "source": "process_dag"
            }
          ],
          "return_type": "Dict",
          "source_file": "financiero_viabilidad_tablas.py"
        }
      }
    ],
    "contributing_modules": [
      "Analyzer_one.py",
      "contradiction_deteccion.py",
      "dereck_beach.py",
      "financiero_viabilidad_tablas.py"
    ],
    "primary_adapter": "analyzer_one",
    "evidence_types": [
      "complexity_score",
      "comprehensive_quality",
      "quality_assessment",
      "robustness_score"
    ],
    "aggregation_strategy": "quality_composite",
    "confidence_threshold": 0.78,
    "total_steps": 4
  },
  "P4-D2-Q3": {
    "question_id": "P4-D2-Q3",
    "point": "P4",
    "dimension": "D2",
    "question_number": 3,
    "question_text": "Assess quality and robustness of processes",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "analyzer_one",
        "adapter_class": "AnalyzerOneAdapter",
        "method": "assess_implementation_quality",
        "args": [
          {
            "name": "plan_text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "quality_assessment"
        },
        "source_module": "Analyzer_one.py",
        "source_class": "AnalyzerOneAdapter",
        "source_method": "assess_implementation_quality",
        "purpose": "Assess overall process quality",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "plan_text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "Dict",
          "source_file": "Analyzer_one.py"
        }
      },
      {
        "step": 2,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "calculate_robustness_score",
        "args": [
          {
            "name": "mechanism",
            "type": "Dict",
            "source": "process_mechanism"
          }
        ],
        "returns": {
          "type": "float",
          "binding": "robustness_score"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "calculate_robustness_score",
        "purpose": "Calculate process robustness",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "mechanism",
              "type": "Dict",
              "source": "process_mechanism"
            }
          ],
          "return_type": "float",
          "source_file": "dereck_beach.py"
        }
      },
      {
        "step": 3,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_calculate_syntactic_complexity",
        "args": [],
        "returns": {
          "type": "float",
          "binding": "complexity_score"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_calculate_syntactic_complexity",
        "purpose": "Measure process complexity",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [],
          "return_type": "float",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 4,
        "adapter": "financial_viability",
        "adapter_class": "FinancialViabilityAdapter",
        "method": "calculate_quality_score",
        "args": [
          {
            "name": "financial",
            "type": "Dict",
            "source": "financial_data"
          },
          {
            "name": "entities",
            "type": "List",
            "source": "responsible_entities"
          },
          {
            "name": "causal_dag",
            "type": "nx.DiGraph",
            "source": "process_dag"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "comprehensive_quality"
        },
        "source_module": "financiero_viabilidad_tablas.py",
        "source_class": "FinancialViabilityAdapter",
        "source_method": "calculate_quality_score",
        "purpose": "Calculate comprehensive quality score",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "financial",
              "type": "Dict",
              "source": "financial_data"
            },
            {
              "name": "entities",
              "type": "List",
              "source": "responsible_entities"
            },
            {
              "name": "causal_dag",
              "type": "nx.DiGraph",
              "source": "process_dag"
            }
          ],
          "return_type": "Dict",
          "source_file": "financiero_viabilidad_tablas.py"
        }
      }
    ],
    "contributing_modules": [
      "Analyzer_one.py",
      "contradiction_deteccion.py",
      "dereck_beach.py",
      "financiero_viabilidad_tablas.py"
    ],
    "primary_adapter": "analyzer_one",
    "evidence_types": [
      "complexity_score",
      "comprehensive_quality",
      "quality_assessment",
      "robustness_score"
    ],
    "aggregation_strategy": "quality_composite",
    "confidence_threshold": 0.78,
    "total_steps": 4
  },
  "P5-D2-Q3": {
    "question_id": "P5-D2-Q3",
    "point": "P5",
    "dimension": "D2",
    "question_number": 3,
    "question_text": "Assess quality and robustness of processes",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "analyzer_one",
        "adapter_class": "AnalyzerOneAdapter",
        "method": "assess_implementation_quality",
        "args": [
          {
            "name": "plan_text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "quality_assessment"
        },
        "source_module": "Analyzer_one.py",
        "source_class": "AnalyzerOneAdapter",
        "source_method": "assess_implementation_quality",
        "purpose": "Assess overall process quality",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "plan_text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "Dict",
          "source_file": "Analyzer_one.py"
        }
      },
      {
        "step": 2,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "calculate_robustness_score",
        "args": [
          {
            "name": "mechanism",
            "type": "Dict",
            "source": "process_mechanism"
          }
        ],
        "returns": {
          "type": "float",
          "binding": "robustness_score"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "calculate_robustness_score",
        "purpose": "Calculate process robustness",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "mechanism",
              "type": "Dict",
              "source": "process_mechanism"
            }
          ],
          "return_type": "float",
          "source_file": "dereck_beach.py"
        }
      },
      {
        "step": 3,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_calculate_syntactic_complexity",
        "args": [],
        "returns": {
          "type": "float",
          "binding": "complexity_score"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_calculate_syntactic_complexity",
        "purpose": "Measure process complexity",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [],
          "return_type": "float",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 4,
        "adapter": "financial_viability",
        "adapter_class": "FinancialViabilityAdapter",
        "method": "calculate_quality_score",
        "args": [
          {
            "name": "financial",
            "type": "Dict",
            "source": "financial_data"
          },
          {
            "name": "entities",
            "type": "List",
            "source": "responsible_entities"
          },
          {
            "name": "causal_dag",
            "type": "nx.DiGraph",
            "source": "process_dag"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "comprehensive_quality"
        },
        "source_module": "financiero_viabilidad_tablas.py",
        "source_class": "FinancialViabilityAdapter",
        "source_method": "calculate_quality_score",
        "purpose": "Calculate comprehensive quality score",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "financial",
              "type": "Dict",
              "source": "financial_data"
            },
            {
              "name": "entities",
              "type": "List",
              "source": "responsible_entities"
            },
            {
              "name": "causal_dag",
              "type": "nx.DiGraph",
              "source": "process_dag"
            }
          ],
          "return_type": "Dict",
          "source_file": "financiero_viabilidad_tablas.py"
        }
      }
    ],
    "contributing_modules": [
      "Analyzer_one.py",
      "contradiction_deteccion.py",
      "dereck_beach.py",
      "financiero_viabilidad_tablas.py"
    ],
    "primary_adapter": "analyzer_one",
    "evidence_types": [
      "complexity_score",
      "comprehensive_quality",
      "quality_assessment",
      "robustness_score"
    ],
    "aggregation_strategy": "quality_composite",
    "confidence_threshold": 0.78,
    "total_steps": 4
  },
  "P6-D2-Q3": {
    "question_id": "P6-D2-Q3",
    "point": "P6",
    "dimension": "D2",
    "question_number": 3,
    "question_text": "Assess quality and robustness of processes",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "analyzer_one",
        "adapter_class": "AnalyzerOneAdapter",
        "method": "assess_implementation_quality",
        "args": [
          {
            "name": "plan_text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "quality_assessment"
        },
        "source_module": "Analyzer_one.py",
        "source_class": "AnalyzerOneAdapter",
        "source_method": "assess_implementation_quality",
        "purpose": "Assess overall process quality",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "plan_text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "Dict",
          "source_file": "Analyzer_one.py"
        }
      },
      {
        "step": 2,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "calculate_robustness_score",
        "args": [
          {
            "name": "mechanism",
            "type": "Dict",
            "source": "process_mechanism"
          }
        ],
        "returns": {
          "type": "float",
          "binding": "robustness_score"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "calculate_robustness_score",
        "purpose": "Calculate process robustness",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "mechanism",
              "type": "Dict",
              "source": "process_mechanism"
            }
          ],
          "return_type": "float",
          "source_file": "dereck_beach.py"
        }
      },
      {
        "step": 3,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_calculate_syntactic_complexity",
        "args": [],
        "returns": {
          "type": "float",
          "binding": "complexity_score"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_calculate_syntactic_complexity",
        "purpose": "Measure process complexity",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [],
          "return_type": "float",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 4,
        "adapter": "financial_viability",
        "adapter_class": "FinancialViabilityAdapter",
        "method": "calculate_quality_score",
        "args": [
          {
            "name": "financial",
            "type": "Dict",
            "source": "financial_data"
          },
          {
            "name": "entities",
            "type": "List",
            "source": "responsible_entities"
          },
          {
            "name": "causal_dag",
            "type": "nx.DiGraph",
            "source": "process_dag"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "comprehensive_quality"
        },
        "source_module": "financiero_viabilidad_tablas.py",
        "source_class": "FinancialViabilityAdapter",
        "source_method": "calculate_quality_score",
        "purpose": "Calculate comprehensive quality score",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "financial",
              "type": "Dict",
              "source": "financial_data"
            },
            {
              "name": "entities",
              "type": "List",
              "source": "responsible_entities"
            },
            {
              "name": "causal_dag",
              "type": "nx.DiGraph",
              "source": "process_dag"
            }
          ],
          "return_type": "Dict",
          "source_file": "financiero_viabilidad_tablas.py"
        }
      }
    ],
    "contributing_modules": [
      "Analyzer_one.py",
      "contradiction_deteccion.py",
      "dereck_beach.py",
      "financiero_viabilidad_tablas.py"
    ],
    "primary_adapter": "analyzer_one",
    "evidence_types": [
      "complexity_score",
      "comprehensive_quality",
      "quality_assessment",
      "robustness_score"
    ],
    "aggregation_strategy": "quality_composite",
    "confidence_threshold": 0.78,
    "total_steps": 4
  },
  "P7-D2-Q3": {
    "question_id": "P7-D2-Q3",
    "point": "P7",
    "dimension": "D2",
    "question_number": 3,
    "question_text": "Assess quality and robustness of processes",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "analyzer_one",
        "adapter_class": "AnalyzerOneAdapter",
        "method": "assess_implementation_quality",
        "args": [
          {
            "name": "plan_text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "quality_assessment"
        },
        "source_module": "Analyzer_one.py",
        "source_class": "AnalyzerOneAdapter",
        "source_method": "assess_implementation_quality",
        "purpose": "Assess overall process quality",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "plan_text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "Dict",
          "source_file": "Analyzer_one.py"
        }
      },
      {
        "step": 2,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "calculate_robustness_score",
        "args": [
          {
            "name": "mechanism",
            "type": "Dict",
            "source": "process_mechanism"
          }
        ],
        "returns": {
          "type": "float",
          "binding": "robustness_score"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "calculate_robustness_score",
        "purpose": "Calculate process robustness",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "mechanism",
              "type": "Dict",
              "source": "process_mechanism"
            }
          ],
          "return_type": "float",
          "source_file": "dereck_beach.py"
        }
      },
      {
        "step": 3,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_calculate_syntactic_complexity",
        "args": [],
        "returns": {
          "type": "float",
          "binding": "complexity_score"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_calculate_syntactic_complexity",
        "purpose": "Measure process complexity",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [],
          "return_type": "float",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 4,
        "adapter": "financial_viability",
        "adapter_class": "FinancialViabilityAdapter",
        "method": "calculate_quality_score",
        "args": [
          {
            "name": "financial",
            "type": "Dict",
            "source": "financial_data"
          },
          {
            "name": "entities",
            "type": "List",
            "source": "responsible_entities"
          },
          {
            "name": "causal_dag",
            "type": "nx.DiGraph",
            "source": "process_dag"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "comprehensive_quality"
        },
        "source_module": "financiero_viabilidad_tablas.py",
        "source_class": "FinancialViabilityAdapter",
        "source_method": "calculate_quality_score",
        "purpose": "Calculate comprehensive quality score",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "financial",
              "type": "Dict",
              "source": "financial_data"
            },
            {
              "name": "entities",
              "type": "List",
              "source": "responsible_entities"
            },
            {
              "name": "causal_dag",
              "type": "nx.DiGraph",
              "source": "process_dag"
            }
          ],
          "return_type": "Dict",
          "source_file": "financiero_viabilidad_tablas.py"
        }
      }
    ],
    "contributing_modules": [
      "Analyzer_one.py",
      "contradiction_deteccion.py",
      "dereck_beach.py",
      "financiero_viabilidad_tablas.py"
    ],
    "primary_adapter": "analyzer_one",
    "evidence_types": [
      "complexity_score",
      "comprehensive_quality",
      "quality_assessment",
      "robustness_score"
    ],
    "aggregation_strategy": "quality_composite",
    "confidence_threshold": 0.78,
    "total_steps": 4
  },
  "P8-D2-Q3": {
    "question_id": "P8-D2-Q3",
    "point": "P8",
    "dimension": "D2",
    "question_number": 3,
    "question_text": "Assess quality and robustness of processes",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "analyzer_one",
        "adapter_class": "AnalyzerOneAdapter",
        "method": "assess_implementation_quality",
        "args": [
          {
            "name": "plan_text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "quality_assessment"
        },
        "source_module": "Analyzer_one.py",
        "source_class": "AnalyzerOneAdapter",
        "source_method": "assess_implementation_quality",
        "purpose": "Assess overall process quality",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "plan_text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "Dict",
          "source_file": "Analyzer_one.py"
        }
      },
      {
        "step": 2,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "calculate_robustness_score",
        "args": [
          {
            "name": "mechanism",
            "type": "Dict",
            "source": "process_mechanism"
          }
        ],
        "returns": {
          "type": "float",
          "binding": "robustness_score"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "calculate_robustness_score",
        "purpose": "Calculate process robustness",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "mechanism",
              "type": "Dict",
              "source": "process_mechanism"
            }
          ],
          "return_type": "float",
          "source_file": "dereck_beach.py"
        }
      },
      {
        "step": 3,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_calculate_syntactic_complexity",
        "args": [],
        "returns": {
          "type": "float",
          "binding": "complexity_score"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_calculate_syntactic_complexity",
        "purpose": "Measure process complexity",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [],
          "return_type": "float",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 4,
        "adapter": "financial_viability",
        "adapter_class": "FinancialViabilityAdapter",
        "method": "calculate_quality_score",
        "args": [
          {
            "name": "financial",
            "type": "Dict",
            "source": "financial_data"
          },
          {
            "name": "entities",
            "type": "List",
            "source": "responsible_entities"
          },
          {
            "name": "causal_dag",
            "type": "nx.DiGraph",
            "source": "process_dag"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "comprehensive_quality"
        },
        "source_module": "financiero_viabilidad_tablas.py",
        "source_class": "FinancialViabilityAdapter",
        "source_method": "calculate_quality_score",
        "purpose": "Calculate comprehensive quality score",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "financial",
              "type": "Dict",
              "source": "financial_data"
            },
            {
              "name": "entities",
              "type": "List",
              "source": "responsible_entities"
            },
            {
              "name": "causal_dag",
              "type": "nx.DiGraph",
              "source": "process_dag"
            }
          ],
          "return_type": "Dict",
          "source_file": "financiero_viabilidad_tablas.py"
        }
      }
    ],
    "contributing_modules": [
      "Analyzer_one.py",
      "contradiction_deteccion.py",
      "dereck_beach.py",
      "financiero_viabilidad_tablas.py"
    ],
    "primary_adapter": "analyzer_one",
    "evidence_types": [
      "complexity_score",
      "comprehensive_quality",
      "quality_assessment",
      "robustness_score"
    ],
    "aggregation_strategy": "quality_composite",
    "confidence_threshold": 0.78,
    "total_steps": 4
  },
  "P9-D2-Q3": {
    "question_id": "P9-D2-Q3",
    "point": "P9",
    "dimension": "D2",
    "question_number": 3,
    "question_text": "Assess quality and robustness of processes",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "analyzer_one",
        "adapter_class": "AnalyzerOneAdapter",
        "method": "assess_implementation_quality",
        "args": [
          {
            "name": "plan_text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "quality_assessment"
        },
        "source_module": "Analyzer_one.py",
        "source_class": "AnalyzerOneAdapter",
        "source_method": "assess_implementation_quality",
        "purpose": "Assess overall process quality",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "plan_text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "Dict",
          "source_file": "Analyzer_one.py"
        }
      },
      {
        "step": 2,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "calculate_robustness_score",
        "args": [
          {
            "name": "mechanism",
            "type": "Dict",
            "source": "process_mechanism"
          }
        ],
        "returns": {
          "type": "float",
          "binding": "robustness_score"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "calculate_robustness_score",
        "purpose": "Calculate process robustness",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "mechanism",
              "type": "Dict",
              "source": "process_mechanism"
            }
          ],
          "return_type": "float",
          "source_file": "dereck_beach.py"
        }
      },
      {
        "step": 3,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_calculate_syntactic_complexity",
        "args": [],
        "returns": {
          "type": "float",
          "binding": "complexity_score"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_calculate_syntactic_complexity",
        "purpose": "Measure process complexity",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [],
          "return_type": "float",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 4,
        "adapter": "financial_viability",
        "adapter_class": "FinancialViabilityAdapter",
        "method": "calculate_quality_score",
        "args": [
          {
            "name": "financial",
            "type": "Dict",
            "source": "financial_data"
          },
          {
            "name": "entities",
            "type": "List",
            "source": "responsible_entities"
          },
          {
            "name": "causal_dag",
            "type": "nx.DiGraph",
            "source": "process_dag"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "comprehensive_quality"
        },
        "source_module": "financiero_viabilidad_tablas.py",
        "source_class": "FinancialViabilityAdapter",
        "source_method": "calculate_quality_score",
        "purpose": "Calculate comprehensive quality score",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "financial",
              "type": "Dict",
              "source": "financial_data"
            },
            {
              "name": "entities",
              "type": "List",
              "source": "responsible_entities"
            },
            {
              "name": "causal_dag",
              "type": "nx.DiGraph",
              "source": "process_dag"
            }
          ],
          "return_type": "Dict",
          "source_file": "financiero_viabilidad_tablas.py"
        }
      }
    ],
    "contributing_modules": [
      "Analyzer_one.py",
      "contradiction_deteccion.py",
      "dereck_beach.py",
      "financiero_viabilidad_tablas.py"
    ],
    "primary_adapter": "analyzer_one",
    "evidence_types": [
      "complexity_score",
      "comprehensive_quality",
      "quality_assessment",
      "robustness_score"
    ],
    "aggregation_strategy": "quality_composite",
    "confidence_threshold": 0.78,
    "total_steps": 4
  },
  "P10-D2-Q3": {
    "question_id": "P10-D2-Q3",
    "point": "P10",
    "dimension": "D2",
    "question_number": 3,
    "question_text": "Assess quality and robustness of processes",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "analyzer_one",
        "adapter_class": "AnalyzerOneAdapter",
        "method": "assess_implementation_quality",
        "args": [
          {
            "name": "plan_text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "quality_assessment"
        },
        "source_module": "Analyzer_one.py",
        "source_class": "AnalyzerOneAdapter",
        "source_method": "assess_implementation_quality",
        "purpose": "Assess overall process quality",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "plan_text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "Dict",
          "source_file": "Analyzer_one.py"
        }
      },
      {
        "step": 2,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "calculate_robustness_score",
        "args": [
          {
            "name": "mechanism",
            "type": "Dict",
            "source": "process_mechanism"
          }
        ],
        "returns": {
          "type": "float",
          "binding": "robustness_score"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "calculate_robustness_score",
        "purpose": "Calculate process robustness",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "mechanism",
              "type": "Dict",
              "source": "process_mechanism"
            }
          ],
          "return_type": "float",
          "source_file": "dereck_beach.py"
        }
      },
      {
        "step": 3,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_calculate_syntactic_complexity",
        "args": [],
        "returns": {
          "type": "float",
          "binding": "complexity_score"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_calculate_syntactic_complexity",
        "purpose": "Measure process complexity",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [],
          "return_type": "float",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 4,
        "adapter": "financial_viability",
        "adapter_class": "FinancialViabilityAdapter",
        "method": "calculate_quality_score",
        "args": [
          {
            "name": "financial",
            "type": "Dict",
            "source": "financial_data"
          },
          {
            "name": "entities",
            "type": "List",
            "source": "responsible_entities"
          },
          {
            "name": "causal_dag",
            "type": "nx.DiGraph",
            "source": "process_dag"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "comprehensive_quality"
        },
        "source_module": "financiero_viabilidad_tablas.py",
        "source_class": "FinancialViabilityAdapter",
        "source_method": "calculate_quality_score",
        "purpose": "Calculate comprehensive quality score",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "financial",
              "type": "Dict",
              "source": "financial_data"
            },
            {
              "name": "entities",
              "type": "List",
              "source": "responsible_entities"
            },
            {
              "name": "causal_dag",
              "type": "nx.DiGraph",
              "source": "process_dag"
            }
          ],
          "return_type": "Dict",
          "source_file": "financiero_viabilidad_tablas.py"
        }
      }
    ],
    "contributing_modules": [
      "Analyzer_one.py",
      "contradiction_deteccion.py",
      "dereck_beach.py",
      "financiero_viabilidad_tablas.py"
    ],
    "primary_adapter": "analyzer_one",
    "evidence_types": [
      "complexity_score",
      "comprehensive_quality",
      "quality_assessment",
      "robustness_score"
    ],
    "aggregation_strategy": "quality_composite",
    "confidence_threshold": 0.78,
    "total_steps": 4
  },
  "P1-D2-Q4": {
    "question_id": "P1-D2-Q4",
    "point": "P1",
    "dimension": "D2",
    "question_number": 4,
    "question_text": "Analyze resource allocation across processes",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "financial_viability",
        "adapter_class": "FinancialViabilityAdapter",
        "method": "_extract_budget_for_pillar",
        "args": [
          {
            "name": "pillar",
            "type": "str",
            "source": "process_pillar"
          },
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "float",
          "binding": "pillar_budget"
        },
        "source_module": "financiero_viabilidad_tablas.py",
        "source_class": "FinancialViabilityAdapter",
        "source_method": "_extract_budget_for_pillar",
        "purpose": "Extract budget allocated to process pillar",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "pillar",
              "type": "str",
              "source": "process_pillar"
            },
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "float",
          "source_file": "financiero_viabilidad_tablas.py"
        }
      },
      {
        "step": 2,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_detect_resource_conflicts",
        "args": [],
        "returns": {
          "type": "List[Dict]",
          "binding": "resource_conflicts"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_detect_resource_conflicts",
        "purpose": "Detect resource allocation conflicts",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [],
          "return_type": "List[Dict]",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 3,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "trace_financial_flows",
        "args": [
          {
            "name": "allocations",
            "type": "List[Dict]",
            "source": "budget_allocations"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "financial_flows"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "trace_financial_flows",
        "purpose": "Trace financial flows across processes",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "allocations",
              "type": "List[Dict]",
              "source": "budget_allocations"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 4,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "assess_financial_capacity",
        "args": [
          {
            "name": "budget_data",
            "type": "Dict",
            "source": "financial_data"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "financial_capacity"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "assess_financial_capacity",
        "purpose": "Assess financial capacity for processes",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "budget_data",
              "type": "Dict",
              "source": "financial_data"
            }
          ],
          "return_type": "Dict",
          "source_file": "dereck_beach.py"
        }
      }
    ],
    "contributing_modules": [
      "contradiction_deteccion.py",
      "dereck_beach.py",
      "financiero_viabilidad_tablas.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "financial_viability",
    "evidence_types": [
      "financial_capacity",
      "financial_flows",
      "pillar_budget",
      "resource_conflicts"
    ],
    "aggregation_strategy": "resource_synthesis",
    "confidence_threshold": 0.8,
    "total_steps": 4
  },
  "P2-D2-Q4": {
    "question_id": "P2-D2-Q4",
    "point": "P2",
    "dimension": "D2",
    "question_number": 4,
    "question_text": "Analyze resource allocation across processes",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "financial_viability",
        "adapter_class": "FinancialViabilityAdapter",
        "method": "_extract_budget_for_pillar",
        "args": [
          {
            "name": "pillar",
            "type": "str",
            "source": "process_pillar"
          },
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "float",
          "binding": "pillar_budget"
        },
        "source_module": "financiero_viabilidad_tablas.py",
        "source_class": "FinancialViabilityAdapter",
        "source_method": "_extract_budget_for_pillar",
        "purpose": "Extract budget allocated to process pillar",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "pillar",
              "type": "str",
              "source": "process_pillar"
            },
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "float",
          "source_file": "financiero_viabilidad_tablas.py"
        }
      },
      {
        "step": 2,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_detect_resource_conflicts",
        "args": [],
        "returns": {
          "type": "List[Dict]",
          "binding": "resource_conflicts"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_detect_resource_conflicts",
        "purpose": "Detect resource allocation conflicts",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [],
          "return_type": "List[Dict]",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 3,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "trace_financial_flows",
        "args": [
          {
            "name": "allocations",
            "type": "List[Dict]",
            "source": "budget_allocations"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "financial_flows"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "trace_financial_flows",
        "purpose": "Trace financial flows across processes",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "allocations",
              "type": "List[Dict]",
              "source": "budget_allocations"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 4,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "assess_financial_capacity",
        "args": [
          {
            "name": "budget_data",
            "type": "Dict",
            "source": "financial_data"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "financial_capacity"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "assess_financial_capacity",
        "purpose": "Assess financial capacity for processes",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "budget_data",
              "type": "Dict",
              "source": "financial_data"
            }
          ],
          "return_type": "Dict",
          "source_file": "dereck_beach.py"
        }
      }
    ],
    "contributing_modules": [
      "contradiction_deteccion.py",
      "dereck_beach.py",
      "financiero_viabilidad_tablas.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "financial_viability",
    "evidence_types": [
      "financial_capacity",
      "financial_flows",
      "pillar_budget",
      "resource_conflicts"
    ],
    "aggregation_strategy": "resource_synthesis",
    "confidence_threshold": 0.8,
    "total_steps": 4
  },
  "P3-D2-Q4": {
    "question_id": "P3-D2-Q4",
    "point": "P3",
    "dimension": "D2",
    "question_number": 4,
    "question_text": "Analyze resource allocation across processes",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "financial_viability",
        "adapter_class": "FinancialViabilityAdapter",
        "method": "_extract_budget_for_pillar",
        "args": [
          {
            "name": "pillar",
            "type": "str",
            "source": "process_pillar"
          },
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "float",
          "binding": "pillar_budget"
        },
        "source_module": "financiero_viabilidad_tablas.py",
        "source_class": "FinancialViabilityAdapter",
        "source_method": "_extract_budget_for_pillar",
        "purpose": "Extract budget allocated to process pillar",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "pillar",
              "type": "str",
              "source": "process_pillar"
            },
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "float",
          "source_file": "financiero_viabilidad_tablas.py"
        }
      },
      {
        "step": 2,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_detect_resource_conflicts",
        "args": [],
        "returns": {
          "type": "List[Dict]",
          "binding": "resource_conflicts"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_detect_resource_conflicts",
        "purpose": "Detect resource allocation conflicts",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [],
          "return_type": "List[Dict]",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 3,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "trace_financial_flows",
        "args": [
          {
            "name": "allocations",
            "type": "List[Dict]",
            "source": "budget_allocations"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "financial_flows"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "trace_financial_flows",
        "purpose": "Trace financial flows across processes",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "allocations",
              "type": "List[Dict]",
              "source": "budget_allocations"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 4,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "assess_financial_capacity",
        "args": [
          {
            "name": "budget_data",
            "type": "Dict",
            "source": "financial_data"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "financial_capacity"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "assess_financial_capacity",
        "purpose": "Assess financial capacity for processes",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "budget_data",
              "type": "Dict",
              "source": "financial_data"
            }
          ],
          "return_type": "Dict",
          "source_file": "dereck_beach.py"
        }
      }
    ],
    "contributing_modules": [
      "contradiction_deteccion.py",
      "dereck_beach.py",
      "financiero_viabilidad_tablas.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "financial_viability",
    "evidence_types": [
      "financial_capacity",
      "financial_flows",
      "pillar_budget",
      "resource_conflicts"
    ],
    "aggregation_strategy": "resource_synthesis",
    "confidence_threshold": 0.8,
    "total_steps": 4
  },
  "P4-D2-Q4": {
    "question_id": "P4-D2-Q4",
    "point": "P4",
    "dimension": "D2",
    "question_number": 4,
    "question_text": "Analyze resource allocation across processes",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "financial_viability",
        "adapter_class": "FinancialViabilityAdapter",
        "method": "_extract_budget_for_pillar",
        "args": [
          {
            "name": "pillar",
            "type": "str",
            "source": "process_pillar"
          },
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "float",
          "binding": "pillar_budget"
        },
        "source_module": "financiero_viabilidad_tablas.py",
        "source_class": "FinancialViabilityAdapter",
        "source_method": "_extract_budget_for_pillar",
        "purpose": "Extract budget allocated to process pillar",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "pillar",
              "type": "str",
              "source": "process_pillar"
            },
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "float",
          "source_file": "financiero_viabilidad_tablas.py"
        }
      },
      {
        "step": 2,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_detect_resource_conflicts",
        "args": [],
        "returns": {
          "type": "List[Dict]",
          "binding": "resource_conflicts"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_detect_resource_conflicts",
        "purpose": "Detect resource allocation conflicts",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [],
          "return_type": "List[Dict]",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 3,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "trace_financial_flows",
        "args": [
          {
            "name": "allocations",
            "type": "List[Dict]",
            "source": "budget_allocations"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "financial_flows"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "trace_financial_flows",
        "purpose": "Trace financial flows across processes",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "allocations",
              "type": "List[Dict]",
              "source": "budget_allocations"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 4,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "assess_financial_capacity",
        "args": [
          {
            "name": "budget_data",
            "type": "Dict",
            "source": "financial_data"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "financial_capacity"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "assess_financial_capacity",
        "purpose": "Assess financial capacity for processes",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "budget_data",
              "type": "Dict",
              "source": "financial_data"
            }
          ],
          "return_type": "Dict",
          "source_file": "dereck_beach.py"
        }
      }
    ],
    "contributing_modules": [
      "contradiction_deteccion.py",
      "dereck_beach.py",
      "financiero_viabilidad_tablas.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "financial_viability",
    "evidence_types": [
      "financial_capacity",
      "financial_flows",
      "pillar_budget",
      "resource_conflicts"
    ],
    "aggregation_strategy": "resource_synthesis",
    "confidence_threshold": 0.8,
    "total_steps": 4
  },
  "P5-D2-Q4": {
    "question_id": "P5-D2-Q4",
    "point": "P5",
    "dimension": "D2",
    "question_number": 4,
    "question_text": "Analyze resource allocation across processes",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "financial_viability",
        "adapter_class": "FinancialViabilityAdapter",
        "method": "_extract_budget_for_pillar",
        "args": [
          {
            "name": "pillar",
            "type": "str",
            "source": "process_pillar"
          },
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "float",
          "binding": "pillar_budget"
        },
        "source_module": "financiero_viabilidad_tablas.py",
        "source_class": "FinancialViabilityAdapter",
        "source_method": "_extract_budget_for_pillar",
        "purpose": "Extract budget allocated to process pillar",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "pillar",
              "type": "str",
              "source": "process_pillar"
            },
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "float",
          "source_file": "financiero_viabilidad_tablas.py"
        }
      },
      {
        "step": 2,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_detect_resource_conflicts",
        "args": [],
        "returns": {
          "type": "List[Dict]",
          "binding": "resource_conflicts"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_detect_resource_conflicts",
        "purpose": "Detect resource allocation conflicts",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [],
          "return_type": "List[Dict]",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 3,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "trace_financial_flows",
        "args": [
          {
            "name": "allocations",
            "type": "List[Dict]",
            "source": "budget_allocations"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "financial_flows"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "trace_financial_flows",
        "purpose": "Trace financial flows across processes",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "allocations",
              "type": "List[Dict]",
              "source": "budget_allocations"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 4,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "assess_financial_capacity",
        "args": [
          {
            "name": "budget_data",
            "type": "Dict",
            "source": "financial_data"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "financial_capacity"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "assess_financial_capacity",
        "purpose": "Assess financial capacity for processes",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "budget_data",
              "type": "Dict",
              "source": "financial_data"
            }
          ],
          "return_type": "Dict",
          "source_file": "dereck_beach.py"
        }
      }
    ],
    "contributing_modules": [
      "contradiction_deteccion.py",
      "dereck_beach.py",
      "financiero_viabilidad_tablas.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "financial_viability",
    "evidence_types": [
      "financial_capacity",
      "financial_flows",
      "pillar_budget",
      "resource_conflicts"
    ],
    "aggregation_strategy": "resource_synthesis",
    "confidence_threshold": 0.8,
    "total_steps": 4
  },
  "P6-D2-Q4": {
    "question_id": "P6-D2-Q4",
    "point": "P6",
    "dimension": "D2",
    "question_number": 4,
    "question_text": "Analyze resource allocation across processes",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "financial_viability",
        "adapter_class": "FinancialViabilityAdapter",
        "method": "_extract_budget_for_pillar",
        "args": [
          {
            "name": "pillar",
            "type": "str",
            "source": "process_pillar"
          },
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "float",
          "binding": "pillar_budget"
        },
        "source_module": "financiero_viabilidad_tablas.py",
        "source_class": "FinancialViabilityAdapter",
        "source_method": "_extract_budget_for_pillar",
        "purpose": "Extract budget allocated to process pillar",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "pillar",
              "type": "str",
              "source": "process_pillar"
            },
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "float",
          "source_file": "financiero_viabilidad_tablas.py"
        }
      },
      {
        "step": 2,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_detect_resource_conflicts",
        "args": [],
        "returns": {
          "type": "List[Dict]",
          "binding": "resource_conflicts"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_detect_resource_conflicts",
        "purpose": "Detect resource allocation conflicts",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [],
          "return_type": "List[Dict]",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 3,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "trace_financial_flows",
        "args": [
          {
            "name": "allocations",
            "type": "List[Dict]",
            "source": "budget_allocations"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "financial_flows"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "trace_financial_flows",
        "purpose": "Trace financial flows across processes",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "allocations",
              "type": "List[Dict]",
              "source": "budget_allocations"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 4,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "assess_financial_capacity",
        "args": [
          {
            "name": "budget_data",
            "type": "Dict",
            "source": "financial_data"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "financial_capacity"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "assess_financial_capacity",
        "purpose": "Assess financial capacity for processes",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "budget_data",
              "type": "Dict",
              "source": "financial_data"
            }
          ],
          "return_type": "Dict",
          "source_file": "dereck_beach.py"
        }
      }
    ],
    "contributing_modules": [
      "contradiction_deteccion.py",
      "dereck_beach.py",
      "financiero_viabilidad_tablas.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "financial_viability",
    "evidence_types": [
      "financial_capacity",
      "financial_flows",
      "pillar_budget",
      "resource_conflicts"
    ],
    "aggregation_strategy": "resource_synthesis",
    "confidence_threshold": 0.8,
    "total_steps": 4
  },
  "P7-D2-Q4": {
    "question_id": "P7-D2-Q4",
    "point": "P7",
    "dimension": "D2",
    "question_number": 4,
    "question_text": "Analyze resource allocation across processes",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "financial_viability",
        "adapter_class": "FinancialViabilityAdapter",
        "method": "_extract_budget_for_pillar",
        "args": [
          {
            "name": "pillar",
            "type": "str",
            "source": "process_pillar"
          },
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "float",
          "binding": "pillar_budget"
        },
        "source_module": "financiero_viabilidad_tablas.py",
        "source_class": "FinancialViabilityAdapter",
        "source_method": "_extract_budget_for_pillar",
        "purpose": "Extract budget allocated to process pillar",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "pillar",
              "type": "str",
              "source": "process_pillar"
            },
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "float",
          "source_file": "financiero_viabilidad_tablas.py"
        }
      },
      {
        "step": 2,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_detect_resource_conflicts",
        "args": [],
        "returns": {
          "type": "List[Dict]",
          "binding": "resource_conflicts"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_detect_resource_conflicts",
        "purpose": "Detect resource allocation conflicts",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [],
          "return_type": "List[Dict]",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 3,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "trace_financial_flows",
        "args": [
          {
            "name": "allocations",
            "type": "List[Dict]",
            "source": "budget_allocations"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "financial_flows"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "trace_financial_flows",
        "purpose": "Trace financial flows across processes",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "allocations",
              "type": "List[Dict]",
              "source": "budget_allocations"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 4,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "assess_financial_capacity",
        "args": [
          {
            "name": "budget_data",
            "type": "Dict",
            "source": "financial_data"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "financial_capacity"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "assess_financial_capacity",
        "purpose": "Assess financial capacity for processes",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "budget_data",
              "type": "Dict",
              "source": "financial_data"
            }
          ],
          "return_type": "Dict",
          "source_file": "dereck_beach.py"
        }
      }
    ],
    "contributing_modules": [
      "contradiction_deteccion.py",
      "dereck_beach.py",
      "financiero_viabilidad_tablas.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "financial_viability",
    "evidence_types": [
      "financial_capacity",
      "financial_flows",
      "pillar_budget",
      "resource_conflicts"
    ],
    "aggregation_strategy": "resource_synthesis",
    "confidence_threshold": 0.8,
    "total_steps": 4
  },
  "P8-D2-Q4": {
    "question_id": "P8-D2-Q4",
    "point": "P8",
    "dimension": "D2",
    "question_number": 4,
    "question_text": "Analyze resource allocation across processes",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "financial_viability",
        "adapter_class": "FinancialViabilityAdapter",
        "method": "_extract_budget_for_pillar",
        "args": [
          {
            "name": "pillar",
            "type": "str",
            "source": "process_pillar"
          },
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "float",
          "binding": "pillar_budget"
        },
        "source_module": "financiero_viabilidad_tablas.py",
        "source_class": "FinancialViabilityAdapter",
        "source_method": "_extract_budget_for_pillar",
        "purpose": "Extract budget allocated to process pillar",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "pillar",
              "type": "str",
              "source": "process_pillar"
            },
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "float",
          "source_file": "financiero_viabilidad_tablas.py"
        }
      },
      {
        "step": 2,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_detect_resource_conflicts",
        "args": [],
        "returns": {
          "type": "List[Dict]",
          "binding": "resource_conflicts"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_detect_resource_conflicts",
        "purpose": "Detect resource allocation conflicts",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [],
          "return_type": "List[Dict]",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 3,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "trace_financial_flows",
        "args": [
          {
            "name": "allocations",
            "type": "List[Dict]",
            "source": "budget_allocations"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "financial_flows"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "trace_financial_flows",
        "purpose": "Trace financial flows across processes",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "allocations",
              "type": "List[Dict]",
              "source": "budget_allocations"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 4,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "assess_financial_capacity",
        "args": [
          {
            "name": "budget_data",
            "type": "Dict",
            "source": "financial_data"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "financial_capacity"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "assess_financial_capacity",
        "purpose": "Assess financial capacity for processes",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "budget_data",
              "type": "Dict",
              "source": "financial_data"
            }
          ],
          "return_type": "Dict",
          "source_file": "dereck_beach.py"
        }
      }
    ],
    "contributing_modules": [
      "contradiction_deteccion.py",
      "dereck_beach.py",
      "financiero_viabilidad_tablas.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "financial_viability",
    "evidence_types": [
      "financial_capacity",
      "financial_flows",
      "pillar_budget",
      "resource_conflicts"
    ],
    "aggregation_strategy": "resource_synthesis",
    "confidence_threshold": 0.8,
    "total_steps": 4
  },
  "P9-D2-Q4": {
    "question_id": "P9-D2-Q4",
    "point": "P9",
    "dimension": "D2",
    "question_number": 4,
    "question_text": "Analyze resource allocation across processes",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "financial_viability",
        "adapter_class": "FinancialViabilityAdapter",
        "method": "_extract_budget_for_pillar",
        "args": [
          {
            "name": "pillar",
            "type": "str",
            "source": "process_pillar"
          },
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "float",
          "binding": "pillar_budget"
        },
        "source_module": "financiero_viabilidad_tablas.py",
        "source_class": "FinancialViabilityAdapter",
        "source_method": "_extract_budget_for_pillar",
        "purpose": "Extract budget allocated to process pillar",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "pillar",
              "type": "str",
              "source": "process_pillar"
            },
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "float",
          "source_file": "financiero_viabilidad_tablas.py"
        }
      },
      {
        "step": 2,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_detect_resource_conflicts",
        "args": [],
        "returns": {
          "type": "List[Dict]",
          "binding": "resource_conflicts"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_detect_resource_conflicts",
        "purpose": "Detect resource allocation conflicts",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [],
          "return_type": "List[Dict]",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 3,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "trace_financial_flows",
        "args": [
          {
            "name": "allocations",
            "type": "List[Dict]",
            "source": "budget_allocations"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "financial_flows"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "trace_financial_flows",
        "purpose": "Trace financial flows across processes",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "allocations",
              "type": "List[Dict]",
              "source": "budget_allocations"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 4,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "assess_financial_capacity",
        "args": [
          {
            "name": "budget_data",
            "type": "Dict",
            "source": "financial_data"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "financial_capacity"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "assess_financial_capacity",
        "purpose": "Assess financial capacity for processes",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "budget_data",
              "type": "Dict",
              "source": "financial_data"
            }
          ],
          "return_type": "Dict",
          "source_file": "dereck_beach.py"
        }
      }
    ],
    "contributing_modules": [
      "contradiction_deteccion.py",
      "dereck_beach.py",
      "financiero_viabilidad_tablas.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "financial_viability",
    "evidence_types": [
      "financial_capacity",
      "financial_flows",
      "pillar_budget",
      "resource_conflicts"
    ],
    "aggregation_strategy": "resource_synthesis",
    "confidence_threshold": 0.8,
    "total_steps": 4
  },
  "P10-D2-Q4": {
    "question_id": "P10-D2-Q4",
    "point": "P10",
    "dimension": "D2",
    "question_number": 4,
    "question_text": "Analyze resource allocation across processes",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "financial_viability",
        "adapter_class": "FinancialViabilityAdapter",
        "method": "_extract_budget_for_pillar",
        "args": [
          {
            "name": "pillar",
            "type": "str",
            "source": "process_pillar"
          },
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "float",
          "binding": "pillar_budget"
        },
        "source_module": "financiero_viabilidad_tablas.py",
        "source_class": "FinancialViabilityAdapter",
        "source_method": "_extract_budget_for_pillar",
        "purpose": "Extract budget allocated to process pillar",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "pillar",
              "type": "str",
              "source": "process_pillar"
            },
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "float",
          "source_file": "financiero_viabilidad_tablas.py"
        }
      },
      {
        "step": 2,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_detect_resource_conflicts",
        "args": [],
        "returns": {
          "type": "List[Dict]",
          "binding": "resource_conflicts"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_detect_resource_conflicts",
        "purpose": "Detect resource allocation conflicts",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [],
          "return_type": "List[Dict]",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 3,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "trace_financial_flows",
        "args": [
          {
            "name": "allocations",
            "type": "List[Dict]",
            "source": "budget_allocations"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "financial_flows"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "trace_financial_flows",
        "purpose": "Trace financial flows across processes",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "allocations",
              "type": "List[Dict]",
              "source": "budget_allocations"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 4,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "assess_financial_capacity",
        "args": [
          {
            "name": "budget_data",
            "type": "Dict",
            "source": "financial_data"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "financial_capacity"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "assess_financial_capacity",
        "purpose": "Assess financial capacity for processes",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "budget_data",
              "type": "Dict",
              "source": "financial_data"
            }
          ],
          "return_type": "Dict",
          "source_file": "dereck_beach.py"
        }
      }
    ],
    "contributing_modules": [
      "contradiction_deteccion.py",
      "dereck_beach.py",
      "financiero_viabilidad_tablas.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "financial_viability",
    "evidence_types": [
      "financial_capacity",
      "financial_flows",
      "pillar_budget",
      "resource_conflicts"
    ],
    "aggregation_strategy": "resource_synthesis",
    "confidence_threshold": 0.8,
    "total_steps": 4
  },
  "P1-D2-Q5": {
    "question_id": "P1-D2-Q5",
    "point": "P1",
    "dimension": "D2",
    "question_number": 5,
    "question_text": "Evaluate process monitoring and control mechanisms",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "extract_monitoring_indicators",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "monitoring_indicators"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "extract_monitoring_indicators",
        "purpose": "Extract process monitoring indicators",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "emebedding_policy.py"
        }
      },
      {
        "step": 2,
        "adapter": "analyzer_one",
        "adapter_class": "AnalyzerOneAdapter",
        "method": "extract_performance_indicators",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "performance_indicators"
        },
        "source_module": "Analyzer_one.py",
        "source_class": "AnalyzerOneAdapter",
        "source_method": "extract_performance_indicators",
        "purpose": "Extract performance indicators",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "Analyzer_one.py"
        }
      },
      {
        "step": 3,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "score_evidence_strength",
        "args": [
          {
            "name": "evidence",
            "type": "List[Dict]",
            "source": "monitoring_evidence"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "evidence_scores"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "score_evidence_strength",
        "purpose": "Score strength of monitoring evidence",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "evidence",
              "type": "List[Dict]",
              "source": "collected_evidence"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 4,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_calculate_global_semantic_coherence",
        "args": [],
        "returns": {
          "type": "float",
          "binding": "monitoring_coherence"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_calculate_global_semantic_coherence",
        "purpose": "Calculate coherence of monitoring framework",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [],
          "return_type": "float",
          "source_file": "contradiction_deteccion.py"
        }
      }
    ],
    "contributing_modules": [
      "Analyzer_one.py",
      "contradiction_deteccion.py",
      "emebedding_policy.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "embedding_policy",
    "evidence_types": [
      "evidence_scores",
      "monitoring_coherence",
      "monitoring_indicators",
      "performance_indicators"
    ],
    "aggregation_strategy": "monitoring_assessment",
    "confidence_threshold": 0.77,
    "total_steps": 4
  },
  "P2-D2-Q5": {
    "question_id": "P2-D2-Q5",
    "point": "P2",
    "dimension": "D2",
    "question_number": 5,
    "question_text": "Evaluate process monitoring and control mechanisms",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "extract_monitoring_indicators",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "monitoring_indicators"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "extract_monitoring_indicators",
        "purpose": "Extract process monitoring indicators",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "emebedding_policy.py"
        }
      },
      {
        "step": 2,
        "adapter": "analyzer_one",
        "adapter_class": "AnalyzerOneAdapter",
        "method": "extract_performance_indicators",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "performance_indicators"
        },
        "source_module": "Analyzer_one.py",
        "source_class": "AnalyzerOneAdapter",
        "source_method": "extract_performance_indicators",
        "purpose": "Extract performance indicators",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "Analyzer_one.py"
        }
      },
      {
        "step": 3,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "score_evidence_strength",
        "args": [
          {
            "name": "evidence",
            "type": "List[Dict]",
            "source": "monitoring_evidence"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "evidence_scores"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "score_evidence_strength",
        "purpose": "Score strength of monitoring evidence",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "evidence",
              "type": "List[Dict]",
              "source": "collected_evidence"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 4,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_calculate_global_semantic_coherence",
        "args": [],
        "returns": {
          "type": "float",
          "binding": "monitoring_coherence"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_calculate_global_semantic_coherence",
        "purpose": "Calculate coherence of monitoring framework",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [],
          "return_type": "float",
          "source_file": "contradiction_deteccion.py"
        }
      }
    ],
    "contributing_modules": [
      "Analyzer_one.py",
      "contradiction_deteccion.py",
      "emebedding_policy.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "embedding_policy",
    "evidence_types": [
      "evidence_scores",
      "monitoring_coherence",
      "monitoring_indicators",
      "performance_indicators"
    ],
    "aggregation_strategy": "monitoring_assessment",
    "confidence_threshold": 0.77,
    "total_steps": 4
  },
  "P3-D2-Q5": {
    "question_id": "P3-D2-Q5",
    "point": "P3",
    "dimension": "D2",
    "question_number": 5,
    "question_text": "Evaluate process monitoring and control mechanisms",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "extract_monitoring_indicators",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "monitoring_indicators"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "extract_monitoring_indicators",
        "purpose": "Extract process monitoring indicators",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "emebedding_policy.py"
        }
      },
      {
        "step": 2,
        "adapter": "analyzer_one",
        "adapter_class": "AnalyzerOneAdapter",
        "method": "extract_performance_indicators",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "performance_indicators"
        },
        "source_module": "Analyzer_one.py",
        "source_class": "AnalyzerOneAdapter",
        "source_method": "extract_performance_indicators",
        "purpose": "Extract performance indicators",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "Analyzer_one.py"
        }
      },
      {
        "step": 3,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "score_evidence_strength",
        "args": [
          {
            "name": "evidence",
            "type": "List[Dict]",
            "source": "monitoring_evidence"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "evidence_scores"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "score_evidence_strength",
        "purpose": "Score strength of monitoring evidence",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "evidence",
              "type": "List[Dict]",
              "source": "collected_evidence"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 4,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_calculate_global_semantic_coherence",
        "args": [],
        "returns": {
          "type": "float",
          "binding": "monitoring_coherence"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_calculate_global_semantic_coherence",
        "purpose": "Calculate coherence of monitoring framework",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [],
          "return_type": "float",
          "source_file": "contradiction_deteccion.py"
        }
      }
    ],
    "contributing_modules": [
      "Analyzer_one.py",
      "contradiction_deteccion.py",
      "emebedding_policy.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "embedding_policy",
    "evidence_types": [
      "evidence_scores",
      "monitoring_coherence",
      "monitoring_indicators",
      "performance_indicators"
    ],
    "aggregation_strategy": "monitoring_assessment",
    "confidence_threshold": 0.77,
    "total_steps": 4
  },
  "P4-D2-Q5": {
    "question_id": "P4-D2-Q5",
    "point": "P4",
    "dimension": "D2",
    "question_number": 5,
    "question_text": "Evaluate process monitoring and control mechanisms",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "extract_monitoring_indicators",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "monitoring_indicators"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "extract_monitoring_indicators",
        "purpose": "Extract process monitoring indicators",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "emebedding_policy.py"
        }
      },
      {
        "step": 2,
        "adapter": "analyzer_one",
        "adapter_class": "AnalyzerOneAdapter",
        "method": "extract_performance_indicators",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "performance_indicators"
        },
        "source_module": "Analyzer_one.py",
        "source_class": "AnalyzerOneAdapter",
        "source_method": "extract_performance_indicators",
        "purpose": "Extract performance indicators",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "Analyzer_one.py"
        }
      },
      {
        "step": 3,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "score_evidence_strength",
        "args": [
          {
            "name": "evidence",
            "type": "List[Dict]",
            "source": "monitoring_evidence"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "evidence_scores"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "score_evidence_strength",
        "purpose": "Score strength of monitoring evidence",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "evidence",
              "type": "List[Dict]",
              "source": "collected_evidence"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 4,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_calculate_global_semantic_coherence",
        "args": [],
        "returns": {
          "type": "float",
          "binding": "monitoring_coherence"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_calculate_global_semantic_coherence",
        "purpose": "Calculate coherence of monitoring framework",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [],
          "return_type": "float",
          "source_file": "contradiction_deteccion.py"
        }
      }
    ],
    "contributing_modules": [
      "Analyzer_one.py",
      "contradiction_deteccion.py",
      "emebedding_policy.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "embedding_policy",
    "evidence_types": [
      "evidence_scores",
      "monitoring_coherence",
      "monitoring_indicators",
      "performance_indicators"
    ],
    "aggregation_strategy": "monitoring_assessment",
    "confidence_threshold": 0.77,
    "total_steps": 4
  },
  "P5-D2-Q5": {
    "question_id": "P5-D2-Q5",
    "point": "P5",
    "dimension": "D2",
    "question_number": 5,
    "question_text": "Evaluate process monitoring and control mechanisms",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "extract_monitoring_indicators",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "monitoring_indicators"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "extract_monitoring_indicators",
        "purpose": "Extract process monitoring indicators",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "emebedding_policy.py"
        }
      },
      {
        "step": 2,
        "adapter": "analyzer_one",
        "adapter_class": "AnalyzerOneAdapter",
        "method": "extract_performance_indicators",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "performance_indicators"
        },
        "source_module": "Analyzer_one.py",
        "source_class": "AnalyzerOneAdapter",
        "source_method": "extract_performance_indicators",
        "purpose": "Extract performance indicators",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "Analyzer_one.py"
        }
      },
      {
        "step": 3,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "score_evidence_strength",
        "args": [
          {
            "name": "evidence",
            "type": "List[Dict]",
            "source": "monitoring_evidence"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "evidence_scores"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "score_evidence_strength",
        "purpose": "Score strength of monitoring evidence",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "evidence",
              "type": "List[Dict]",
              "source": "collected_evidence"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 4,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_calculate_global_semantic_coherence",
        "args": [],
        "returns": {
          "type": "float",
          "binding": "monitoring_coherence"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_calculate_global_semantic_coherence",
        "purpose": "Calculate coherence of monitoring framework",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [],
          "return_type": "float",
          "source_file": "contradiction_deteccion.py"
        }
      }
    ],
    "contributing_modules": [
      "Analyzer_one.py",
      "contradiction_deteccion.py",
      "emebedding_policy.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "embedding_policy",
    "evidence_types": [
      "evidence_scores",
      "monitoring_coherence",
      "monitoring_indicators",
      "performance_indicators"
    ],
    "aggregation_strategy": "monitoring_assessment",
    "confidence_threshold": 0.77,
    "total_steps": 4
  },
  "P6-D2-Q5": {
    "question_id": "P6-D2-Q5",
    "point": "P6",
    "dimension": "D2",
    "question_number": 5,
    "question_text": "Evaluate process monitoring and control mechanisms",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "extract_monitoring_indicators",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "monitoring_indicators"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "extract_monitoring_indicators",
        "purpose": "Extract process monitoring indicators",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "emebedding_policy.py"
        }
      },
      {
        "step": 2,
        "adapter": "analyzer_one",
        "adapter_class": "AnalyzerOneAdapter",
        "method": "extract_performance_indicators",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "performance_indicators"
        },
        "source_module": "Analyzer_one.py",
        "source_class": "AnalyzerOneAdapter",
        "source_method": "extract_performance_indicators",
        "purpose": "Extract performance indicators",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "Analyzer_one.py"
        }
      },
      {
        "step": 3,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "score_evidence_strength",
        "args": [
          {
            "name": "evidence",
            "type": "List[Dict]",
            "source": "monitoring_evidence"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "evidence_scores"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "score_evidence_strength",
        "purpose": "Score strength of monitoring evidence",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "evidence",
              "type": "List[Dict]",
              "source": "collected_evidence"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 4,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_calculate_global_semantic_coherence",
        "args": [],
        "returns": {
          "type": "float",
          "binding": "monitoring_coherence"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_calculate_global_semantic_coherence",
        "purpose": "Calculate coherence of monitoring framework",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [],
          "return_type": "float",
          "source_file": "contradiction_deteccion.py"
        }
      }
    ],
    "contributing_modules": [
      "Analyzer_one.py",
      "contradiction_deteccion.py",
      "emebedding_policy.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "embedding_policy",
    "evidence_types": [
      "evidence_scores",
      "monitoring_coherence",
      "monitoring_indicators",
      "performance_indicators"
    ],
    "aggregation_strategy": "monitoring_assessment",
    "confidence_threshold": 0.77,
    "total_steps": 4
  },
  "P7-D2-Q5": {
    "question_id": "P7-D2-Q5",
    "point": "P7",
    "dimension": "D2",
    "question_number": 5,
    "question_text": "Evaluate process monitoring and control mechanisms",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "extract_monitoring_indicators",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "monitoring_indicators"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "extract_monitoring_indicators",
        "purpose": "Extract process monitoring indicators",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "emebedding_policy.py"
        }
      },
      {
        "step": 2,
        "adapter": "analyzer_one",
        "adapter_class": "AnalyzerOneAdapter",
        "method": "extract_performance_indicators",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "performance_indicators"
        },
        "source_module": "Analyzer_one.py",
        "source_class": "AnalyzerOneAdapter",
        "source_method": "extract_performance_indicators",
        "purpose": "Extract performance indicators",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "Analyzer_one.py"
        }
      },
      {
        "step": 3,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "score_evidence_strength",
        "args": [
          {
            "name": "evidence",
            "type": "List[Dict]",
            "source": "monitoring_evidence"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "evidence_scores"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "score_evidence_strength",
        "purpose": "Score strength of monitoring evidence",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "evidence",
              "type": "List[Dict]",
              "source": "collected_evidence"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 4,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_calculate_global_semantic_coherence",
        "args": [],
        "returns": {
          "type": "float",
          "binding": "monitoring_coherence"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_calculate_global_semantic_coherence",
        "purpose": "Calculate coherence of monitoring framework",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [],
          "return_type": "float",
          "source_file": "contradiction_deteccion.py"
        }
      }
    ],
    "contributing_modules": [
      "Analyzer_one.py",
      "contradiction_deteccion.py",
      "emebedding_policy.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "embedding_policy",
    "evidence_types": [
      "evidence_scores",
      "monitoring_coherence",
      "monitoring_indicators",
      "performance_indicators"
    ],
    "aggregation_strategy": "monitoring_assessment",
    "confidence_threshold": 0.77,
    "total_steps": 4
  },
  "P8-D2-Q5": {
    "question_id": "P8-D2-Q5",
    "point": "P8",
    "dimension": "D2",
    "question_number": 5,
    "question_text": "Evaluate process monitoring and control mechanisms",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "extract_monitoring_indicators",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "monitoring_indicators"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "extract_monitoring_indicators",
        "purpose": "Extract process monitoring indicators",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "emebedding_policy.py"
        }
      },
      {
        "step": 2,
        "adapter": "analyzer_one",
        "adapter_class": "AnalyzerOneAdapter",
        "method": "extract_performance_indicators",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "performance_indicators"
        },
        "source_module": "Analyzer_one.py",
        "source_class": "AnalyzerOneAdapter",
        "source_method": "extract_performance_indicators",
        "purpose": "Extract performance indicators",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "Analyzer_one.py"
        }
      },
      {
        "step": 3,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "score_evidence_strength",
        "args": [
          {
            "name": "evidence",
            "type": "List[Dict]",
            "source": "monitoring_evidence"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "evidence_scores"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "score_evidence_strength",
        "purpose": "Score strength of monitoring evidence",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "evidence",
              "type": "List[Dict]",
              "source": "collected_evidence"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 4,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_calculate_global_semantic_coherence",
        "args": [],
        "returns": {
          "type": "float",
          "binding": "monitoring_coherence"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_calculate_global_semantic_coherence",
        "purpose": "Calculate coherence of monitoring framework",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [],
          "return_type": "float",
          "source_file": "contradiction_deteccion.py"
        }
      }
    ],
    "contributing_modules": [
      "Analyzer_one.py",
      "contradiction_deteccion.py",
      "emebedding_policy.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "embedding_policy",
    "evidence_types": [
      "evidence_scores",
      "monitoring_coherence",
      "monitoring_indicators",
      "performance_indicators"
    ],
    "aggregation_strategy": "monitoring_assessment",
    "confidence_threshold": 0.77,
    "total_steps": 4
  },
  "P9-D2-Q5": {
    "question_id": "P9-D2-Q5",
    "point": "P9",
    "dimension": "D2",
    "question_number": 5,
    "question_text": "Evaluate process monitoring and control mechanisms",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "extract_monitoring_indicators",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "monitoring_indicators"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "extract_monitoring_indicators",
        "purpose": "Extract process monitoring indicators",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "emebedding_policy.py"
        }
      },
      {
        "step": 2,
        "adapter": "analyzer_one",
        "adapter_class": "AnalyzerOneAdapter",
        "method": "extract_performance_indicators",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "performance_indicators"
        },
        "source_module": "Analyzer_one.py",
        "source_class": "AnalyzerOneAdapter",
        "source_method": "extract_performance_indicators",
        "purpose": "Extract performance indicators",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "Analyzer_one.py"
        }
      },
      {
        "step": 3,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "score_evidence_strength",
        "args": [
          {
            "name": "evidence",
            "type": "List[Dict]",
            "source": "monitoring_evidence"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "evidence_scores"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "score_evidence_strength",
        "purpose": "Score strength of monitoring evidence",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "evidence",
              "type": "List[Dict]",
              "source": "collected_evidence"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 4,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_calculate_global_semantic_coherence",
        "args": [],
        "returns": {
          "type": "float",
          "binding": "monitoring_coherence"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_calculate_global_semantic_coherence",
        "purpose": "Calculate coherence of monitoring framework",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [],
          "return_type": "float",
          "source_file": "contradiction_deteccion.py"
        }
      }
    ],
    "contributing_modules": [
      "Analyzer_one.py",
      "contradiction_deteccion.py",
      "emebedding_policy.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "embedding_policy",
    "evidence_types": [
      "evidence_scores",
      "monitoring_coherence",
      "monitoring_indicators",
      "performance_indicators"
    ],
    "aggregation_strategy": "monitoring_assessment",
    "confidence_threshold": 0.77,
    "total_steps": 4
  },
  "P10-D2-Q5": {
    "question_id": "P10-D2-Q5",
    "point": "P10",
    "dimension": "D2",
    "question_number": 5,
    "question_text": "Evaluate process monitoring and control mechanisms",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "extract_monitoring_indicators",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "monitoring_indicators"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "extract_monitoring_indicators",
        "purpose": "Extract process monitoring indicators",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "emebedding_policy.py"
        }
      },
      {
        "step": 2,
        "adapter": "analyzer_one",
        "adapter_class": "AnalyzerOneAdapter",
        "method": "extract_performance_indicators",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "performance_indicators"
        },
        "source_module": "Analyzer_one.py",
        "source_class": "AnalyzerOneAdapter",
        "source_method": "extract_performance_indicators",
        "purpose": "Extract performance indicators",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "Analyzer_one.py"
        }
      },
      {
        "step": 3,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "score_evidence_strength",
        "args": [
          {
            "name": "evidence",
            "type": "List[Dict]",
            "source": "monitoring_evidence"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "evidence_scores"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "score_evidence_strength",
        "purpose": "Score strength of monitoring evidence",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "evidence",
              "type": "List[Dict]",
              "source": "collected_evidence"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 4,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_calculate_global_semantic_coherence",
        "args": [],
        "returns": {
          "type": "float",
          "binding": "monitoring_coherence"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_calculate_global_semantic_coherence",
        "purpose": "Calculate coherence of monitoring framework",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [],
          "return_type": "float",
          "source_file": "contradiction_deteccion.py"
        }
      }
    ],
    "contributing_modules": [
      "Analyzer_one.py",
      "contradiction_deteccion.py",
      "emebedding_policy.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "embedding_policy",
    "evidence_types": [
      "evidence_scores",
      "monitoring_coherence",
      "monitoring_indicators",
      "performance_indicators"
    ],
    "aggregation_strategy": "monitoring_assessment",
    "confidence_threshold": 0.77,
    "total_steps": 4
  },
  "P1-D3-Q1": {
    "question_id": "P1-D3-Q1",
    "point": "P1",
    "dimension": "D3",
    "question_number": 1,
    "question_text": "Identify and specify expected products",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "identify_pdm_products",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "identified_products"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "identify_pdm_products",
        "purpose": "Identify products using P-D-Q framework",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "emebedding_policy.py"
        }
      },
      {
        "step": 2,
        "adapter": "policy_processor",
        "adapter_class": "PolicyProcessorAdapter",
        "method": "_extract_point_evidence",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          },
          {
            "name": "point",
            "type": "Dict",
            "source": "product_point"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "product_evidence"
        },
        "source_module": "policy_processor.py",
        "source_class": "PolicyProcessorAdapter",
        "source_method": "_extract_point_evidence",
        "purpose": "Extract evidence for product specifications",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            },
            {
              "name": "point",
              "type": "Dict",
              "source": "product_point"
            }
          ],
          "return_type": "Dict",
          "source_file": "policy_processor.py"
        }
      },
      {
        "step": 3,
        "adapter": "semantic_chunking_policy",
        "adapter_class": "SemanticChunkingPolicyAdapter",
        "method": "extract_causal_strength",
        "args": [
          {
            "name": "chunk",
            "type": "Dict",
            "source": "product_chunk"
          }
        ],
        "returns": {
          "type": "float",
          "binding": "product_causal_strength"
        },
        "source_module": "semantic_chunking_policy.py",
        "source_class": "SemanticChunkingPolicyAdapter",
        "source_method": "extract_causal_strength",
        "purpose": "Extract causal strength indicators",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [
            {
              "name": "chunk",
              "type": "Dict",
              "source": "product_chunk"
            }
          ],
          "return_type": "float",
          "source_file": "semantic_chunking_policy.py"
        }
      },
      {
        "step": 4,
        "adapter": "analyzer_one",
        "adapter_class": "AnalyzerOneAdapter",
        "method": "validate_indicator_structure",
        "args": [
          {
            "name": "indicators",
            "type": "List[Dict]",
            "source": "product_indicators"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "indicator_validation"
        },
        "source_module": "Analyzer_one.py",
        "source_class": "AnalyzerOneAdapter",
        "source_method": "validate_indicator_structure",
        "purpose": "Validate product indicator structure",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "indicators",
              "type": "List[Dict]",
              "source": "product_indicators"
            }
          ],
          "return_type": "Dict",
          "source_file": "Analyzer_one.py"
        }
      }
    ],
    "contributing_modules": [
      "Analyzer_one.py",
      "emebedding_policy.py",
      "policy_processor.py",
      "semantic_chunking_policy.py"
    ],
    "primary_adapter": "embedding_policy",
    "evidence_types": [
      "identified_products",
      "indicator_validation",
      "product_causal_strength",
      "product_evidence"
    ],
    "aggregation_strategy": "product_identification",
    "confidence_threshold": 0.78,
    "total_steps": 4
  },
  "P2-D3-Q1": {
    "question_id": "P2-D3-Q1",
    "point": "P2",
    "dimension": "D3",
    "question_number": 1,
    "question_text": "Identify and specify expected products",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "identify_pdm_products",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "identified_products"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "identify_pdm_products",
        "purpose": "Identify products using P-D-Q framework",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "emebedding_policy.py"
        }
      },
      {
        "step": 2,
        "adapter": "policy_processor",
        "adapter_class": "PolicyProcessorAdapter",
        "method": "_extract_point_evidence",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          },
          {
            "name": "point",
            "type": "Dict",
            "source": "product_point"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "product_evidence"
        },
        "source_module": "policy_processor.py",
        "source_class": "PolicyProcessorAdapter",
        "source_method": "_extract_point_evidence",
        "purpose": "Extract evidence for product specifications",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            },
            {
              "name": "point",
              "type": "Dict",
              "source": "product_point"
            }
          ],
          "return_type": "Dict",
          "source_file": "policy_processor.py"
        }
      },
      {
        "step": 3,
        "adapter": "semantic_chunking_policy",
        "adapter_class": "SemanticChunkingPolicyAdapter",
        "method": "extract_causal_strength",
        "args": [
          {
            "name": "chunk",
            "type": "Dict",
            "source": "product_chunk"
          }
        ],
        "returns": {
          "type": "float",
          "binding": "product_causal_strength"
        },
        "source_module": "semantic_chunking_policy.py",
        "source_class": "SemanticChunkingPolicyAdapter",
        "source_method": "extract_causal_strength",
        "purpose": "Extract causal strength indicators",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [
            {
              "name": "chunk",
              "type": "Dict",
              "source": "product_chunk"
            }
          ],
          "return_type": "float",
          "source_file": "semantic_chunking_policy.py"
        }
      },
      {
        "step": 4,
        "adapter": "analyzer_one",
        "adapter_class": "AnalyzerOneAdapter",
        "method": "validate_indicator_structure",
        "args": [
          {
            "name": "indicators",
            "type": "List[Dict]",
            "source": "product_indicators"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "indicator_validation"
        },
        "source_module": "Analyzer_one.py",
        "source_class": "AnalyzerOneAdapter",
        "source_method": "validate_indicator_structure",
        "purpose": "Validate product indicator structure",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "indicators",
              "type": "List[Dict]",
              "source": "product_indicators"
            }
          ],
          "return_type": "Dict",
          "source_file": "Analyzer_one.py"
        }
      }
    ],
    "contributing_modules": [
      "Analyzer_one.py",
      "emebedding_policy.py",
      "policy_processor.py",
      "semantic_chunking_policy.py"
    ],
    "primary_adapter": "embedding_policy",
    "evidence_types": [
      "identified_products",
      "indicator_validation",
      "product_causal_strength",
      "product_evidence"
    ],
    "aggregation_strategy": "product_identification",
    "confidence_threshold": 0.78,
    "total_steps": 4
  },
  "P3-D3-Q1": {
    "question_id": "P3-D3-Q1",
    "point": "P3",
    "dimension": "D3",
    "question_number": 1,
    "question_text": "Identify and specify expected products",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "identify_pdm_products",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "identified_products"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "identify_pdm_products",
        "purpose": "Identify products using P-D-Q framework",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "emebedding_policy.py"
        }
      },
      {
        "step": 2,
        "adapter": "policy_processor",
        "adapter_class": "PolicyProcessorAdapter",
        "method": "_extract_point_evidence",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          },
          {
            "name": "point",
            "type": "Dict",
            "source": "product_point"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "product_evidence"
        },
        "source_module": "policy_processor.py",
        "source_class": "PolicyProcessorAdapter",
        "source_method": "_extract_point_evidence",
        "purpose": "Extract evidence for product specifications",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            },
            {
              "name": "point",
              "type": "Dict",
              "source": "product_point"
            }
          ],
          "return_type": "Dict",
          "source_file": "policy_processor.py"
        }
      },
      {
        "step": 3,
        "adapter": "semantic_chunking_policy",
        "adapter_class": "SemanticChunkingPolicyAdapter",
        "method": "extract_causal_strength",
        "args": [
          {
            "name": "chunk",
            "type": "Dict",
            "source": "product_chunk"
          }
        ],
        "returns": {
          "type": "float",
          "binding": "product_causal_strength"
        },
        "source_module": "semantic_chunking_policy.py",
        "source_class": "SemanticChunkingPolicyAdapter",
        "source_method": "extract_causal_strength",
        "purpose": "Extract causal strength indicators",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [
            {
              "name": "chunk",
              "type": "Dict",
              "source": "product_chunk"
            }
          ],
          "return_type": "float",
          "source_file": "semantic_chunking_policy.py"
        }
      },
      {
        "step": 4,
        "adapter": "analyzer_one",
        "adapter_class": "AnalyzerOneAdapter",
        "method": "validate_indicator_structure",
        "args": [
          {
            "name": "indicators",
            "type": "List[Dict]",
            "source": "product_indicators"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "indicator_validation"
        },
        "source_module": "Analyzer_one.py",
        "source_class": "AnalyzerOneAdapter",
        "source_method": "validate_indicator_structure",
        "purpose": "Validate product indicator structure",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "indicators",
              "type": "List[Dict]",
              "source": "product_indicators"
            }
          ],
          "return_type": "Dict",
          "source_file": "Analyzer_one.py"
        }
      }
    ],
    "contributing_modules": [
      "Analyzer_one.py",
      "emebedding_policy.py",
      "policy_processor.py",
      "semantic_chunking_policy.py"
    ],
    "primary_adapter": "embedding_policy",
    "evidence_types": [
      "identified_products",
      "indicator_validation",
      "product_causal_strength",
      "product_evidence"
    ],
    "aggregation_strategy": "product_identification",
    "confidence_threshold": 0.78,
    "total_steps": 4
  },
  "P4-D3-Q1": {
    "question_id": "P4-D3-Q1",
    "point": "P4",
    "dimension": "D3",
    "question_number": 1,
    "question_text": "Identify and specify expected products",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "identify_pdm_products",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "identified_products"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "identify_pdm_products",
        "purpose": "Identify products using P-D-Q framework",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "emebedding_policy.py"
        }
      },
      {
        "step": 2,
        "adapter": "policy_processor",
        "adapter_class": "PolicyProcessorAdapter",
        "method": "_extract_point_evidence",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          },
          {
            "name": "point",
            "type": "Dict",
            "source": "product_point"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "product_evidence"
        },
        "source_module": "policy_processor.py",
        "source_class": "PolicyProcessorAdapter",
        "source_method": "_extract_point_evidence",
        "purpose": "Extract evidence for product specifications",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            },
            {
              "name": "point",
              "type": "Dict",
              "source": "product_point"
            }
          ],
          "return_type": "Dict",
          "source_file": "policy_processor.py"
        }
      },
      {
        "step": 3,
        "adapter": "semantic_chunking_policy",
        "adapter_class": "SemanticChunkingPolicyAdapter",
        "method": "extract_causal_strength",
        "args": [
          {
            "name": "chunk",
            "type": "Dict",
            "source": "product_chunk"
          }
        ],
        "returns": {
          "type": "float",
          "binding": "product_causal_strength"
        },
        "source_module": "semantic_chunking_policy.py",
        "source_class": "SemanticChunkingPolicyAdapter",
        "source_method": "extract_causal_strength",
        "purpose": "Extract causal strength indicators",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [
            {
              "name": "chunk",
              "type": "Dict",
              "source": "product_chunk"
            }
          ],
          "return_type": "float",
          "source_file": "semantic_chunking_policy.py"
        }
      },
      {
        "step": 4,
        "adapter": "analyzer_one",
        "adapter_class": "AnalyzerOneAdapter",
        "method": "validate_indicator_structure",
        "args": [
          {
            "name": "indicators",
            "type": "List[Dict]",
            "source": "product_indicators"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "indicator_validation"
        },
        "source_module": "Analyzer_one.py",
        "source_class": "AnalyzerOneAdapter",
        "source_method": "validate_indicator_structure",
        "purpose": "Validate product indicator structure",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "indicators",
              "type": "List[Dict]",
              "source": "product_indicators"
            }
          ],
          "return_type": "Dict",
          "source_file": "Analyzer_one.py"
        }
      }
    ],
    "contributing_modules": [
      "Analyzer_one.py",
      "emebedding_policy.py",
      "policy_processor.py",
      "semantic_chunking_policy.py"
    ],
    "primary_adapter": "embedding_policy",
    "evidence_types": [
      "identified_products",
      "indicator_validation",
      "product_causal_strength",
      "product_evidence"
    ],
    "aggregation_strategy": "product_identification",
    "confidence_threshold": 0.78,
    "total_steps": 4
  },
  "P5-D3-Q1": {
    "question_id": "P5-D3-Q1",
    "point": "P5",
    "dimension": "D3",
    "question_number": 1,
    "question_text": "Identify and specify expected products",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "identify_pdm_products",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "identified_products"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "identify_pdm_products",
        "purpose": "Identify products using P-D-Q framework",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "emebedding_policy.py"
        }
      },
      {
        "step": 2,
        "adapter": "policy_processor",
        "adapter_class": "PolicyProcessorAdapter",
        "method": "_extract_point_evidence",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          },
          {
            "name": "point",
            "type": "Dict",
            "source": "product_point"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "product_evidence"
        },
        "source_module": "policy_processor.py",
        "source_class": "PolicyProcessorAdapter",
        "source_method": "_extract_point_evidence",
        "purpose": "Extract evidence for product specifications",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            },
            {
              "name": "point",
              "type": "Dict",
              "source": "product_point"
            }
          ],
          "return_type": "Dict",
          "source_file": "policy_processor.py"
        }
      },
      {
        "step": 3,
        "adapter": "semantic_chunking_policy",
        "adapter_class": "SemanticChunkingPolicyAdapter",
        "method": "extract_causal_strength",
        "args": [
          {
            "name": "chunk",
            "type": "Dict",
            "source": "product_chunk"
          }
        ],
        "returns": {
          "type": "float",
          "binding": "product_causal_strength"
        },
        "source_module": "semantic_chunking_policy.py",
        "source_class": "SemanticChunkingPolicyAdapter",
        "source_method": "extract_causal_strength",
        "purpose": "Extract causal strength indicators",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [
            {
              "name": "chunk",
              "type": "Dict",
              "source": "product_chunk"
            }
          ],
          "return_type": "float",
          "source_file": "semantic_chunking_policy.py"
        }
      },
      {
        "step": 4,
        "adapter": "analyzer_one",
        "adapter_class": "AnalyzerOneAdapter",
        "method": "validate_indicator_structure",
        "args": [
          {
            "name": "indicators",
            "type": "List[Dict]",
            "source": "product_indicators"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "indicator_validation"
        },
        "source_module": "Analyzer_one.py",
        "source_class": "AnalyzerOneAdapter",
        "source_method": "validate_indicator_structure",
        "purpose": "Validate product indicator structure",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "indicators",
              "type": "List[Dict]",
              "source": "product_indicators"
            }
          ],
          "return_type": "Dict",
          "source_file": "Analyzer_one.py"
        }
      }
    ],
    "contributing_modules": [
      "Analyzer_one.py",
      "emebedding_policy.py",
      "policy_processor.py",
      "semantic_chunking_policy.py"
    ],
    "primary_adapter": "embedding_policy",
    "evidence_types": [
      "identified_products",
      "indicator_validation",
      "product_causal_strength",
      "product_evidence"
    ],
    "aggregation_strategy": "product_identification",
    "confidence_threshold": 0.78,
    "total_steps": 4
  },
  "P6-D3-Q1": {
    "question_id": "P6-D3-Q1",
    "point": "P6",
    "dimension": "D3",
    "question_number": 1,
    "question_text": "Identify and specify expected products",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "identify_pdm_products",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "identified_products"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "identify_pdm_products",
        "purpose": "Identify products using P-D-Q framework",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "emebedding_policy.py"
        }
      },
      {
        "step": 2,
        "adapter": "policy_processor",
        "adapter_class": "PolicyProcessorAdapter",
        "method": "_extract_point_evidence",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          },
          {
            "name": "point",
            "type": "Dict",
            "source": "product_point"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "product_evidence"
        },
        "source_module": "policy_processor.py",
        "source_class": "PolicyProcessorAdapter",
        "source_method": "_extract_point_evidence",
        "purpose": "Extract evidence for product specifications",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            },
            {
              "name": "point",
              "type": "Dict",
              "source": "product_point"
            }
          ],
          "return_type": "Dict",
          "source_file": "policy_processor.py"
        }
      },
      {
        "step": 3,
        "adapter": "semantic_chunking_policy",
        "adapter_class": "SemanticChunkingPolicyAdapter",
        "method": "extract_causal_strength",
        "args": [
          {
            "name": "chunk",
            "type": "Dict",
            "source": "product_chunk"
          }
        ],
        "returns": {
          "type": "float",
          "binding": "product_causal_strength"
        },
        "source_module": "semantic_chunking_policy.py",
        "source_class": "SemanticChunkingPolicyAdapter",
        "source_method": "extract_causal_strength",
        "purpose": "Extract causal strength indicators",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [
            {
              "name": "chunk",
              "type": "Dict",
              "source": "product_chunk"
            }
          ],
          "return_type": "float",
          "source_file": "semantic_chunking_policy.py"
        }
      },
      {
        "step": 4,
        "adapter": "analyzer_one",
        "adapter_class": "AnalyzerOneAdapter",
        "method": "validate_indicator_structure",
        "args": [
          {
            "name": "indicators",
            "type": "List[Dict]",
            "source": "product_indicators"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "indicator_validation"
        },
        "source_module": "Analyzer_one.py",
        "source_class": "AnalyzerOneAdapter",
        "source_method": "validate_indicator_structure",
        "purpose": "Validate product indicator structure",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "indicators",
              "type": "List[Dict]",
              "source": "product_indicators"
            }
          ],
          "return_type": "Dict",
          "source_file": "Analyzer_one.py"
        }
      }
    ],
    "contributing_modules": [
      "Analyzer_one.py",
      "emebedding_policy.py",
      "policy_processor.py",
      "semantic_chunking_policy.py"
    ],
    "primary_adapter": "embedding_policy",
    "evidence_types": [
      "identified_products",
      "indicator_validation",
      "product_causal_strength",
      "product_evidence"
    ],
    "aggregation_strategy": "product_identification",
    "confidence_threshold": 0.78,
    "total_steps": 4
  },
  "P7-D3-Q1": {
    "question_id": "P7-D3-Q1",
    "point": "P7",
    "dimension": "D3",
    "question_number": 1,
    "question_text": "Identify and specify expected products",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "identify_pdm_products",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "identified_products"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "identify_pdm_products",
        "purpose": "Identify products using P-D-Q framework",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "emebedding_policy.py"
        }
      },
      {
        "step": 2,
        "adapter": "policy_processor",
        "adapter_class": "PolicyProcessorAdapter",
        "method": "_extract_point_evidence",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          },
          {
            "name": "point",
            "type": "Dict",
            "source": "product_point"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "product_evidence"
        },
        "source_module": "policy_processor.py",
        "source_class": "PolicyProcessorAdapter",
        "source_method": "_extract_point_evidence",
        "purpose": "Extract evidence for product specifications",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            },
            {
              "name": "point",
              "type": "Dict",
              "source": "product_point"
            }
          ],
          "return_type": "Dict",
          "source_file": "policy_processor.py"
        }
      },
      {
        "step": 3,
        "adapter": "semantic_chunking_policy",
        "adapter_class": "SemanticChunkingPolicyAdapter",
        "method": "extract_causal_strength",
        "args": [
          {
            "name": "chunk",
            "type": "Dict",
            "source": "product_chunk"
          }
        ],
        "returns": {
          "type": "float",
          "binding": "product_causal_strength"
        },
        "source_module": "semantic_chunking_policy.py",
        "source_class": "SemanticChunkingPolicyAdapter",
        "source_method": "extract_causal_strength",
        "purpose": "Extract causal strength indicators",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [
            {
              "name": "chunk",
              "type": "Dict",
              "source": "product_chunk"
            }
          ],
          "return_type": "float",
          "source_file": "semantic_chunking_policy.py"
        }
      },
      {
        "step": 4,
        "adapter": "analyzer_one",
        "adapter_class": "AnalyzerOneAdapter",
        "method": "validate_indicator_structure",
        "args": [
          {
            "name": "indicators",
            "type": "List[Dict]",
            "source": "product_indicators"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "indicator_validation"
        },
        "source_module": "Analyzer_one.py",
        "source_class": "AnalyzerOneAdapter",
        "source_method": "validate_indicator_structure",
        "purpose": "Validate product indicator structure",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "indicators",
              "type": "List[Dict]",
              "source": "product_indicators"
            }
          ],
          "return_type": "Dict",
          "source_file": "Analyzer_one.py"
        }
      }
    ],
    "contributing_modules": [
      "Analyzer_one.py",
      "emebedding_policy.py",
      "policy_processor.py",
      "semantic_chunking_policy.py"
    ],
    "primary_adapter": "embedding_policy",
    "evidence_types": [
      "identified_products",
      "indicator_validation",
      "product_causal_strength",
      "product_evidence"
    ],
    "aggregation_strategy": "product_identification",
    "confidence_threshold": 0.78,
    "total_steps": 4
  },
  "P8-D3-Q1": {
    "question_id": "P8-D3-Q1",
    "point": "P8",
    "dimension": "D3",
    "question_number": 1,
    "question_text": "Identify and specify expected products",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "identify_pdm_products",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "identified_products"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "identify_pdm_products",
        "purpose": "Identify products using P-D-Q framework",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "emebedding_policy.py"
        }
      },
      {
        "step": 2,
        "adapter": "policy_processor",
        "adapter_class": "PolicyProcessorAdapter",
        "method": "_extract_point_evidence",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          },
          {
            "name": "point",
            "type": "Dict",
            "source": "product_point"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "product_evidence"
        },
        "source_module": "policy_processor.py",
        "source_class": "PolicyProcessorAdapter",
        "source_method": "_extract_point_evidence",
        "purpose": "Extract evidence for product specifications",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            },
            {
              "name": "point",
              "type": "Dict",
              "source": "product_point"
            }
          ],
          "return_type": "Dict",
          "source_file": "policy_processor.py"
        }
      },
      {
        "step": 3,
        "adapter": "semantic_chunking_policy",
        "adapter_class": "SemanticChunkingPolicyAdapter",
        "method": "extract_causal_strength",
        "args": [
          {
            "name": "chunk",
            "type": "Dict",
            "source": "product_chunk"
          }
        ],
        "returns": {
          "type": "float",
          "binding": "product_causal_strength"
        },
        "source_module": "semantic_chunking_policy.py",
        "source_class": "SemanticChunkingPolicyAdapter",
        "source_method": "extract_causal_strength",
        "purpose": "Extract causal strength indicators",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [
            {
              "name": "chunk",
              "type": "Dict",
              "source": "product_chunk"
            }
          ],
          "return_type": "float",
          "source_file": "semantic_chunking_policy.py"
        }
      },
      {
        "step": 4,
        "adapter": "analyzer_one",
        "adapter_class": "AnalyzerOneAdapter",
        "method": "validate_indicator_structure",
        "args": [
          {
            "name": "indicators",
            "type": "List[Dict]",
            "source": "product_indicators"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "indicator_validation"
        },
        "source_module": "Analyzer_one.py",
        "source_class": "AnalyzerOneAdapter",
        "source_method": "validate_indicator_structure",
        "purpose": "Validate product indicator structure",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "indicators",
              "type": "List[Dict]",
              "source": "product_indicators"
            }
          ],
          "return_type": "Dict",
          "source_file": "Analyzer_one.py"
        }
      }
    ],
    "contributing_modules": [
      "Analyzer_one.py",
      "emebedding_policy.py",
      "policy_processor.py",
      "semantic_chunking_policy.py"
    ],
    "primary_adapter": "embedding_policy",
    "evidence_types": [
      "identified_products",
      "indicator_validation",
      "product_causal_strength",
      "product_evidence"
    ],
    "aggregation_strategy": "product_identification",
    "confidence_threshold": 0.78,
    "total_steps": 4
  },
  "P9-D3-Q1": {
    "question_id": "P9-D3-Q1",
    "point": "P9",
    "dimension": "D3",
    "question_number": 1,
    "question_text": "Identify and specify expected products",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "identify_pdm_products",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "identified_products"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "identify_pdm_products",
        "purpose": "Identify products using P-D-Q framework",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "emebedding_policy.py"
        }
      },
      {
        "step": 2,
        "adapter": "policy_processor",
        "adapter_class": "PolicyProcessorAdapter",
        "method": "_extract_point_evidence",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          },
          {
            "name": "point",
            "type": "Dict",
            "source": "product_point"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "product_evidence"
        },
        "source_module": "policy_processor.py",
        "source_class": "PolicyProcessorAdapter",
        "source_method": "_extract_point_evidence",
        "purpose": "Extract evidence for product specifications",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            },
            {
              "name": "point",
              "type": "Dict",
              "source": "product_point"
            }
          ],
          "return_type": "Dict",
          "source_file": "policy_processor.py"
        }
      },
      {
        "step": 3,
        "adapter": "semantic_chunking_policy",
        "adapter_class": "SemanticChunkingPolicyAdapter",
        "method": "extract_causal_strength",
        "args": [
          {
            "name": "chunk",
            "type": "Dict",
            "source": "product_chunk"
          }
        ],
        "returns": {
          "type": "float",
          "binding": "product_causal_strength"
        },
        "source_module": "semantic_chunking_policy.py",
        "source_class": "SemanticChunkingPolicyAdapter",
        "source_method": "extract_causal_strength",
        "purpose": "Extract causal strength indicators",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [
            {
              "name": "chunk",
              "type": "Dict",
              "source": "product_chunk"
            }
          ],
          "return_type": "float",
          "source_file": "semantic_chunking_policy.py"
        }
      },
      {
        "step": 4,
        "adapter": "analyzer_one",
        "adapter_class": "AnalyzerOneAdapter",
        "method": "validate_indicator_structure",
        "args": [
          {
            "name": "indicators",
            "type": "List[Dict]",
            "source": "product_indicators"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "indicator_validation"
        },
        "source_module": "Analyzer_one.py",
        "source_class": "AnalyzerOneAdapter",
        "source_method": "validate_indicator_structure",
        "purpose": "Validate product indicator structure",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "indicators",
              "type": "List[Dict]",
              "source": "product_indicators"
            }
          ],
          "return_type": "Dict",
          "source_file": "Analyzer_one.py"
        }
      }
    ],
    "contributing_modules": [
      "Analyzer_one.py",
      "emebedding_policy.py",
      "policy_processor.py",
      "semantic_chunking_policy.py"
    ],
    "primary_adapter": "embedding_policy",
    "evidence_types": [
      "identified_products",
      "indicator_validation",
      "product_causal_strength",
      "product_evidence"
    ],
    "aggregation_strategy": "product_identification",
    "confidence_threshold": 0.78,
    "total_steps": 4
  },
  "P10-D3-Q1": {
    "question_id": "P10-D3-Q1",
    "point": "P10",
    "dimension": "D3",
    "question_number": 1,
    "question_text": "Identify and specify expected products",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "identify_pdm_products",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "identified_products"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "identify_pdm_products",
        "purpose": "Identify products using P-D-Q framework",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "emebedding_policy.py"
        }
      },
      {
        "step": 2,
        "adapter": "policy_processor",
        "adapter_class": "PolicyProcessorAdapter",
        "method": "_extract_point_evidence",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          },
          {
            "name": "point",
            "type": "Dict",
            "source": "product_point"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "product_evidence"
        },
        "source_module": "policy_processor.py",
        "source_class": "PolicyProcessorAdapter",
        "source_method": "_extract_point_evidence",
        "purpose": "Extract evidence for product specifications",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            },
            {
              "name": "point",
              "type": "Dict",
              "source": "product_point"
            }
          ],
          "return_type": "Dict",
          "source_file": "policy_processor.py"
        }
      },
      {
        "step": 3,
        "adapter": "semantic_chunking_policy",
        "adapter_class": "SemanticChunkingPolicyAdapter",
        "method": "extract_causal_strength",
        "args": [
          {
            "name": "chunk",
            "type": "Dict",
            "source": "product_chunk"
          }
        ],
        "returns": {
          "type": "float",
          "binding": "product_causal_strength"
        },
        "source_module": "semantic_chunking_policy.py",
        "source_class": "SemanticChunkingPolicyAdapter",
        "source_method": "extract_causal_strength",
        "purpose": "Extract causal strength indicators",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [
            {
              "name": "chunk",
              "type": "Dict",
              "source": "product_chunk"
            }
          ],
          "return_type": "float",
          "source_file": "semantic_chunking_policy.py"
        }
      },
      {
        "step": 4,
        "adapter": "analyzer_one",
        "adapter_class": "AnalyzerOneAdapter",
        "method": "validate_indicator_structure",
        "args": [
          {
            "name": "indicators",
            "type": "List[Dict]",
            "source": "product_indicators"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "indicator_validation"
        },
        "source_module": "Analyzer_one.py",
        "source_class": "AnalyzerOneAdapter",
        "source_method": "validate_indicator_structure",
        "purpose": "Validate product indicator structure",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "indicators",
              "type": "List[Dict]",
              "source": "product_indicators"
            }
          ],
          "return_type": "Dict",
          "source_file": "Analyzer_one.py"
        }
      }
    ],
    "contributing_modules": [
      "Analyzer_one.py",
      "emebedding_policy.py",
      "policy_processor.py",
      "semantic_chunking_policy.py"
    ],
    "primary_adapter": "embedding_policy",
    "evidence_types": [
      "identified_products",
      "indicator_validation",
      "product_causal_strength",
      "product_evidence"
    ],
    "aggregation_strategy": "product_identification",
    "confidence_threshold": 0.78,
    "total_steps": 4
  },
  "P1-D3-Q2": {
    "question_id": "P1-D3-Q2",
    "point": "P1",
    "dimension": "D3",
    "question_number": 2,
    "question_text": "Validate linkages between processes and products",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "estimate_causal_effects",
        "args": [
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "source": "process_product_dag"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "causal_effects"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "estimate_causal_effects",
        "purpose": "Estimate causal effects from processes to products",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "graph",
              "type": "nx.DiGraph",
              "source": "complete_causal_dag"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 2,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "trace_causal_pathway",
        "args": [
          {
            "name": "from_node",
            "type": "str",
            "source": "process_node"
          },
          {
            "name": "to_node",
            "type": "str",
            "source": "product_node"
          },
          {
            "name": "dag",
            "type": "nx.DiGraph",
            "source": "causal_dag"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "pathway_trace"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "trace_causal_pathway",
        "purpose": "Trace pathway from process to product",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "from_node",
              "type": "str",
              "source": "evidence_source"
            },
            {
              "name": "to_node",
              "type": "str",
              "source": "evidence_target"
            },
            {
              "name": "dag",
              "type": "nx.DiGraph",
              "source": "evidence_dag"
            }
          ],
          "return_type": "Dict",
          "source_file": "dereck_beach.py"
        }
      },
      {
        "step": 3,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_detect_logical_incompatibilities",
        "args": [],
        "returns": {
          "type": "List[Dict]",
          "binding": "logical_conflicts"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_detect_logical_incompatibilities",
        "purpose": "Detect logical conflicts in linkages",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [],
          "return_type": "List[Dict]",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 4,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "calculate_semantic_similarity",
        "args": [
          {
            "name": "embedding1",
            "type": "np.ndarray",
            "source": "process_embedding"
          },
          {
            "name": "embedding2",
            "type": "np.ndarray",
            "source": "product_embedding"
          }
        ],
        "returns": {
          "type": "float",
          "binding": "semantic_linkage"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "calculate_semantic_similarity",
        "purpose": "Calculate semantic similarity between process and product",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "embedding1",
              "type": "np.ndarray",
              "source": "process_embedding"
            },
            {
              "name": "embedding2",
              "type": "np.ndarray",
              "source": "product_embedding"
            }
          ],
          "return_type": "float",
          "source_file": "emebedding_policy.py"
        }
      }
    ],
    "contributing_modules": [
      "contradiction_deteccion.py",
      "dereck_beach.py",
      "emebedding_policy.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "teoria_cambio",
    "evidence_types": [
      "causal_effects",
      "logical_conflicts",
      "pathway_trace",
      "semantic_linkage"
    ],
    "aggregation_strategy": "linkage_validation",
    "confidence_threshold": 0.8,
    "total_steps": 4
  },
  "P2-D3-Q2": {
    "question_id": "P2-D3-Q2",
    "point": "P2",
    "dimension": "D3",
    "question_number": 2,
    "question_text": "Validate linkages between processes and products",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "estimate_causal_effects",
        "args": [
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "source": "process_product_dag"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "causal_effects"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "estimate_causal_effects",
        "purpose": "Estimate causal effects from processes to products",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "graph",
              "type": "nx.DiGraph",
              "source": "complete_causal_dag"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 2,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "trace_causal_pathway",
        "args": [
          {
            "name": "from_node",
            "type": "str",
            "source": "process_node"
          },
          {
            "name": "to_node",
            "type": "str",
            "source": "product_node"
          },
          {
            "name": "dag",
            "type": "nx.DiGraph",
            "source": "causal_dag"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "pathway_trace"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "trace_causal_pathway",
        "purpose": "Trace pathway from process to product",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "from_node",
              "type": "str",
              "source": "evidence_source"
            },
            {
              "name": "to_node",
              "type": "str",
              "source": "evidence_target"
            },
            {
              "name": "dag",
              "type": "nx.DiGraph",
              "source": "evidence_dag"
            }
          ],
          "return_type": "Dict",
          "source_file": "dereck_beach.py"
        }
      },
      {
        "step": 3,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_detect_logical_incompatibilities",
        "args": [],
        "returns": {
          "type": "List[Dict]",
          "binding": "logical_conflicts"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_detect_logical_incompatibilities",
        "purpose": "Detect logical conflicts in linkages",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [],
          "return_type": "List[Dict]",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 4,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "calculate_semantic_similarity",
        "args": [
          {
            "name": "embedding1",
            "type": "np.ndarray",
            "source": "process_embedding"
          },
          {
            "name": "embedding2",
            "type": "np.ndarray",
            "source": "product_embedding"
          }
        ],
        "returns": {
          "type": "float",
          "binding": "semantic_linkage"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "calculate_semantic_similarity",
        "purpose": "Calculate semantic similarity between process and product",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "embedding1",
              "type": "np.ndarray",
              "source": "process_embedding"
            },
            {
              "name": "embedding2",
              "type": "np.ndarray",
              "source": "product_embedding"
            }
          ],
          "return_type": "float",
          "source_file": "emebedding_policy.py"
        }
      }
    ],
    "contributing_modules": [
      "contradiction_deteccion.py",
      "dereck_beach.py",
      "emebedding_policy.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "teoria_cambio",
    "evidence_types": [
      "causal_effects",
      "logical_conflicts",
      "pathway_trace",
      "semantic_linkage"
    ],
    "aggregation_strategy": "linkage_validation",
    "confidence_threshold": 0.8,
    "total_steps": 4
  },
  "P3-D3-Q2": {
    "question_id": "P3-D3-Q2",
    "point": "P3",
    "dimension": "D3",
    "question_number": 2,
    "question_text": "Validate linkages between processes and products",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "estimate_causal_effects",
        "args": [
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "source": "process_product_dag"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "causal_effects"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "estimate_causal_effects",
        "purpose": "Estimate causal effects from processes to products",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "graph",
              "type": "nx.DiGraph",
              "source": "complete_causal_dag"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 2,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "trace_causal_pathway",
        "args": [
          {
            "name": "from_node",
            "type": "str",
            "source": "process_node"
          },
          {
            "name": "to_node",
            "type": "str",
            "source": "product_node"
          },
          {
            "name": "dag",
            "type": "nx.DiGraph",
            "source": "causal_dag"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "pathway_trace"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "trace_causal_pathway",
        "purpose": "Trace pathway from process to product",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "from_node",
              "type": "str",
              "source": "evidence_source"
            },
            {
              "name": "to_node",
              "type": "str",
              "source": "evidence_target"
            },
            {
              "name": "dag",
              "type": "nx.DiGraph",
              "source": "evidence_dag"
            }
          ],
          "return_type": "Dict",
          "source_file": "dereck_beach.py"
        }
      },
      {
        "step": 3,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_detect_logical_incompatibilities",
        "args": [],
        "returns": {
          "type": "List[Dict]",
          "binding": "logical_conflicts"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_detect_logical_incompatibilities",
        "purpose": "Detect logical conflicts in linkages",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [],
          "return_type": "List[Dict]",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 4,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "calculate_semantic_similarity",
        "args": [
          {
            "name": "embedding1",
            "type": "np.ndarray",
            "source": "process_embedding"
          },
          {
            "name": "embedding2",
            "type": "np.ndarray",
            "source": "product_embedding"
          }
        ],
        "returns": {
          "type": "float",
          "binding": "semantic_linkage"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "calculate_semantic_similarity",
        "purpose": "Calculate semantic similarity between process and product",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "embedding1",
              "type": "np.ndarray",
              "source": "process_embedding"
            },
            {
              "name": "embedding2",
              "type": "np.ndarray",
              "source": "product_embedding"
            }
          ],
          "return_type": "float",
          "source_file": "emebedding_policy.py"
        }
      }
    ],
    "contributing_modules": [
      "contradiction_deteccion.py",
      "dereck_beach.py",
      "emebedding_policy.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "teoria_cambio",
    "evidence_types": [
      "causal_effects",
      "logical_conflicts",
      "pathway_trace",
      "semantic_linkage"
    ],
    "aggregation_strategy": "linkage_validation",
    "confidence_threshold": 0.8,
    "total_steps": 4
  },
  "P4-D3-Q2": {
    "question_id": "P4-D3-Q2",
    "point": "P4",
    "dimension": "D3",
    "question_number": 2,
    "question_text": "Validate linkages between processes and products",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "estimate_causal_effects",
        "args": [
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "source": "process_product_dag"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "causal_effects"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "estimate_causal_effects",
        "purpose": "Estimate causal effects from processes to products",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "graph",
              "type": "nx.DiGraph",
              "source": "complete_causal_dag"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 2,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "trace_causal_pathway",
        "args": [
          {
            "name": "from_node",
            "type": "str",
            "source": "process_node"
          },
          {
            "name": "to_node",
            "type": "str",
            "source": "product_node"
          },
          {
            "name": "dag",
            "type": "nx.DiGraph",
            "source": "causal_dag"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "pathway_trace"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "trace_causal_pathway",
        "purpose": "Trace pathway from process to product",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "from_node",
              "type": "str",
              "source": "evidence_source"
            },
            {
              "name": "to_node",
              "type": "str",
              "source": "evidence_target"
            },
            {
              "name": "dag",
              "type": "nx.DiGraph",
              "source": "evidence_dag"
            }
          ],
          "return_type": "Dict",
          "source_file": "dereck_beach.py"
        }
      },
      {
        "step": 3,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_detect_logical_incompatibilities",
        "args": [],
        "returns": {
          "type": "List[Dict]",
          "binding": "logical_conflicts"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_detect_logical_incompatibilities",
        "purpose": "Detect logical conflicts in linkages",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [],
          "return_type": "List[Dict]",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 4,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "calculate_semantic_similarity",
        "args": [
          {
            "name": "embedding1",
            "type": "np.ndarray",
            "source": "process_embedding"
          },
          {
            "name": "embedding2",
            "type": "np.ndarray",
            "source": "product_embedding"
          }
        ],
        "returns": {
          "type": "float",
          "binding": "semantic_linkage"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "calculate_semantic_similarity",
        "purpose": "Calculate semantic similarity between process and product",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "embedding1",
              "type": "np.ndarray",
              "source": "process_embedding"
            },
            {
              "name": "embedding2",
              "type": "np.ndarray",
              "source": "product_embedding"
            }
          ],
          "return_type": "float",
          "source_file": "emebedding_policy.py"
        }
      }
    ],
    "contributing_modules": [
      "contradiction_deteccion.py",
      "dereck_beach.py",
      "emebedding_policy.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "teoria_cambio",
    "evidence_types": [
      "causal_effects",
      "logical_conflicts",
      "pathway_trace",
      "semantic_linkage"
    ],
    "aggregation_strategy": "linkage_validation",
    "confidence_threshold": 0.8,
    "total_steps": 4
  },
  "P5-D3-Q2": {
    "question_id": "P5-D3-Q2",
    "point": "P5",
    "dimension": "D3",
    "question_number": 2,
    "question_text": "Validate linkages between processes and products",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "estimate_causal_effects",
        "args": [
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "source": "process_product_dag"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "causal_effects"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "estimate_causal_effects",
        "purpose": "Estimate causal effects from processes to products",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "graph",
              "type": "nx.DiGraph",
              "source": "complete_causal_dag"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 2,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "trace_causal_pathway",
        "args": [
          {
            "name": "from_node",
            "type": "str",
            "source": "process_node"
          },
          {
            "name": "to_node",
            "type": "str",
            "source": "product_node"
          },
          {
            "name": "dag",
            "type": "nx.DiGraph",
            "source": "causal_dag"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "pathway_trace"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "trace_causal_pathway",
        "purpose": "Trace pathway from process to product",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "from_node",
              "type": "str",
              "source": "evidence_source"
            },
            {
              "name": "to_node",
              "type": "str",
              "source": "evidence_target"
            },
            {
              "name": "dag",
              "type": "nx.DiGraph",
              "source": "evidence_dag"
            }
          ],
          "return_type": "Dict",
          "source_file": "dereck_beach.py"
        }
      },
      {
        "step": 3,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_detect_logical_incompatibilities",
        "args": [],
        "returns": {
          "type": "List[Dict]",
          "binding": "logical_conflicts"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_detect_logical_incompatibilities",
        "purpose": "Detect logical conflicts in linkages",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [],
          "return_type": "List[Dict]",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 4,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "calculate_semantic_similarity",
        "args": [
          {
            "name": "embedding1",
            "type": "np.ndarray",
            "source": "process_embedding"
          },
          {
            "name": "embedding2",
            "type": "np.ndarray",
            "source": "product_embedding"
          }
        ],
        "returns": {
          "type": "float",
          "binding": "semantic_linkage"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "calculate_semantic_similarity",
        "purpose": "Calculate semantic similarity between process and product",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "embedding1",
              "type": "np.ndarray",
              "source": "process_embedding"
            },
            {
              "name": "embedding2",
              "type": "np.ndarray",
              "source": "product_embedding"
            }
          ],
          "return_type": "float",
          "source_file": "emebedding_policy.py"
        }
      }
    ],
    "contributing_modules": [
      "contradiction_deteccion.py",
      "dereck_beach.py",
      "emebedding_policy.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "teoria_cambio",
    "evidence_types": [
      "causal_effects",
      "logical_conflicts",
      "pathway_trace",
      "semantic_linkage"
    ],
    "aggregation_strategy": "linkage_validation",
    "confidence_threshold": 0.8,
    "total_steps": 4
  },
  "P6-D3-Q2": {
    "question_id": "P6-D3-Q2",
    "point": "P6",
    "dimension": "D3",
    "question_number": 2,
    "question_text": "Validate linkages between processes and products",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "estimate_causal_effects",
        "args": [
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "source": "process_product_dag"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "causal_effects"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "estimate_causal_effects",
        "purpose": "Estimate causal effects from processes to products",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "graph",
              "type": "nx.DiGraph",
              "source": "complete_causal_dag"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 2,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "trace_causal_pathway",
        "args": [
          {
            "name": "from_node",
            "type": "str",
            "source": "process_node"
          },
          {
            "name": "to_node",
            "type": "str",
            "source": "product_node"
          },
          {
            "name": "dag",
            "type": "nx.DiGraph",
            "source": "causal_dag"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "pathway_trace"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "trace_causal_pathway",
        "purpose": "Trace pathway from process to product",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "from_node",
              "type": "str",
              "source": "evidence_source"
            },
            {
              "name": "to_node",
              "type": "str",
              "source": "evidence_target"
            },
            {
              "name": "dag",
              "type": "nx.DiGraph",
              "source": "evidence_dag"
            }
          ],
          "return_type": "Dict",
          "source_file": "dereck_beach.py"
        }
      },
      {
        "step": 3,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_detect_logical_incompatibilities",
        "args": [],
        "returns": {
          "type": "List[Dict]",
          "binding": "logical_conflicts"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_detect_logical_incompatibilities",
        "purpose": "Detect logical conflicts in linkages",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [],
          "return_type": "List[Dict]",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 4,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "calculate_semantic_similarity",
        "args": [
          {
            "name": "embedding1",
            "type": "np.ndarray",
            "source": "process_embedding"
          },
          {
            "name": "embedding2",
            "type": "np.ndarray",
            "source": "product_embedding"
          }
        ],
        "returns": {
          "type": "float",
          "binding": "semantic_linkage"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "calculate_semantic_similarity",
        "purpose": "Calculate semantic similarity between process and product",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "embedding1",
              "type": "np.ndarray",
              "source": "process_embedding"
            },
            {
              "name": "embedding2",
              "type": "np.ndarray",
              "source": "product_embedding"
            }
          ],
          "return_type": "float",
          "source_file": "emebedding_policy.py"
        }
      }
    ],
    "contributing_modules": [
      "contradiction_deteccion.py",
      "dereck_beach.py",
      "emebedding_policy.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "teoria_cambio",
    "evidence_types": [
      "causal_effects",
      "logical_conflicts",
      "pathway_trace",
      "semantic_linkage"
    ],
    "aggregation_strategy": "linkage_validation",
    "confidence_threshold": 0.8,
    "total_steps": 4
  },
  "P7-D3-Q2": {
    "question_id": "P7-D3-Q2",
    "point": "P7",
    "dimension": "D3",
    "question_number": 2,
    "question_text": "Validate linkages between processes and products",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "estimate_causal_effects",
        "args": [
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "source": "process_product_dag"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "causal_effects"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "estimate_causal_effects",
        "purpose": "Estimate causal effects from processes to products",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "graph",
              "type": "nx.DiGraph",
              "source": "complete_causal_dag"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 2,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "trace_causal_pathway",
        "args": [
          {
            "name": "from_node",
            "type": "str",
            "source": "process_node"
          },
          {
            "name": "to_node",
            "type": "str",
            "source": "product_node"
          },
          {
            "name": "dag",
            "type": "nx.DiGraph",
            "source": "causal_dag"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "pathway_trace"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "trace_causal_pathway",
        "purpose": "Trace pathway from process to product",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "from_node",
              "type": "str",
              "source": "evidence_source"
            },
            {
              "name": "to_node",
              "type": "str",
              "source": "evidence_target"
            },
            {
              "name": "dag",
              "type": "nx.DiGraph",
              "source": "evidence_dag"
            }
          ],
          "return_type": "Dict",
          "source_file": "dereck_beach.py"
        }
      },
      {
        "step": 3,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_detect_logical_incompatibilities",
        "args": [],
        "returns": {
          "type": "List[Dict]",
          "binding": "logical_conflicts"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_detect_logical_incompatibilities",
        "purpose": "Detect logical conflicts in linkages",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [],
          "return_type": "List[Dict]",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 4,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "calculate_semantic_similarity",
        "args": [
          {
            "name": "embedding1",
            "type": "np.ndarray",
            "source": "process_embedding"
          },
          {
            "name": "embedding2",
            "type": "np.ndarray",
            "source": "product_embedding"
          }
        ],
        "returns": {
          "type": "float",
          "binding": "semantic_linkage"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "calculate_semantic_similarity",
        "purpose": "Calculate semantic similarity between process and product",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "embedding1",
              "type": "np.ndarray",
              "source": "process_embedding"
            },
            {
              "name": "embedding2",
              "type": "np.ndarray",
              "source": "product_embedding"
            }
          ],
          "return_type": "float",
          "source_file": "emebedding_policy.py"
        }
      }
    ],
    "contributing_modules": [
      "contradiction_deteccion.py",
      "dereck_beach.py",
      "emebedding_policy.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "teoria_cambio",
    "evidence_types": [
      "causal_effects",
      "logical_conflicts",
      "pathway_trace",
      "semantic_linkage"
    ],
    "aggregation_strategy": "linkage_validation",
    "confidence_threshold": 0.8,
    "total_steps": 4
  },
  "P8-D3-Q2": {
    "question_id": "P8-D3-Q2",
    "point": "P8",
    "dimension": "D3",
    "question_number": 2,
    "question_text": "Validate linkages between processes and products",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "estimate_causal_effects",
        "args": [
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "source": "process_product_dag"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "causal_effects"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "estimate_causal_effects",
        "purpose": "Estimate causal effects from processes to products",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "graph",
              "type": "nx.DiGraph",
              "source": "complete_causal_dag"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 2,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "trace_causal_pathway",
        "args": [
          {
            "name": "from_node",
            "type": "str",
            "source": "process_node"
          },
          {
            "name": "to_node",
            "type": "str",
            "source": "product_node"
          },
          {
            "name": "dag",
            "type": "nx.DiGraph",
            "source": "causal_dag"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "pathway_trace"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "trace_causal_pathway",
        "purpose": "Trace pathway from process to product",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "from_node",
              "type": "str",
              "source": "evidence_source"
            },
            {
              "name": "to_node",
              "type": "str",
              "source": "evidence_target"
            },
            {
              "name": "dag",
              "type": "nx.DiGraph",
              "source": "evidence_dag"
            }
          ],
          "return_type": "Dict",
          "source_file": "dereck_beach.py"
        }
      },
      {
        "step": 3,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_detect_logical_incompatibilities",
        "args": [],
        "returns": {
          "type": "List[Dict]",
          "binding": "logical_conflicts"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_detect_logical_incompatibilities",
        "purpose": "Detect logical conflicts in linkages",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [],
          "return_type": "List[Dict]",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 4,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "calculate_semantic_similarity",
        "args": [
          {
            "name": "embedding1",
            "type": "np.ndarray",
            "source": "process_embedding"
          },
          {
            "name": "embedding2",
            "type": "np.ndarray",
            "source": "product_embedding"
          }
        ],
        "returns": {
          "type": "float",
          "binding": "semantic_linkage"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "calculate_semantic_similarity",
        "purpose": "Calculate semantic similarity between process and product",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "embedding1",
              "type": "np.ndarray",
              "source": "process_embedding"
            },
            {
              "name": "embedding2",
              "type": "np.ndarray",
              "source": "product_embedding"
            }
          ],
          "return_type": "float",
          "source_file": "emebedding_policy.py"
        }
      }
    ],
    "contributing_modules": [
      "contradiction_deteccion.py",
      "dereck_beach.py",
      "emebedding_policy.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "teoria_cambio",
    "evidence_types": [
      "causal_effects",
      "logical_conflicts",
      "pathway_trace",
      "semantic_linkage"
    ],
    "aggregation_strategy": "linkage_validation",
    "confidence_threshold": 0.8,
    "total_steps": 4
  },
  "P9-D3-Q2": {
    "question_id": "P9-D3-Q2",
    "point": "P9",
    "dimension": "D3",
    "question_number": 2,
    "question_text": "Validate linkages between processes and products",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "estimate_causal_effects",
        "args": [
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "source": "process_product_dag"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "causal_effects"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "estimate_causal_effects",
        "purpose": "Estimate causal effects from processes to products",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "graph",
              "type": "nx.DiGraph",
              "source": "complete_causal_dag"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 2,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "trace_causal_pathway",
        "args": [
          {
            "name": "from_node",
            "type": "str",
            "source": "process_node"
          },
          {
            "name": "to_node",
            "type": "str",
            "source": "product_node"
          },
          {
            "name": "dag",
            "type": "nx.DiGraph",
            "source": "causal_dag"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "pathway_trace"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "trace_causal_pathway",
        "purpose": "Trace pathway from process to product",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "from_node",
              "type": "str",
              "source": "evidence_source"
            },
            {
              "name": "to_node",
              "type": "str",
              "source": "evidence_target"
            },
            {
              "name": "dag",
              "type": "nx.DiGraph",
              "source": "evidence_dag"
            }
          ],
          "return_type": "Dict",
          "source_file": "dereck_beach.py"
        }
      },
      {
        "step": 3,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_detect_logical_incompatibilities",
        "args": [],
        "returns": {
          "type": "List[Dict]",
          "binding": "logical_conflicts"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_detect_logical_incompatibilities",
        "purpose": "Detect logical conflicts in linkages",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [],
          "return_type": "List[Dict]",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 4,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "calculate_semantic_similarity",
        "args": [
          {
            "name": "embedding1",
            "type": "np.ndarray",
            "source": "process_embedding"
          },
          {
            "name": "embedding2",
            "type": "np.ndarray",
            "source": "product_embedding"
          }
        ],
        "returns": {
          "type": "float",
          "binding": "semantic_linkage"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "calculate_semantic_similarity",
        "purpose": "Calculate semantic similarity between process and product",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "embedding1",
              "type": "np.ndarray",
              "source": "process_embedding"
            },
            {
              "name": "embedding2",
              "type": "np.ndarray",
              "source": "product_embedding"
            }
          ],
          "return_type": "float",
          "source_file": "emebedding_policy.py"
        }
      }
    ],
    "contributing_modules": [
      "contradiction_deteccion.py",
      "dereck_beach.py",
      "emebedding_policy.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "teoria_cambio",
    "evidence_types": [
      "causal_effects",
      "logical_conflicts",
      "pathway_trace",
      "semantic_linkage"
    ],
    "aggregation_strategy": "linkage_validation",
    "confidence_threshold": 0.8,
    "total_steps": 4
  },
  "P10-D3-Q2": {
    "question_id": "P10-D3-Q2",
    "point": "P10",
    "dimension": "D3",
    "question_number": 2,
    "question_text": "Validate linkages between processes and products",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "estimate_causal_effects",
        "args": [
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "source": "process_product_dag"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "causal_effects"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "estimate_causal_effects",
        "purpose": "Estimate causal effects from processes to products",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "graph",
              "type": "nx.DiGraph",
              "source": "complete_causal_dag"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 2,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "trace_causal_pathway",
        "args": [
          {
            "name": "from_node",
            "type": "str",
            "source": "process_node"
          },
          {
            "name": "to_node",
            "type": "str",
            "source": "product_node"
          },
          {
            "name": "dag",
            "type": "nx.DiGraph",
            "source": "causal_dag"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "pathway_trace"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "trace_causal_pathway",
        "purpose": "Trace pathway from process to product",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "from_node",
              "type": "str",
              "source": "evidence_source"
            },
            {
              "name": "to_node",
              "type": "str",
              "source": "evidence_target"
            },
            {
              "name": "dag",
              "type": "nx.DiGraph",
              "source": "evidence_dag"
            }
          ],
          "return_type": "Dict",
          "source_file": "dereck_beach.py"
        }
      },
      {
        "step": 3,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_detect_logical_incompatibilities",
        "args": [],
        "returns": {
          "type": "List[Dict]",
          "binding": "logical_conflicts"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_detect_logical_incompatibilities",
        "purpose": "Detect logical conflicts in linkages",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [],
          "return_type": "List[Dict]",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 4,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "calculate_semantic_similarity",
        "args": [
          {
            "name": "embedding1",
            "type": "np.ndarray",
            "source": "process_embedding"
          },
          {
            "name": "embedding2",
            "type": "np.ndarray",
            "source": "product_embedding"
          }
        ],
        "returns": {
          "type": "float",
          "binding": "semantic_linkage"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "calculate_semantic_similarity",
        "purpose": "Calculate semantic similarity between process and product",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "embedding1",
              "type": "np.ndarray",
              "source": "process_embedding"
            },
            {
              "name": "embedding2",
              "type": "np.ndarray",
              "source": "product_embedding"
            }
          ],
          "return_type": "float",
          "source_file": "emebedding_policy.py"
        }
      }
    ],
    "contributing_modules": [
      "contradiction_deteccion.py",
      "dereck_beach.py",
      "emebedding_policy.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "teoria_cambio",
    "evidence_types": [
      "causal_effects",
      "logical_conflicts",
      "pathway_trace",
      "semantic_linkage"
    ],
    "aggregation_strategy": "linkage_validation",
    "confidence_threshold": 0.8,
    "total_steps": 4
  },
  "P1-D4-Q1": {
    "question_id": "P1-D4-Q1",
    "point": "P1",
    "dimension": "D4",
    "question_number": 1,
    "question_text": "Identify and specify expected outcomes",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "identify_pdm_outcomes",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "identified_outcomes"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "identify_pdm_outcomes",
        "purpose": "Identify outcomes using P-D-Q notation",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "emebedding_policy.py"
        }
      },
      {
        "step": 2,
        "adapter": "analyzer_one",
        "adapter_class": "AnalyzerOneAdapter",
        "method": "analyze_outcome_indicators",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "outcome_analysis"
        },
        "source_module": "Analyzer_one.py",
        "source_class": "AnalyzerOneAdapter",
        "source_method": "analyze_outcome_indicators",
        "purpose": "Analyze outcome indicators",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "Dict",
          "source_file": "Analyzer_one.py"
        }
      },
      {
        "step": 3,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "generate_counterfactuals",
        "args": [
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "source": "outcome_dag"
          },
          {
            "name": "effects",
            "type": "List[Dict]",
            "source": "causal_effects"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "counterfactual_scenarios"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "generate_counterfactuals",
        "purpose": "Generate counterfactual outcome scenarios",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [
            {
              "name": "graph",
              "type": "nx.DiGraph",
              "source": "evidence_dag"
            },
            {
              "name": "effects",
              "type": "List[Dict]",
              "source": "causal_effects"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 4,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "identify_outcome_indicators",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "beach_outcome_indicators"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "identify_outcome_indicators",
        "purpose": "Identify outcome indicators using Beach framework",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "dereck_beach.py"
        }
      }
    ],
    "contributing_modules": [
      "Analyzer_one.py",
      "dereck_beach.py",
      "emebedding_policy.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "embedding_policy",
    "evidence_types": [
      "beach_outcome_indicators",
      "counterfactual_scenarios",
      "identified_outcomes",
      "outcome_analysis"
    ],
    "aggregation_strategy": "outcome_synthesis",
    "confidence_threshold": 0.78,
    "total_steps": 4
  },
  "P2-D4-Q1": {
    "question_id": "P2-D4-Q1",
    "point": "P2",
    "dimension": "D4",
    "question_number": 1,
    "question_text": "Identify and specify expected outcomes",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "identify_pdm_outcomes",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "identified_outcomes"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "identify_pdm_outcomes",
        "purpose": "Identify outcomes using P-D-Q notation",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "emebedding_policy.py"
        }
      },
      {
        "step": 2,
        "adapter": "analyzer_one",
        "adapter_class": "AnalyzerOneAdapter",
        "method": "analyze_outcome_indicators",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "outcome_analysis"
        },
        "source_module": "Analyzer_one.py",
        "source_class": "AnalyzerOneAdapter",
        "source_method": "analyze_outcome_indicators",
        "purpose": "Analyze outcome indicators",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "Dict",
          "source_file": "Analyzer_one.py"
        }
      },
      {
        "step": 3,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "generate_counterfactuals",
        "args": [
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "source": "outcome_dag"
          },
          {
            "name": "effects",
            "type": "List[Dict]",
            "source": "causal_effects"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "counterfactual_scenarios"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "generate_counterfactuals",
        "purpose": "Generate counterfactual outcome scenarios",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [
            {
              "name": "graph",
              "type": "nx.DiGraph",
              "source": "evidence_dag"
            },
            {
              "name": "effects",
              "type": "List[Dict]",
              "source": "causal_effects"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 4,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "identify_outcome_indicators",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "beach_outcome_indicators"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "identify_outcome_indicators",
        "purpose": "Identify outcome indicators using Beach framework",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "dereck_beach.py"
        }
      }
    ],
    "contributing_modules": [
      "Analyzer_one.py",
      "dereck_beach.py",
      "emebedding_policy.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "embedding_policy",
    "evidence_types": [
      "beach_outcome_indicators",
      "counterfactual_scenarios",
      "identified_outcomes",
      "outcome_analysis"
    ],
    "aggregation_strategy": "outcome_synthesis",
    "confidence_threshold": 0.78,
    "total_steps": 4
  },
  "P3-D4-Q1": {
    "question_id": "P3-D4-Q1",
    "point": "P3",
    "dimension": "D4",
    "question_number": 1,
    "question_text": "Identify and specify expected outcomes",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "identify_pdm_outcomes",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "identified_outcomes"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "identify_pdm_outcomes",
        "purpose": "Identify outcomes using P-D-Q notation",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "emebedding_policy.py"
        }
      },
      {
        "step": 2,
        "adapter": "analyzer_one",
        "adapter_class": "AnalyzerOneAdapter",
        "method": "analyze_outcome_indicators",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "outcome_analysis"
        },
        "source_module": "Analyzer_one.py",
        "source_class": "AnalyzerOneAdapter",
        "source_method": "analyze_outcome_indicators",
        "purpose": "Analyze outcome indicators",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "Dict",
          "source_file": "Analyzer_one.py"
        }
      },
      {
        "step": 3,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "generate_counterfactuals",
        "args": [
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "source": "outcome_dag"
          },
          {
            "name": "effects",
            "type": "List[Dict]",
            "source": "causal_effects"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "counterfactual_scenarios"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "generate_counterfactuals",
        "purpose": "Generate counterfactual outcome scenarios",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [
            {
              "name": "graph",
              "type": "nx.DiGraph",
              "source": "evidence_dag"
            },
            {
              "name": "effects",
              "type": "List[Dict]",
              "source": "causal_effects"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 4,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "identify_outcome_indicators",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "beach_outcome_indicators"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "identify_outcome_indicators",
        "purpose": "Identify outcome indicators using Beach framework",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "dereck_beach.py"
        }
      }
    ],
    "contributing_modules": [
      "Analyzer_one.py",
      "dereck_beach.py",
      "emebedding_policy.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "embedding_policy",
    "evidence_types": [
      "beach_outcome_indicators",
      "counterfactual_scenarios",
      "identified_outcomes",
      "outcome_analysis"
    ],
    "aggregation_strategy": "outcome_synthesis",
    "confidence_threshold": 0.78,
    "total_steps": 4
  },
  "P4-D4-Q1": {
    "question_id": "P4-D4-Q1",
    "point": "P4",
    "dimension": "D4",
    "question_number": 1,
    "question_text": "Identify and specify expected outcomes",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "identify_pdm_outcomes",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "identified_outcomes"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "identify_pdm_outcomes",
        "purpose": "Identify outcomes using P-D-Q notation",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "emebedding_policy.py"
        }
      },
      {
        "step": 2,
        "adapter": "analyzer_one",
        "adapter_class": "AnalyzerOneAdapter",
        "method": "analyze_outcome_indicators",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "outcome_analysis"
        },
        "source_module": "Analyzer_one.py",
        "source_class": "AnalyzerOneAdapter",
        "source_method": "analyze_outcome_indicators",
        "purpose": "Analyze outcome indicators",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "Dict",
          "source_file": "Analyzer_one.py"
        }
      },
      {
        "step": 3,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "generate_counterfactuals",
        "args": [
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "source": "outcome_dag"
          },
          {
            "name": "effects",
            "type": "List[Dict]",
            "source": "causal_effects"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "counterfactual_scenarios"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "generate_counterfactuals",
        "purpose": "Generate counterfactual outcome scenarios",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [
            {
              "name": "graph",
              "type": "nx.DiGraph",
              "source": "evidence_dag"
            },
            {
              "name": "effects",
              "type": "List[Dict]",
              "source": "causal_effects"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 4,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "identify_outcome_indicators",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "beach_outcome_indicators"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "identify_outcome_indicators",
        "purpose": "Identify outcome indicators using Beach framework",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "dereck_beach.py"
        }
      }
    ],
    "contributing_modules": [
      "Analyzer_one.py",
      "dereck_beach.py",
      "emebedding_policy.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "embedding_policy",
    "evidence_types": [
      "beach_outcome_indicators",
      "counterfactual_scenarios",
      "identified_outcomes",
      "outcome_analysis"
    ],
    "aggregation_strategy": "outcome_synthesis",
    "confidence_threshold": 0.78,
    "total_steps": 4
  },
  "P5-D4-Q1": {
    "question_id": "P5-D4-Q1",
    "point": "P5",
    "dimension": "D4",
    "question_number": 1,
    "question_text": "Identify and specify expected outcomes",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "identify_pdm_outcomes",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "identified_outcomes"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "identify_pdm_outcomes",
        "purpose": "Identify outcomes using P-D-Q notation",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "emebedding_policy.py"
        }
      },
      {
        "step": 2,
        "adapter": "analyzer_one",
        "adapter_class": "AnalyzerOneAdapter",
        "method": "analyze_outcome_indicators",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "outcome_analysis"
        },
        "source_module": "Analyzer_one.py",
        "source_class": "AnalyzerOneAdapter",
        "source_method": "analyze_outcome_indicators",
        "purpose": "Analyze outcome indicators",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "Dict",
          "source_file": "Analyzer_one.py"
        }
      },
      {
        "step": 3,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "generate_counterfactuals",
        "args": [
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "source": "outcome_dag"
          },
          {
            "name": "effects",
            "type": "List[Dict]",
            "source": "causal_effects"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "counterfactual_scenarios"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "generate_counterfactuals",
        "purpose": "Generate counterfactual outcome scenarios",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [
            {
              "name": "graph",
              "type": "nx.DiGraph",
              "source": "evidence_dag"
            },
            {
              "name": "effects",
              "type": "List[Dict]",
              "source": "causal_effects"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 4,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "identify_outcome_indicators",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "beach_outcome_indicators"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "identify_outcome_indicators",
        "purpose": "Identify outcome indicators using Beach framework",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "dereck_beach.py"
        }
      }
    ],
    "contributing_modules": [
      "Analyzer_one.py",
      "dereck_beach.py",
      "emebedding_policy.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "embedding_policy",
    "evidence_types": [
      "beach_outcome_indicators",
      "counterfactual_scenarios",
      "identified_outcomes",
      "outcome_analysis"
    ],
    "aggregation_strategy": "outcome_synthesis",
    "confidence_threshold": 0.78,
    "total_steps": 4
  },
  "P6-D4-Q1": {
    "question_id": "P6-D4-Q1",
    "point": "P6",
    "dimension": "D4",
    "question_number": 1,
    "question_text": "Identify and specify expected outcomes",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "identify_pdm_outcomes",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "identified_outcomes"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "identify_pdm_outcomes",
        "purpose": "Identify outcomes using P-D-Q notation",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "emebedding_policy.py"
        }
      },
      {
        "step": 2,
        "adapter": "analyzer_one",
        "adapter_class": "AnalyzerOneAdapter",
        "method": "analyze_outcome_indicators",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "outcome_analysis"
        },
        "source_module": "Analyzer_one.py",
        "source_class": "AnalyzerOneAdapter",
        "source_method": "analyze_outcome_indicators",
        "purpose": "Analyze outcome indicators",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "Dict",
          "source_file": "Analyzer_one.py"
        }
      },
      {
        "step": 3,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "generate_counterfactuals",
        "args": [
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "source": "outcome_dag"
          },
          {
            "name": "effects",
            "type": "List[Dict]",
            "source": "causal_effects"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "counterfactual_scenarios"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "generate_counterfactuals",
        "purpose": "Generate counterfactual outcome scenarios",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [
            {
              "name": "graph",
              "type": "nx.DiGraph",
              "source": "evidence_dag"
            },
            {
              "name": "effects",
              "type": "List[Dict]",
              "source": "causal_effects"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 4,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "identify_outcome_indicators",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "beach_outcome_indicators"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "identify_outcome_indicators",
        "purpose": "Identify outcome indicators using Beach framework",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "dereck_beach.py"
        }
      }
    ],
    "contributing_modules": [
      "Analyzer_one.py",
      "dereck_beach.py",
      "emebedding_policy.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "embedding_policy",
    "evidence_types": [
      "beach_outcome_indicators",
      "counterfactual_scenarios",
      "identified_outcomes",
      "outcome_analysis"
    ],
    "aggregation_strategy": "outcome_synthesis",
    "confidence_threshold": 0.78,
    "total_steps": 4
  },
  "P7-D4-Q1": {
    "question_id": "P7-D4-Q1",
    "point": "P7",
    "dimension": "D4",
    "question_number": 1,
    "question_text": "Identify and specify expected outcomes",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "identify_pdm_outcomes",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "identified_outcomes"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "identify_pdm_outcomes",
        "purpose": "Identify outcomes using P-D-Q notation",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "emebedding_policy.py"
        }
      },
      {
        "step": 2,
        "adapter": "analyzer_one",
        "adapter_class": "AnalyzerOneAdapter",
        "method": "analyze_outcome_indicators",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "outcome_analysis"
        },
        "source_module": "Analyzer_one.py",
        "source_class": "AnalyzerOneAdapter",
        "source_method": "analyze_outcome_indicators",
        "purpose": "Analyze outcome indicators",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "Dict",
          "source_file": "Analyzer_one.py"
        }
      },
      {
        "step": 3,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "generate_counterfactuals",
        "args": [
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "source": "outcome_dag"
          },
          {
            "name": "effects",
            "type": "List[Dict]",
            "source": "causal_effects"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "counterfactual_scenarios"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "generate_counterfactuals",
        "purpose": "Generate counterfactual outcome scenarios",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [
            {
              "name": "graph",
              "type": "nx.DiGraph",
              "source": "evidence_dag"
            },
            {
              "name": "effects",
              "type": "List[Dict]",
              "source": "causal_effects"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 4,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "identify_outcome_indicators",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "beach_outcome_indicators"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "identify_outcome_indicators",
        "purpose": "Identify outcome indicators using Beach framework",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "dereck_beach.py"
        }
      }
    ],
    "contributing_modules": [
      "Analyzer_one.py",
      "dereck_beach.py",
      "emebedding_policy.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "embedding_policy",
    "evidence_types": [
      "beach_outcome_indicators",
      "counterfactual_scenarios",
      "identified_outcomes",
      "outcome_analysis"
    ],
    "aggregation_strategy": "outcome_synthesis",
    "confidence_threshold": 0.78,
    "total_steps": 4
  },
  "P8-D4-Q1": {
    "question_id": "P8-D4-Q1",
    "point": "P8",
    "dimension": "D4",
    "question_number": 1,
    "question_text": "Identify and specify expected outcomes",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "identify_pdm_outcomes",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "identified_outcomes"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "identify_pdm_outcomes",
        "purpose": "Identify outcomes using P-D-Q notation",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "emebedding_policy.py"
        }
      },
      {
        "step": 2,
        "adapter": "analyzer_one",
        "adapter_class": "AnalyzerOneAdapter",
        "method": "analyze_outcome_indicators",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "outcome_analysis"
        },
        "source_module": "Analyzer_one.py",
        "source_class": "AnalyzerOneAdapter",
        "source_method": "analyze_outcome_indicators",
        "purpose": "Analyze outcome indicators",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "Dict",
          "source_file": "Analyzer_one.py"
        }
      },
      {
        "step": 3,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "generate_counterfactuals",
        "args": [
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "source": "outcome_dag"
          },
          {
            "name": "effects",
            "type": "List[Dict]",
            "source": "causal_effects"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "counterfactual_scenarios"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "generate_counterfactuals",
        "purpose": "Generate counterfactual outcome scenarios",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [
            {
              "name": "graph",
              "type": "nx.DiGraph",
              "source": "evidence_dag"
            },
            {
              "name": "effects",
              "type": "List[Dict]",
              "source": "causal_effects"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 4,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "identify_outcome_indicators",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "beach_outcome_indicators"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "identify_outcome_indicators",
        "purpose": "Identify outcome indicators using Beach framework",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "dereck_beach.py"
        }
      }
    ],
    "contributing_modules": [
      "Analyzer_one.py",
      "dereck_beach.py",
      "emebedding_policy.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "embedding_policy",
    "evidence_types": [
      "beach_outcome_indicators",
      "counterfactual_scenarios",
      "identified_outcomes",
      "outcome_analysis"
    ],
    "aggregation_strategy": "outcome_synthesis",
    "confidence_threshold": 0.78,
    "total_steps": 4
  },
  "P9-D4-Q1": {
    "question_id": "P9-D4-Q1",
    "point": "P9",
    "dimension": "D4",
    "question_number": 1,
    "question_text": "Identify and specify expected outcomes",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "identify_pdm_outcomes",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "identified_outcomes"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "identify_pdm_outcomes",
        "purpose": "Identify outcomes using P-D-Q notation",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "emebedding_policy.py"
        }
      },
      {
        "step": 2,
        "adapter": "analyzer_one",
        "adapter_class": "AnalyzerOneAdapter",
        "method": "analyze_outcome_indicators",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "outcome_analysis"
        },
        "source_module": "Analyzer_one.py",
        "source_class": "AnalyzerOneAdapter",
        "source_method": "analyze_outcome_indicators",
        "purpose": "Analyze outcome indicators",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "Dict",
          "source_file": "Analyzer_one.py"
        }
      },
      {
        "step": 3,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "generate_counterfactuals",
        "args": [
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "source": "outcome_dag"
          },
          {
            "name": "effects",
            "type": "List[Dict]",
            "source": "causal_effects"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "counterfactual_scenarios"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "generate_counterfactuals",
        "purpose": "Generate counterfactual outcome scenarios",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [
            {
              "name": "graph",
              "type": "nx.DiGraph",
              "source": "evidence_dag"
            },
            {
              "name": "effects",
              "type": "List[Dict]",
              "source": "causal_effects"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 4,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "identify_outcome_indicators",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "beach_outcome_indicators"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "identify_outcome_indicators",
        "purpose": "Identify outcome indicators using Beach framework",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "dereck_beach.py"
        }
      }
    ],
    "contributing_modules": [
      "Analyzer_one.py",
      "dereck_beach.py",
      "emebedding_policy.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "embedding_policy",
    "evidence_types": [
      "beach_outcome_indicators",
      "counterfactual_scenarios",
      "identified_outcomes",
      "outcome_analysis"
    ],
    "aggregation_strategy": "outcome_synthesis",
    "confidence_threshold": 0.78,
    "total_steps": 4
  },
  "P10-D4-Q1": {
    "question_id": "P10-D4-Q1",
    "point": "P10",
    "dimension": "D4",
    "question_number": 1,
    "question_text": "Identify and specify expected outcomes",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "identify_pdm_outcomes",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "identified_outcomes"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "identify_pdm_outcomes",
        "purpose": "Identify outcomes using P-D-Q notation",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "emebedding_policy.py"
        }
      },
      {
        "step": 2,
        "adapter": "analyzer_one",
        "adapter_class": "AnalyzerOneAdapter",
        "method": "analyze_outcome_indicators",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "outcome_analysis"
        },
        "source_module": "Analyzer_one.py",
        "source_class": "AnalyzerOneAdapter",
        "source_method": "analyze_outcome_indicators",
        "purpose": "Analyze outcome indicators",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "Dict",
          "source_file": "Analyzer_one.py"
        }
      },
      {
        "step": 3,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "generate_counterfactuals",
        "args": [
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "source": "outcome_dag"
          },
          {
            "name": "effects",
            "type": "List[Dict]",
            "source": "causal_effects"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "counterfactual_scenarios"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "generate_counterfactuals",
        "purpose": "Generate counterfactual outcome scenarios",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [
            {
              "name": "graph",
              "type": "nx.DiGraph",
              "source": "evidence_dag"
            },
            {
              "name": "effects",
              "type": "List[Dict]",
              "source": "causal_effects"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 4,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "identify_outcome_indicators",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "beach_outcome_indicators"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "identify_outcome_indicators",
        "purpose": "Identify outcome indicators using Beach framework",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "dereck_beach.py"
        }
      }
    ],
    "contributing_modules": [
      "Analyzer_one.py",
      "dereck_beach.py",
      "emebedding_policy.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "embedding_policy",
    "evidence_types": [
      "beach_outcome_indicators",
      "counterfactual_scenarios",
      "identified_outcomes",
      "outcome_analysis"
    ],
    "aggregation_strategy": "outcome_synthesis",
    "confidence_threshold": 0.78,
    "total_steps": 4
  },
  "P1-D4-Q2": {
    "question_id": "P1-D4-Q2",
    "point": "P1",
    "dimension": "D4",
    "question_number": 2,
    "question_text": "Assess outcome measurement framework",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "analyzer_one",
        "adapter_class": "AnalyzerOneAdapter",
        "method": "validate_measurement_framework",
        "args": [
          {
            "name": "indicators",
            "type": "List[Dict]",
            "source": "outcome_indicators"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "measurement_validation"
        },
        "source_module": "Analyzer_one.py",
        "source_class": "AnalyzerOneAdapter",
        "source_method": "validate_measurement_framework",
        "purpose": "Validate outcome measurement framework",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "indicators",
              "type": "List[Dict]",
              "source": "outcome_indicators"
            }
          ],
          "return_type": "Dict",
          "source_file": "Analyzer_one.py"
        }
      },
      {
        "step": 2,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "validate_numerical_consistency",
        "args": [
          {
            "name": "claims",
            "type": "List[Dict]",
            "source": "numerical_outcomes"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "numerical_validation"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "validate_numerical_consistency",
        "purpose": "Validate numerical consistency in outcomes",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "claims",
              "type": "List[Dict]",
              "source": "numerical_outcomes"
            }
          ],
          "return_type": "Dict",
          "source_file": "emebedding_policy.py"
        }
      },
      {
        "step": 3,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "calculate_bayesian_confidence",
        "args": [
          {
            "name": "priors",
            "type": "Dict",
            "source": "outcome_priors"
          },
          {
            "name": "evidence",
            "type": "List",
            "source": "measurement_evidence"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "measurement_confidence"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "calculate_bayesian_confidence",
        "purpose": "Calculate Bayesian confidence in measurements",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "priors",
              "type": "Dict",
              "source": "outcome_priors"
            },
            {
              "name": "evidence",
              "type": "List",
              "source": "measurement_evidence"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 4,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_calculate_confidence_interval",
        "args": [
          {
            "name": "contradictions",
            "type": "List",
            "source": "measurement_conflicts"
          }
        ],
        "returns": {
          "type": "Tuple",
          "binding": "confidence_interval"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_calculate_confidence_interval",
        "purpose": "Calculate confidence interval for measurements",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "contradictions",
              "type": "List",
              "source": "measurement_conflicts"
            }
          ],
          "return_type": "Tuple",
          "source_file": "contradiction_deteccion.py"
        }
      }
    ],
    "contributing_modules": [
      "Analyzer_one.py",
      "contradiction_deteccion.py",
      "emebedding_policy.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "analyzer_one",
    "evidence_types": [
      "confidence_interval",
      "measurement_confidence",
      "measurement_validation",
      "numerical_validation"
    ],
    "aggregation_strategy": "measurement_assessment",
    "confidence_threshold": 0.82,
    "total_steps": 4
  },
  "P2-D4-Q2": {
    "question_id": "P2-D4-Q2",
    "point": "P2",
    "dimension": "D4",
    "question_number": 2,
    "question_text": "Assess outcome measurement framework",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "analyzer_one",
        "adapter_class": "AnalyzerOneAdapter",
        "method": "validate_measurement_framework",
        "args": [
          {
            "name": "indicators",
            "type": "List[Dict]",
            "source": "outcome_indicators"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "measurement_validation"
        },
        "source_module": "Analyzer_one.py",
        "source_class": "AnalyzerOneAdapter",
        "source_method": "validate_measurement_framework",
        "purpose": "Validate outcome measurement framework",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "indicators",
              "type": "List[Dict]",
              "source": "outcome_indicators"
            }
          ],
          "return_type": "Dict",
          "source_file": "Analyzer_one.py"
        }
      },
      {
        "step": 2,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "validate_numerical_consistency",
        "args": [
          {
            "name": "claims",
            "type": "List[Dict]",
            "source": "numerical_outcomes"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "numerical_validation"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "validate_numerical_consistency",
        "purpose": "Validate numerical consistency in outcomes",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "claims",
              "type": "List[Dict]",
              "source": "numerical_outcomes"
            }
          ],
          "return_type": "Dict",
          "source_file": "emebedding_policy.py"
        }
      },
      {
        "step": 3,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "calculate_bayesian_confidence",
        "args": [
          {
            "name": "priors",
            "type": "Dict",
            "source": "outcome_priors"
          },
          {
            "name": "evidence",
            "type": "List",
            "source": "measurement_evidence"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "measurement_confidence"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "calculate_bayesian_confidence",
        "purpose": "Calculate Bayesian confidence in measurements",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "priors",
              "type": "Dict",
              "source": "outcome_priors"
            },
            {
              "name": "evidence",
              "type": "List",
              "source": "measurement_evidence"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 4,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_calculate_confidence_interval",
        "args": [
          {
            "name": "contradictions",
            "type": "List",
            "source": "measurement_conflicts"
          }
        ],
        "returns": {
          "type": "Tuple",
          "binding": "confidence_interval"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_calculate_confidence_interval",
        "purpose": "Calculate confidence interval for measurements",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "contradictions",
              "type": "List",
              "source": "measurement_conflicts"
            }
          ],
          "return_type": "Tuple",
          "source_file": "contradiction_deteccion.py"
        }
      }
    ],
    "contributing_modules": [
      "Analyzer_one.py",
      "contradiction_deteccion.py",
      "emebedding_policy.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "analyzer_one",
    "evidence_types": [
      "confidence_interval",
      "measurement_confidence",
      "measurement_validation",
      "numerical_validation"
    ],
    "aggregation_strategy": "measurement_assessment",
    "confidence_threshold": 0.82,
    "total_steps": 4
  },
  "P3-D4-Q2": {
    "question_id": "P3-D4-Q2",
    "point": "P3",
    "dimension": "D4",
    "question_number": 2,
    "question_text": "Assess outcome measurement framework",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "analyzer_one",
        "adapter_class": "AnalyzerOneAdapter",
        "method": "validate_measurement_framework",
        "args": [
          {
            "name": "indicators",
            "type": "List[Dict]",
            "source": "outcome_indicators"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "measurement_validation"
        },
        "source_module": "Analyzer_one.py",
        "source_class": "AnalyzerOneAdapter",
        "source_method": "validate_measurement_framework",
        "purpose": "Validate outcome measurement framework",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "indicators",
              "type": "List[Dict]",
              "source": "outcome_indicators"
            }
          ],
          "return_type": "Dict",
          "source_file": "Analyzer_one.py"
        }
      },
      {
        "step": 2,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "validate_numerical_consistency",
        "args": [
          {
            "name": "claims",
            "type": "List[Dict]",
            "source": "numerical_outcomes"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "numerical_validation"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "validate_numerical_consistency",
        "purpose": "Validate numerical consistency in outcomes",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "claims",
              "type": "List[Dict]",
              "source": "numerical_outcomes"
            }
          ],
          "return_type": "Dict",
          "source_file": "emebedding_policy.py"
        }
      },
      {
        "step": 3,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "calculate_bayesian_confidence",
        "args": [
          {
            "name": "priors",
            "type": "Dict",
            "source": "outcome_priors"
          },
          {
            "name": "evidence",
            "type": "List",
            "source": "measurement_evidence"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "measurement_confidence"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "calculate_bayesian_confidence",
        "purpose": "Calculate Bayesian confidence in measurements",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "priors",
              "type": "Dict",
              "source": "outcome_priors"
            },
            {
              "name": "evidence",
              "type": "List",
              "source": "measurement_evidence"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 4,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_calculate_confidence_interval",
        "args": [
          {
            "name": "contradictions",
            "type": "List",
            "source": "measurement_conflicts"
          }
        ],
        "returns": {
          "type": "Tuple",
          "binding": "confidence_interval"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_calculate_confidence_interval",
        "purpose": "Calculate confidence interval for measurements",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "contradictions",
              "type": "List",
              "source": "measurement_conflicts"
            }
          ],
          "return_type": "Tuple",
          "source_file": "contradiction_deteccion.py"
        }
      }
    ],
    "contributing_modules": [
      "Analyzer_one.py",
      "contradiction_deteccion.py",
      "emebedding_policy.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "analyzer_one",
    "evidence_types": [
      "confidence_interval",
      "measurement_confidence",
      "measurement_validation",
      "numerical_validation"
    ],
    "aggregation_strategy": "measurement_assessment",
    "confidence_threshold": 0.82,
    "total_steps": 4
  },
  "P4-D4-Q2": {
    "question_id": "P4-D4-Q2",
    "point": "P4",
    "dimension": "D4",
    "question_number": 2,
    "question_text": "Assess outcome measurement framework",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "analyzer_one",
        "adapter_class": "AnalyzerOneAdapter",
        "method": "validate_measurement_framework",
        "args": [
          {
            "name": "indicators",
            "type": "List[Dict]",
            "source": "outcome_indicators"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "measurement_validation"
        },
        "source_module": "Analyzer_one.py",
        "source_class": "AnalyzerOneAdapter",
        "source_method": "validate_measurement_framework",
        "purpose": "Validate outcome measurement framework",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "indicators",
              "type": "List[Dict]",
              "source": "outcome_indicators"
            }
          ],
          "return_type": "Dict",
          "source_file": "Analyzer_one.py"
        }
      },
      {
        "step": 2,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "validate_numerical_consistency",
        "args": [
          {
            "name": "claims",
            "type": "List[Dict]",
            "source": "numerical_outcomes"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "numerical_validation"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "validate_numerical_consistency",
        "purpose": "Validate numerical consistency in outcomes",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "claims",
              "type": "List[Dict]",
              "source": "numerical_outcomes"
            }
          ],
          "return_type": "Dict",
          "source_file": "emebedding_policy.py"
        }
      },
      {
        "step": 3,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "calculate_bayesian_confidence",
        "args": [
          {
            "name": "priors",
            "type": "Dict",
            "source": "outcome_priors"
          },
          {
            "name": "evidence",
            "type": "List",
            "source": "measurement_evidence"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "measurement_confidence"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "calculate_bayesian_confidence",
        "purpose": "Calculate Bayesian confidence in measurements",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "priors",
              "type": "Dict",
              "source": "outcome_priors"
            },
            {
              "name": "evidence",
              "type": "List",
              "source": "measurement_evidence"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 4,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_calculate_confidence_interval",
        "args": [
          {
            "name": "contradictions",
            "type": "List",
            "source": "measurement_conflicts"
          }
        ],
        "returns": {
          "type": "Tuple",
          "binding": "confidence_interval"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_calculate_confidence_interval",
        "purpose": "Calculate confidence interval for measurements",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "contradictions",
              "type": "List",
              "source": "measurement_conflicts"
            }
          ],
          "return_type": "Tuple",
          "source_file": "contradiction_deteccion.py"
        }
      }
    ],
    "contributing_modules": [
      "Analyzer_one.py",
      "contradiction_deteccion.py",
      "emebedding_policy.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "analyzer_one",
    "evidence_types": [
      "confidence_interval",
      "measurement_confidence",
      "measurement_validation",
      "numerical_validation"
    ],
    "aggregation_strategy": "measurement_assessment",
    "confidence_threshold": 0.82,
    "total_steps": 4
  },
  "P5-D4-Q2": {
    "question_id": "P5-D4-Q2",
    "point": "P5",
    "dimension": "D4",
    "question_number": 2,
    "question_text": "Assess outcome measurement framework",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "analyzer_one",
        "adapter_class": "AnalyzerOneAdapter",
        "method": "validate_measurement_framework",
        "args": [
          {
            "name": "indicators",
            "type": "List[Dict]",
            "source": "outcome_indicators"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "measurement_validation"
        },
        "source_module": "Analyzer_one.py",
        "source_class": "AnalyzerOneAdapter",
        "source_method": "validate_measurement_framework",
        "purpose": "Validate outcome measurement framework",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "indicators",
              "type": "List[Dict]",
              "source": "outcome_indicators"
            }
          ],
          "return_type": "Dict",
          "source_file": "Analyzer_one.py"
        }
      },
      {
        "step": 2,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "validate_numerical_consistency",
        "args": [
          {
            "name": "claims",
            "type": "List[Dict]",
            "source": "numerical_outcomes"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "numerical_validation"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "validate_numerical_consistency",
        "purpose": "Validate numerical consistency in outcomes",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "claims",
              "type": "List[Dict]",
              "source": "numerical_outcomes"
            }
          ],
          "return_type": "Dict",
          "source_file": "emebedding_policy.py"
        }
      },
      {
        "step": 3,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "calculate_bayesian_confidence",
        "args": [
          {
            "name": "priors",
            "type": "Dict",
            "source": "outcome_priors"
          },
          {
            "name": "evidence",
            "type": "List",
            "source": "measurement_evidence"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "measurement_confidence"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "calculate_bayesian_confidence",
        "purpose": "Calculate Bayesian confidence in measurements",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "priors",
              "type": "Dict",
              "source": "outcome_priors"
            },
            {
              "name": "evidence",
              "type": "List",
              "source": "measurement_evidence"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 4,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_calculate_confidence_interval",
        "args": [
          {
            "name": "contradictions",
            "type": "List",
            "source": "measurement_conflicts"
          }
        ],
        "returns": {
          "type": "Tuple",
          "binding": "confidence_interval"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_calculate_confidence_interval",
        "purpose": "Calculate confidence interval for measurements",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "contradictions",
              "type": "List",
              "source": "measurement_conflicts"
            }
          ],
          "return_type": "Tuple",
          "source_file": "contradiction_deteccion.py"
        }
      }
    ],
    "contributing_modules": [
      "Analyzer_one.py",
      "contradiction_deteccion.py",
      "emebedding_policy.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "analyzer_one",
    "evidence_types": [
      "confidence_interval",
      "measurement_confidence",
      "measurement_validation",
      "numerical_validation"
    ],
    "aggregation_strategy": "measurement_assessment",
    "confidence_threshold": 0.82,
    "total_steps": 4
  },
  "P6-D4-Q2": {
    "question_id": "P6-D4-Q2",
    "point": "P6",
    "dimension": "D4",
    "question_number": 2,
    "question_text": "Assess outcome measurement framework",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "analyzer_one",
        "adapter_class": "AnalyzerOneAdapter",
        "method": "validate_measurement_framework",
        "args": [
          {
            "name": "indicators",
            "type": "List[Dict]",
            "source": "outcome_indicators"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "measurement_validation"
        },
        "source_module": "Analyzer_one.py",
        "source_class": "AnalyzerOneAdapter",
        "source_method": "validate_measurement_framework",
        "purpose": "Validate outcome measurement framework",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "indicators",
              "type": "List[Dict]",
              "source": "outcome_indicators"
            }
          ],
          "return_type": "Dict",
          "source_file": "Analyzer_one.py"
        }
      },
      {
        "step": 2,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "validate_numerical_consistency",
        "args": [
          {
            "name": "claims",
            "type": "List[Dict]",
            "source": "numerical_outcomes"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "numerical_validation"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "validate_numerical_consistency",
        "purpose": "Validate numerical consistency in outcomes",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "claims",
              "type": "List[Dict]",
              "source": "numerical_outcomes"
            }
          ],
          "return_type": "Dict",
          "source_file": "emebedding_policy.py"
        }
      },
      {
        "step": 3,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "calculate_bayesian_confidence",
        "args": [
          {
            "name": "priors",
            "type": "Dict",
            "source": "outcome_priors"
          },
          {
            "name": "evidence",
            "type": "List",
            "source": "measurement_evidence"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "measurement_confidence"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "calculate_bayesian_confidence",
        "purpose": "Calculate Bayesian confidence in measurements",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "priors",
              "type": "Dict",
              "source": "outcome_priors"
            },
            {
              "name": "evidence",
              "type": "List",
              "source": "measurement_evidence"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 4,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_calculate_confidence_interval",
        "args": [
          {
            "name": "contradictions",
            "type": "List",
            "source": "measurement_conflicts"
          }
        ],
        "returns": {
          "type": "Tuple",
          "binding": "confidence_interval"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_calculate_confidence_interval",
        "purpose": "Calculate confidence interval for measurements",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "contradictions",
              "type": "List",
              "source": "measurement_conflicts"
            }
          ],
          "return_type": "Tuple",
          "source_file": "contradiction_deteccion.py"
        }
      }
    ],
    "contributing_modules": [
      "Analyzer_one.py",
      "contradiction_deteccion.py",
      "emebedding_policy.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "analyzer_one",
    "evidence_types": [
      "confidence_interval",
      "measurement_confidence",
      "measurement_validation",
      "numerical_validation"
    ],
    "aggregation_strategy": "measurement_assessment",
    "confidence_threshold": 0.82,
    "total_steps": 4
  },
  "P7-D4-Q2": {
    "question_id": "P7-D4-Q2",
    "point": "P7",
    "dimension": "D4",
    "question_number": 2,
    "question_text": "Assess outcome measurement framework",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "analyzer_one",
        "adapter_class": "AnalyzerOneAdapter",
        "method": "validate_measurement_framework",
        "args": [
          {
            "name": "indicators",
            "type": "List[Dict]",
            "source": "outcome_indicators"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "measurement_validation"
        },
        "source_module": "Analyzer_one.py",
        "source_class": "AnalyzerOneAdapter",
        "source_method": "validate_measurement_framework",
        "purpose": "Validate outcome measurement framework",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "indicators",
              "type": "List[Dict]",
              "source": "outcome_indicators"
            }
          ],
          "return_type": "Dict",
          "source_file": "Analyzer_one.py"
        }
      },
      {
        "step": 2,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "validate_numerical_consistency",
        "args": [
          {
            "name": "claims",
            "type": "List[Dict]",
            "source": "numerical_outcomes"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "numerical_validation"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "validate_numerical_consistency",
        "purpose": "Validate numerical consistency in outcomes",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "claims",
              "type": "List[Dict]",
              "source": "numerical_outcomes"
            }
          ],
          "return_type": "Dict",
          "source_file": "emebedding_policy.py"
        }
      },
      {
        "step": 3,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "calculate_bayesian_confidence",
        "args": [
          {
            "name": "priors",
            "type": "Dict",
            "source": "outcome_priors"
          },
          {
            "name": "evidence",
            "type": "List",
            "source": "measurement_evidence"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "measurement_confidence"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "calculate_bayesian_confidence",
        "purpose": "Calculate Bayesian confidence in measurements",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "priors",
              "type": "Dict",
              "source": "outcome_priors"
            },
            {
              "name": "evidence",
              "type": "List",
              "source": "measurement_evidence"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 4,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_calculate_confidence_interval",
        "args": [
          {
            "name": "contradictions",
            "type": "List",
            "source": "measurement_conflicts"
          }
        ],
        "returns": {
          "type": "Tuple",
          "binding": "confidence_interval"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_calculate_confidence_interval",
        "purpose": "Calculate confidence interval for measurements",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "contradictions",
              "type": "List",
              "source": "measurement_conflicts"
            }
          ],
          "return_type": "Tuple",
          "source_file": "contradiction_deteccion.py"
        }
      }
    ],
    "contributing_modules": [
      "Analyzer_one.py",
      "contradiction_deteccion.py",
      "emebedding_policy.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "analyzer_one",
    "evidence_types": [
      "confidence_interval",
      "measurement_confidence",
      "measurement_validation",
      "numerical_validation"
    ],
    "aggregation_strategy": "measurement_assessment",
    "confidence_threshold": 0.82,
    "total_steps": 4
  },
  "P8-D4-Q2": {
    "question_id": "P8-D4-Q2",
    "point": "P8",
    "dimension": "D4",
    "question_number": 2,
    "question_text": "Assess outcome measurement framework",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "analyzer_one",
        "adapter_class": "AnalyzerOneAdapter",
        "method": "validate_measurement_framework",
        "args": [
          {
            "name": "indicators",
            "type": "List[Dict]",
            "source": "outcome_indicators"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "measurement_validation"
        },
        "source_module": "Analyzer_one.py",
        "source_class": "AnalyzerOneAdapter",
        "source_method": "validate_measurement_framework",
        "purpose": "Validate outcome measurement framework",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "indicators",
              "type": "List[Dict]",
              "source": "outcome_indicators"
            }
          ],
          "return_type": "Dict",
          "source_file": "Analyzer_one.py"
        }
      },
      {
        "step": 2,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "validate_numerical_consistency",
        "args": [
          {
            "name": "claims",
            "type": "List[Dict]",
            "source": "numerical_outcomes"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "numerical_validation"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "validate_numerical_consistency",
        "purpose": "Validate numerical consistency in outcomes",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "claims",
              "type": "List[Dict]",
              "source": "numerical_outcomes"
            }
          ],
          "return_type": "Dict",
          "source_file": "emebedding_policy.py"
        }
      },
      {
        "step": 3,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "calculate_bayesian_confidence",
        "args": [
          {
            "name": "priors",
            "type": "Dict",
            "source": "outcome_priors"
          },
          {
            "name": "evidence",
            "type": "List",
            "source": "measurement_evidence"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "measurement_confidence"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "calculate_bayesian_confidence",
        "purpose": "Calculate Bayesian confidence in measurements",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "priors",
              "type": "Dict",
              "source": "outcome_priors"
            },
            {
              "name": "evidence",
              "type": "List",
              "source": "measurement_evidence"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 4,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_calculate_confidence_interval",
        "args": [
          {
            "name": "contradictions",
            "type": "List",
            "source": "measurement_conflicts"
          }
        ],
        "returns": {
          "type": "Tuple",
          "binding": "confidence_interval"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_calculate_confidence_interval",
        "purpose": "Calculate confidence interval for measurements",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "contradictions",
              "type": "List",
              "source": "measurement_conflicts"
            }
          ],
          "return_type": "Tuple",
          "source_file": "contradiction_deteccion.py"
        }
      }
    ],
    "contributing_modules": [
      "Analyzer_one.py",
      "contradiction_deteccion.py",
      "emebedding_policy.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "analyzer_one",
    "evidence_types": [
      "confidence_interval",
      "measurement_confidence",
      "measurement_validation",
      "numerical_validation"
    ],
    "aggregation_strategy": "measurement_assessment",
    "confidence_threshold": 0.82,
    "total_steps": 4
  },
  "P9-D4-Q2": {
    "question_id": "P9-D4-Q2",
    "point": "P9",
    "dimension": "D4",
    "question_number": 2,
    "question_text": "Assess outcome measurement framework",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "analyzer_one",
        "adapter_class": "AnalyzerOneAdapter",
        "method": "validate_measurement_framework",
        "args": [
          {
            "name": "indicators",
            "type": "List[Dict]",
            "source": "outcome_indicators"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "measurement_validation"
        },
        "source_module": "Analyzer_one.py",
        "source_class": "AnalyzerOneAdapter",
        "source_method": "validate_measurement_framework",
        "purpose": "Validate outcome measurement framework",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "indicators",
              "type": "List[Dict]",
              "source": "outcome_indicators"
            }
          ],
          "return_type": "Dict",
          "source_file": "Analyzer_one.py"
        }
      },
      {
        "step": 2,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "validate_numerical_consistency",
        "args": [
          {
            "name": "claims",
            "type": "List[Dict]",
            "source": "numerical_outcomes"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "numerical_validation"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "validate_numerical_consistency",
        "purpose": "Validate numerical consistency in outcomes",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "claims",
              "type": "List[Dict]",
              "source": "numerical_outcomes"
            }
          ],
          "return_type": "Dict",
          "source_file": "emebedding_policy.py"
        }
      },
      {
        "step": 3,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "calculate_bayesian_confidence",
        "args": [
          {
            "name": "priors",
            "type": "Dict",
            "source": "outcome_priors"
          },
          {
            "name": "evidence",
            "type": "List",
            "source": "measurement_evidence"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "measurement_confidence"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "calculate_bayesian_confidence",
        "purpose": "Calculate Bayesian confidence in measurements",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "priors",
              "type": "Dict",
              "source": "outcome_priors"
            },
            {
              "name": "evidence",
              "type": "List",
              "source": "measurement_evidence"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 4,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_calculate_confidence_interval",
        "args": [
          {
            "name": "contradictions",
            "type": "List",
            "source": "measurement_conflicts"
          }
        ],
        "returns": {
          "type": "Tuple",
          "binding": "confidence_interval"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_calculate_confidence_interval",
        "purpose": "Calculate confidence interval for measurements",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "contradictions",
              "type": "List",
              "source": "measurement_conflicts"
            }
          ],
          "return_type": "Tuple",
          "source_file": "contradiction_deteccion.py"
        }
      }
    ],
    "contributing_modules": [
      "Analyzer_one.py",
      "contradiction_deteccion.py",
      "emebedding_policy.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "analyzer_one",
    "evidence_types": [
      "confidence_interval",
      "measurement_confidence",
      "measurement_validation",
      "numerical_validation"
    ],
    "aggregation_strategy": "measurement_assessment",
    "confidence_threshold": 0.82,
    "total_steps": 4
  },
  "P10-D4-Q2": {
    "question_id": "P10-D4-Q2",
    "point": "P10",
    "dimension": "D4",
    "question_number": 2,
    "question_text": "Assess outcome measurement framework",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "analyzer_one",
        "adapter_class": "AnalyzerOneAdapter",
        "method": "validate_measurement_framework",
        "args": [
          {
            "name": "indicators",
            "type": "List[Dict]",
            "source": "outcome_indicators"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "measurement_validation"
        },
        "source_module": "Analyzer_one.py",
        "source_class": "AnalyzerOneAdapter",
        "source_method": "validate_measurement_framework",
        "purpose": "Validate outcome measurement framework",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "indicators",
              "type": "List[Dict]",
              "source": "outcome_indicators"
            }
          ],
          "return_type": "Dict",
          "source_file": "Analyzer_one.py"
        }
      },
      {
        "step": 2,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "validate_numerical_consistency",
        "args": [
          {
            "name": "claims",
            "type": "List[Dict]",
            "source": "numerical_outcomes"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "numerical_validation"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "validate_numerical_consistency",
        "purpose": "Validate numerical consistency in outcomes",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "claims",
              "type": "List[Dict]",
              "source": "numerical_outcomes"
            }
          ],
          "return_type": "Dict",
          "source_file": "emebedding_policy.py"
        }
      },
      {
        "step": 3,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "calculate_bayesian_confidence",
        "args": [
          {
            "name": "priors",
            "type": "Dict",
            "source": "outcome_priors"
          },
          {
            "name": "evidence",
            "type": "List",
            "source": "measurement_evidence"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "measurement_confidence"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "calculate_bayesian_confidence",
        "purpose": "Calculate Bayesian confidence in measurements",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "priors",
              "type": "Dict",
              "source": "outcome_priors"
            },
            {
              "name": "evidence",
              "type": "List",
              "source": "measurement_evidence"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 4,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_calculate_confidence_interval",
        "args": [
          {
            "name": "contradictions",
            "type": "List",
            "source": "measurement_conflicts"
          }
        ],
        "returns": {
          "type": "Tuple",
          "binding": "confidence_interval"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_calculate_confidence_interval",
        "purpose": "Calculate confidence interval for measurements",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "contradictions",
              "type": "List",
              "source": "measurement_conflicts"
            }
          ],
          "return_type": "Tuple",
          "source_file": "contradiction_deteccion.py"
        }
      }
    ],
    "contributing_modules": [
      "Analyzer_one.py",
      "contradiction_deteccion.py",
      "emebedding_policy.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "analyzer_one",
    "evidence_types": [
      "confidence_interval",
      "measurement_confidence",
      "measurement_validation",
      "numerical_validation"
    ],
    "aggregation_strategy": "measurement_assessment",
    "confidence_threshold": 0.82,
    "total_steps": 4
  },
  "P1-D5-Q1": {
    "question_id": "P1-D5-Q1",
    "point": "P1",
    "dimension": "D5",
    "question_number": 1,
    "question_text": "Construct and validate causal model",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "construct_causal_dag",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          },
          {
            "name": "indicators",
            "type": "List",
            "source": "all_indicators"
          }
        ],
        "returns": {
          "type": "nx.DiGraph",
          "binding": "complete_causal_dag"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "construct_causal_dag",
        "purpose": "Construct complete causal DAG",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            },
            {
              "name": "indicators",
              "type": "List",
              "source": "all_indicators"
            }
          ],
          "return_type": "nx.DiGraph",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 2,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "construct_causal_graph",
        "args": [
          {
            "name": "mechanisms",
            "type": "List[Dict]",
            "source": "identified_mechanisms"
          }
        ],
        "returns": {
          "type": "nx.DiGraph",
          "binding": "beach_causal_graph"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "construct_causal_graph",
        "purpose": "Construct causal graph using Beach methodology",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "mechanisms",
              "type": "List[Dict]",
              "source": "identified_mechanisms"
            }
          ],
          "return_type": "nx.DiGraph",
          "source_file": "dereck_beach.py"
        }
      },
      {
        "step": 3,
        "adapter": "financial_viability",
        "adapter_class": "FinancialViabilityAdapter",
        "method": "construct_causal_dag",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          },
          {
            "name": "indicators",
            "type": "List",
            "source": "pdet_indicators"
          }
        ],
        "returns": {
          "type": "nx.DiGraph",
          "binding": "financial_causal_dag"
        },
        "source_module": "financiero_viabilidad_tablas.py",
        "source_class": "FinancialViabilityAdapter",
        "source_method": "construct_causal_dag",
        "purpose": "Construct financial causal DAG",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            },
            {
              "name": "indicators",
              "type": "List",
              "source": "pdet_indicators"
            }
          ],
          "return_type": "nx.DiGraph",
          "source_file": "financiero_viabilidad_tablas.py"
        }
      },
      {
        "step": 4,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "validate_dag_structure",
        "args": [
          {
            "name": "dag",
            "type": "nx.DiGraph",
            "source": "complete_causal_dag"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "dag_validation"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "validate_dag_structure",
        "purpose": "Validate DAG structure and properties",
        "confidence_expected": 0.9,
        "signature": {
          "parameters": [
            {
              "name": "dag",
              "type": "nx.DiGraph",
              "source": "complete_causal_dag"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      }
    ],
    "contributing_modules": [
      "dereck_beach.py",
      "financiero_viabilidad_tablas.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "teoria_cambio",
    "evidence_types": [
      "beach_causal_graph",
      "complete_causal_dag",
      "dag_validation",
      "financial_causal_dag"
    ],
    "aggregation_strategy": "causal_model_synthesis",
    "confidence_threshold": 0.85,
    "total_steps": 4
  },
  "P2-D5-Q1": {
    "question_id": "P2-D5-Q1",
    "point": "P2",
    "dimension": "D5",
    "question_number": 1,
    "question_text": "Construct and validate causal model",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "construct_causal_dag",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          },
          {
            "name": "indicators",
            "type": "List",
            "source": "all_indicators"
          }
        ],
        "returns": {
          "type": "nx.DiGraph",
          "binding": "complete_causal_dag"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "construct_causal_dag",
        "purpose": "Construct complete causal DAG",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            },
            {
              "name": "indicators",
              "type": "List",
              "source": "all_indicators"
            }
          ],
          "return_type": "nx.DiGraph",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 2,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "construct_causal_graph",
        "args": [
          {
            "name": "mechanisms",
            "type": "List[Dict]",
            "source": "identified_mechanisms"
          }
        ],
        "returns": {
          "type": "nx.DiGraph",
          "binding": "beach_causal_graph"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "construct_causal_graph",
        "purpose": "Construct causal graph using Beach methodology",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "mechanisms",
              "type": "List[Dict]",
              "source": "identified_mechanisms"
            }
          ],
          "return_type": "nx.DiGraph",
          "source_file": "dereck_beach.py"
        }
      },
      {
        "step": 3,
        "adapter": "financial_viability",
        "adapter_class": "FinancialViabilityAdapter",
        "method": "construct_causal_dag",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          },
          {
            "name": "indicators",
            "type": "List",
            "source": "pdet_indicators"
          }
        ],
        "returns": {
          "type": "nx.DiGraph",
          "binding": "financial_causal_dag"
        },
        "source_module": "financiero_viabilidad_tablas.py",
        "source_class": "FinancialViabilityAdapter",
        "source_method": "construct_causal_dag",
        "purpose": "Construct financial causal DAG",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            },
            {
              "name": "indicators",
              "type": "List",
              "source": "pdet_indicators"
            }
          ],
          "return_type": "nx.DiGraph",
          "source_file": "financiero_viabilidad_tablas.py"
        }
      },
      {
        "step": 4,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "validate_dag_structure",
        "args": [
          {
            "name": "dag",
            "type": "nx.DiGraph",
            "source": "complete_causal_dag"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "dag_validation"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "validate_dag_structure",
        "purpose": "Validate DAG structure and properties",
        "confidence_expected": 0.9,
        "signature": {
          "parameters": [
            {
              "name": "dag",
              "type": "nx.DiGraph",
              "source": "complete_causal_dag"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      }
    ],
    "contributing_modules": [
      "dereck_beach.py",
      "financiero_viabilidad_tablas.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "teoria_cambio",
    "evidence_types": [
      "beach_causal_graph",
      "complete_causal_dag",
      "dag_validation",
      "financial_causal_dag"
    ],
    "aggregation_strategy": "causal_model_synthesis",
    "confidence_threshold": 0.85,
    "total_steps": 4
  },
  "P3-D5-Q1": {
    "question_id": "P3-D5-Q1",
    "point": "P3",
    "dimension": "D5",
    "question_number": 1,
    "question_text": "Construct and validate causal model",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "construct_causal_dag",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          },
          {
            "name": "indicators",
            "type": "List",
            "source": "all_indicators"
          }
        ],
        "returns": {
          "type": "nx.DiGraph",
          "binding": "complete_causal_dag"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "construct_causal_dag",
        "purpose": "Construct complete causal DAG",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            },
            {
              "name": "indicators",
              "type": "List",
              "source": "all_indicators"
            }
          ],
          "return_type": "nx.DiGraph",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 2,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "construct_causal_graph",
        "args": [
          {
            "name": "mechanisms",
            "type": "List[Dict]",
            "source": "identified_mechanisms"
          }
        ],
        "returns": {
          "type": "nx.DiGraph",
          "binding": "beach_causal_graph"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "construct_causal_graph",
        "purpose": "Construct causal graph using Beach methodology",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "mechanisms",
              "type": "List[Dict]",
              "source": "identified_mechanisms"
            }
          ],
          "return_type": "nx.DiGraph",
          "source_file": "dereck_beach.py"
        }
      },
      {
        "step": 3,
        "adapter": "financial_viability",
        "adapter_class": "FinancialViabilityAdapter",
        "method": "construct_causal_dag",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          },
          {
            "name": "indicators",
            "type": "List",
            "source": "pdet_indicators"
          }
        ],
        "returns": {
          "type": "nx.DiGraph",
          "binding": "financial_causal_dag"
        },
        "source_module": "financiero_viabilidad_tablas.py",
        "source_class": "FinancialViabilityAdapter",
        "source_method": "construct_causal_dag",
        "purpose": "Construct financial causal DAG",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            },
            {
              "name": "indicators",
              "type": "List",
              "source": "pdet_indicators"
            }
          ],
          "return_type": "nx.DiGraph",
          "source_file": "financiero_viabilidad_tablas.py"
        }
      },
      {
        "step": 4,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "validate_dag_structure",
        "args": [
          {
            "name": "dag",
            "type": "nx.DiGraph",
            "source": "complete_causal_dag"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "dag_validation"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "validate_dag_structure",
        "purpose": "Validate DAG structure and properties",
        "confidence_expected": 0.9,
        "signature": {
          "parameters": [
            {
              "name": "dag",
              "type": "nx.DiGraph",
              "source": "complete_causal_dag"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      }
    ],
    "contributing_modules": [
      "dereck_beach.py",
      "financiero_viabilidad_tablas.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "teoria_cambio",
    "evidence_types": [
      "beach_causal_graph",
      "complete_causal_dag",
      "dag_validation",
      "financial_causal_dag"
    ],
    "aggregation_strategy": "causal_model_synthesis",
    "confidence_threshold": 0.85,
    "total_steps": 4
  },
  "P4-D5-Q1": {
    "question_id": "P4-D5-Q1",
    "point": "P4",
    "dimension": "D5",
    "question_number": 1,
    "question_text": "Construct and validate causal model",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "construct_causal_dag",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          },
          {
            "name": "indicators",
            "type": "List",
            "source": "all_indicators"
          }
        ],
        "returns": {
          "type": "nx.DiGraph",
          "binding": "complete_causal_dag"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "construct_causal_dag",
        "purpose": "Construct complete causal DAG",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            },
            {
              "name": "indicators",
              "type": "List",
              "source": "all_indicators"
            }
          ],
          "return_type": "nx.DiGraph",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 2,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "construct_causal_graph",
        "args": [
          {
            "name": "mechanisms",
            "type": "List[Dict]",
            "source": "identified_mechanisms"
          }
        ],
        "returns": {
          "type": "nx.DiGraph",
          "binding": "beach_causal_graph"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "construct_causal_graph",
        "purpose": "Construct causal graph using Beach methodology",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "mechanisms",
              "type": "List[Dict]",
              "source": "identified_mechanisms"
            }
          ],
          "return_type": "nx.DiGraph",
          "source_file": "dereck_beach.py"
        }
      },
      {
        "step": 3,
        "adapter": "financial_viability",
        "adapter_class": "FinancialViabilityAdapter",
        "method": "construct_causal_dag",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          },
          {
            "name": "indicators",
            "type": "List",
            "source": "pdet_indicators"
          }
        ],
        "returns": {
          "type": "nx.DiGraph",
          "binding": "financial_causal_dag"
        },
        "source_module": "financiero_viabilidad_tablas.py",
        "source_class": "FinancialViabilityAdapter",
        "source_method": "construct_causal_dag",
        "purpose": "Construct financial causal DAG",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            },
            {
              "name": "indicators",
              "type": "List",
              "source": "pdet_indicators"
            }
          ],
          "return_type": "nx.DiGraph",
          "source_file": "financiero_viabilidad_tablas.py"
        }
      },
      {
        "step": 4,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "validate_dag_structure",
        "args": [
          {
            "name": "dag",
            "type": "nx.DiGraph",
            "source": "complete_causal_dag"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "dag_validation"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "validate_dag_structure",
        "purpose": "Validate DAG structure and properties",
        "confidence_expected": 0.9,
        "signature": {
          "parameters": [
            {
              "name": "dag",
              "type": "nx.DiGraph",
              "source": "complete_causal_dag"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      }
    ],
    "contributing_modules": [
      "dereck_beach.py",
      "financiero_viabilidad_tablas.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "teoria_cambio",
    "evidence_types": [
      "beach_causal_graph",
      "complete_causal_dag",
      "dag_validation",
      "financial_causal_dag"
    ],
    "aggregation_strategy": "causal_model_synthesis",
    "confidence_threshold": 0.85,
    "total_steps": 4
  },
  "P5-D5-Q1": {
    "question_id": "P5-D5-Q1",
    "point": "P5",
    "dimension": "D5",
    "question_number": 1,
    "question_text": "Construct and validate causal model",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "construct_causal_dag",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          },
          {
            "name": "indicators",
            "type": "List",
            "source": "all_indicators"
          }
        ],
        "returns": {
          "type": "nx.DiGraph",
          "binding": "complete_causal_dag"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "construct_causal_dag",
        "purpose": "Construct complete causal DAG",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            },
            {
              "name": "indicators",
              "type": "List",
              "source": "all_indicators"
            }
          ],
          "return_type": "nx.DiGraph",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 2,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "construct_causal_graph",
        "args": [
          {
            "name": "mechanisms",
            "type": "List[Dict]",
            "source": "identified_mechanisms"
          }
        ],
        "returns": {
          "type": "nx.DiGraph",
          "binding": "beach_causal_graph"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "construct_causal_graph",
        "purpose": "Construct causal graph using Beach methodology",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "mechanisms",
              "type": "List[Dict]",
              "source": "identified_mechanisms"
            }
          ],
          "return_type": "nx.DiGraph",
          "source_file": "dereck_beach.py"
        }
      },
      {
        "step": 3,
        "adapter": "financial_viability",
        "adapter_class": "FinancialViabilityAdapter",
        "method": "construct_causal_dag",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          },
          {
            "name": "indicators",
            "type": "List",
            "source": "pdet_indicators"
          }
        ],
        "returns": {
          "type": "nx.DiGraph",
          "binding": "financial_causal_dag"
        },
        "source_module": "financiero_viabilidad_tablas.py",
        "source_class": "FinancialViabilityAdapter",
        "source_method": "construct_causal_dag",
        "purpose": "Construct financial causal DAG",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            },
            {
              "name": "indicators",
              "type": "List",
              "source": "pdet_indicators"
            }
          ],
          "return_type": "nx.DiGraph",
          "source_file": "financiero_viabilidad_tablas.py"
        }
      },
      {
        "step": 4,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "validate_dag_structure",
        "args": [
          {
            "name": "dag",
            "type": "nx.DiGraph",
            "source": "complete_causal_dag"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "dag_validation"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "validate_dag_structure",
        "purpose": "Validate DAG structure and properties",
        "confidence_expected": 0.9,
        "signature": {
          "parameters": [
            {
              "name": "dag",
              "type": "nx.DiGraph",
              "source": "complete_causal_dag"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      }
    ],
    "contributing_modules": [
      "dereck_beach.py",
      "financiero_viabilidad_tablas.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "teoria_cambio",
    "evidence_types": [
      "beach_causal_graph",
      "complete_causal_dag",
      "dag_validation",
      "financial_causal_dag"
    ],
    "aggregation_strategy": "causal_model_synthesis",
    "confidence_threshold": 0.85,
    "total_steps": 4
  },
  "P6-D5-Q1": {
    "question_id": "P6-D5-Q1",
    "point": "P6",
    "dimension": "D5",
    "question_number": 1,
    "question_text": "Construct and validate causal model",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "construct_causal_dag",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          },
          {
            "name": "indicators",
            "type": "List",
            "source": "all_indicators"
          }
        ],
        "returns": {
          "type": "nx.DiGraph",
          "binding": "complete_causal_dag"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "construct_causal_dag",
        "purpose": "Construct complete causal DAG",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            },
            {
              "name": "indicators",
              "type": "List",
              "source": "all_indicators"
            }
          ],
          "return_type": "nx.DiGraph",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 2,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "construct_causal_graph",
        "args": [
          {
            "name": "mechanisms",
            "type": "List[Dict]",
            "source": "identified_mechanisms"
          }
        ],
        "returns": {
          "type": "nx.DiGraph",
          "binding": "beach_causal_graph"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "construct_causal_graph",
        "purpose": "Construct causal graph using Beach methodology",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "mechanisms",
              "type": "List[Dict]",
              "source": "identified_mechanisms"
            }
          ],
          "return_type": "nx.DiGraph",
          "source_file": "dereck_beach.py"
        }
      },
      {
        "step": 3,
        "adapter": "financial_viability",
        "adapter_class": "FinancialViabilityAdapter",
        "method": "construct_causal_dag",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          },
          {
            "name": "indicators",
            "type": "List",
            "source": "pdet_indicators"
          }
        ],
        "returns": {
          "type": "nx.DiGraph",
          "binding": "financial_causal_dag"
        },
        "source_module": "financiero_viabilidad_tablas.py",
        "source_class": "FinancialViabilityAdapter",
        "source_method": "construct_causal_dag",
        "purpose": "Construct financial causal DAG",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            },
            {
              "name": "indicators",
              "type": "List",
              "source": "pdet_indicators"
            }
          ],
          "return_type": "nx.DiGraph",
          "source_file": "financiero_viabilidad_tablas.py"
        }
      },
      {
        "step": 4,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "validate_dag_structure",
        "args": [
          {
            "name": "dag",
            "type": "nx.DiGraph",
            "source": "complete_causal_dag"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "dag_validation"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "validate_dag_structure",
        "purpose": "Validate DAG structure and properties",
        "confidence_expected": 0.9,
        "signature": {
          "parameters": [
            {
              "name": "dag",
              "type": "nx.DiGraph",
              "source": "complete_causal_dag"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      }
    ],
    "contributing_modules": [
      "dereck_beach.py",
      "financiero_viabilidad_tablas.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "teoria_cambio",
    "evidence_types": [
      "beach_causal_graph",
      "complete_causal_dag",
      "dag_validation",
      "financial_causal_dag"
    ],
    "aggregation_strategy": "causal_model_synthesis",
    "confidence_threshold": 0.85,
    "total_steps": 4
  },
  "P7-D5-Q1": {
    "question_id": "P7-D5-Q1",
    "point": "P7",
    "dimension": "D5",
    "question_number": 1,
    "question_text": "Construct and validate causal model",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "construct_causal_dag",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          },
          {
            "name": "indicators",
            "type": "List",
            "source": "all_indicators"
          }
        ],
        "returns": {
          "type": "nx.DiGraph",
          "binding": "complete_causal_dag"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "construct_causal_dag",
        "purpose": "Construct complete causal DAG",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            },
            {
              "name": "indicators",
              "type": "List",
              "source": "all_indicators"
            }
          ],
          "return_type": "nx.DiGraph",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 2,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "construct_causal_graph",
        "args": [
          {
            "name": "mechanisms",
            "type": "List[Dict]",
            "source": "identified_mechanisms"
          }
        ],
        "returns": {
          "type": "nx.DiGraph",
          "binding": "beach_causal_graph"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "construct_causal_graph",
        "purpose": "Construct causal graph using Beach methodology",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "mechanisms",
              "type": "List[Dict]",
              "source": "identified_mechanisms"
            }
          ],
          "return_type": "nx.DiGraph",
          "source_file": "dereck_beach.py"
        }
      },
      {
        "step": 3,
        "adapter": "financial_viability",
        "adapter_class": "FinancialViabilityAdapter",
        "method": "construct_causal_dag",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          },
          {
            "name": "indicators",
            "type": "List",
            "source": "pdet_indicators"
          }
        ],
        "returns": {
          "type": "nx.DiGraph",
          "binding": "financial_causal_dag"
        },
        "source_module": "financiero_viabilidad_tablas.py",
        "source_class": "FinancialViabilityAdapter",
        "source_method": "construct_causal_dag",
        "purpose": "Construct financial causal DAG",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            },
            {
              "name": "indicators",
              "type": "List",
              "source": "pdet_indicators"
            }
          ],
          "return_type": "nx.DiGraph",
          "source_file": "financiero_viabilidad_tablas.py"
        }
      },
      {
        "step": 4,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "validate_dag_structure",
        "args": [
          {
            "name": "dag",
            "type": "nx.DiGraph",
            "source": "complete_causal_dag"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "dag_validation"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "validate_dag_structure",
        "purpose": "Validate DAG structure and properties",
        "confidence_expected": 0.9,
        "signature": {
          "parameters": [
            {
              "name": "dag",
              "type": "nx.DiGraph",
              "source": "complete_causal_dag"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      }
    ],
    "contributing_modules": [
      "dereck_beach.py",
      "financiero_viabilidad_tablas.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "teoria_cambio",
    "evidence_types": [
      "beach_causal_graph",
      "complete_causal_dag",
      "dag_validation",
      "financial_causal_dag"
    ],
    "aggregation_strategy": "causal_model_synthesis",
    "confidence_threshold": 0.85,
    "total_steps": 4
  },
  "P8-D5-Q1": {
    "question_id": "P8-D5-Q1",
    "point": "P8",
    "dimension": "D5",
    "question_number": 1,
    "question_text": "Construct and validate causal model",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "construct_causal_dag",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          },
          {
            "name": "indicators",
            "type": "List",
            "source": "all_indicators"
          }
        ],
        "returns": {
          "type": "nx.DiGraph",
          "binding": "complete_causal_dag"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "construct_causal_dag",
        "purpose": "Construct complete causal DAG",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            },
            {
              "name": "indicators",
              "type": "List",
              "source": "all_indicators"
            }
          ],
          "return_type": "nx.DiGraph",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 2,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "construct_causal_graph",
        "args": [
          {
            "name": "mechanisms",
            "type": "List[Dict]",
            "source": "identified_mechanisms"
          }
        ],
        "returns": {
          "type": "nx.DiGraph",
          "binding": "beach_causal_graph"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "construct_causal_graph",
        "purpose": "Construct causal graph using Beach methodology",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "mechanisms",
              "type": "List[Dict]",
              "source": "identified_mechanisms"
            }
          ],
          "return_type": "nx.DiGraph",
          "source_file": "dereck_beach.py"
        }
      },
      {
        "step": 3,
        "adapter": "financial_viability",
        "adapter_class": "FinancialViabilityAdapter",
        "method": "construct_causal_dag",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          },
          {
            "name": "indicators",
            "type": "List",
            "source": "pdet_indicators"
          }
        ],
        "returns": {
          "type": "nx.DiGraph",
          "binding": "financial_causal_dag"
        },
        "source_module": "financiero_viabilidad_tablas.py",
        "source_class": "FinancialViabilityAdapter",
        "source_method": "construct_causal_dag",
        "purpose": "Construct financial causal DAG",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            },
            {
              "name": "indicators",
              "type": "List",
              "source": "pdet_indicators"
            }
          ],
          "return_type": "nx.DiGraph",
          "source_file": "financiero_viabilidad_tablas.py"
        }
      },
      {
        "step": 4,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "validate_dag_structure",
        "args": [
          {
            "name": "dag",
            "type": "nx.DiGraph",
            "source": "complete_causal_dag"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "dag_validation"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "validate_dag_structure",
        "purpose": "Validate DAG structure and properties",
        "confidence_expected": 0.9,
        "signature": {
          "parameters": [
            {
              "name": "dag",
              "type": "nx.DiGraph",
              "source": "complete_causal_dag"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      }
    ],
    "contributing_modules": [
      "dereck_beach.py",
      "financiero_viabilidad_tablas.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "teoria_cambio",
    "evidence_types": [
      "beach_causal_graph",
      "complete_causal_dag",
      "dag_validation",
      "financial_causal_dag"
    ],
    "aggregation_strategy": "causal_model_synthesis",
    "confidence_threshold": 0.85,
    "total_steps": 4
  },
  "P9-D5-Q1": {
    "question_id": "P9-D5-Q1",
    "point": "P9",
    "dimension": "D5",
    "question_number": 1,
    "question_text": "Construct and validate causal model",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "construct_causal_dag",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          },
          {
            "name": "indicators",
            "type": "List",
            "source": "all_indicators"
          }
        ],
        "returns": {
          "type": "nx.DiGraph",
          "binding": "complete_causal_dag"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "construct_causal_dag",
        "purpose": "Construct complete causal DAG",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            },
            {
              "name": "indicators",
              "type": "List",
              "source": "all_indicators"
            }
          ],
          "return_type": "nx.DiGraph",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 2,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "construct_causal_graph",
        "args": [
          {
            "name": "mechanisms",
            "type": "List[Dict]",
            "source": "identified_mechanisms"
          }
        ],
        "returns": {
          "type": "nx.DiGraph",
          "binding": "beach_causal_graph"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "construct_causal_graph",
        "purpose": "Construct causal graph using Beach methodology",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "mechanisms",
              "type": "List[Dict]",
              "source": "identified_mechanisms"
            }
          ],
          "return_type": "nx.DiGraph",
          "source_file": "dereck_beach.py"
        }
      },
      {
        "step": 3,
        "adapter": "financial_viability",
        "adapter_class": "FinancialViabilityAdapter",
        "method": "construct_causal_dag",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          },
          {
            "name": "indicators",
            "type": "List",
            "source": "pdet_indicators"
          }
        ],
        "returns": {
          "type": "nx.DiGraph",
          "binding": "financial_causal_dag"
        },
        "source_module": "financiero_viabilidad_tablas.py",
        "source_class": "FinancialViabilityAdapter",
        "source_method": "construct_causal_dag",
        "purpose": "Construct financial causal DAG",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            },
            {
              "name": "indicators",
              "type": "List",
              "source": "pdet_indicators"
            }
          ],
          "return_type": "nx.DiGraph",
          "source_file": "financiero_viabilidad_tablas.py"
        }
      },
      {
        "step": 4,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "validate_dag_structure",
        "args": [
          {
            "name": "dag",
            "type": "nx.DiGraph",
            "source": "complete_causal_dag"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "dag_validation"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "validate_dag_structure",
        "purpose": "Validate DAG structure and properties",
        "confidence_expected": 0.9,
        "signature": {
          "parameters": [
            {
              "name": "dag",
              "type": "nx.DiGraph",
              "source": "complete_causal_dag"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      }
    ],
    "contributing_modules": [
      "dereck_beach.py",
      "financiero_viabilidad_tablas.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "teoria_cambio",
    "evidence_types": [
      "beach_causal_graph",
      "complete_causal_dag",
      "dag_validation",
      "financial_causal_dag"
    ],
    "aggregation_strategy": "causal_model_synthesis",
    "confidence_threshold": 0.85,
    "total_steps": 4
  },
  "P10-D5-Q1": {
    "question_id": "P10-D5-Q1",
    "point": "P10",
    "dimension": "D5",
    "question_number": 1,
    "question_text": "Construct and validate causal model",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "construct_causal_dag",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          },
          {
            "name": "indicators",
            "type": "List",
            "source": "all_indicators"
          }
        ],
        "returns": {
          "type": "nx.DiGraph",
          "binding": "complete_causal_dag"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "construct_causal_dag",
        "purpose": "Construct complete causal DAG",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            },
            {
              "name": "indicators",
              "type": "List",
              "source": "all_indicators"
            }
          ],
          "return_type": "nx.DiGraph",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 2,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "construct_causal_graph",
        "args": [
          {
            "name": "mechanisms",
            "type": "List[Dict]",
            "source": "identified_mechanisms"
          }
        ],
        "returns": {
          "type": "nx.DiGraph",
          "binding": "beach_causal_graph"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "construct_causal_graph",
        "purpose": "Construct causal graph using Beach methodology",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "mechanisms",
              "type": "List[Dict]",
              "source": "identified_mechanisms"
            }
          ],
          "return_type": "nx.DiGraph",
          "source_file": "dereck_beach.py"
        }
      },
      {
        "step": 3,
        "adapter": "financial_viability",
        "adapter_class": "FinancialViabilityAdapter",
        "method": "construct_causal_dag",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          },
          {
            "name": "indicators",
            "type": "List",
            "source": "pdet_indicators"
          }
        ],
        "returns": {
          "type": "nx.DiGraph",
          "binding": "financial_causal_dag"
        },
        "source_module": "financiero_viabilidad_tablas.py",
        "source_class": "FinancialViabilityAdapter",
        "source_method": "construct_causal_dag",
        "purpose": "Construct financial causal DAG",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            },
            {
              "name": "indicators",
              "type": "List",
              "source": "pdet_indicators"
            }
          ],
          "return_type": "nx.DiGraph",
          "source_file": "financiero_viabilidad_tablas.py"
        }
      },
      {
        "step": 4,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "validate_dag_structure",
        "args": [
          {
            "name": "dag",
            "type": "nx.DiGraph",
            "source": "complete_causal_dag"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "dag_validation"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "validate_dag_structure",
        "purpose": "Validate DAG structure and properties",
        "confidence_expected": 0.9,
        "signature": {
          "parameters": [
            {
              "name": "dag",
              "type": "nx.DiGraph",
              "source": "complete_causal_dag"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      }
    ],
    "contributing_modules": [
      "dereck_beach.py",
      "financiero_viabilidad_tablas.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "teoria_cambio",
    "evidence_types": [
      "beach_causal_graph",
      "complete_causal_dag",
      "dag_validation",
      "financial_causal_dag"
    ],
    "aggregation_strategy": "causal_model_synthesis",
    "confidence_threshold": 0.85,
    "total_steps": 4
  },
  "P1-D5-Q2": {
    "question_id": "P1-D5-Q2",
    "point": "P1",
    "dimension": "D5",
    "question_number": 2,
    "question_text": "Estimate causal effects and strengths",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "estimate_causal_effects",
        "args": [
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "source": "complete_causal_dag"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "estimated_effects"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "estimate_causal_effects",
        "purpose": "Estimate all causal effects in DAG",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "graph",
              "type": "nx.DiGraph",
              "source": "complete_causal_dag"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 2,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "calculate_mechanism_strength",
        "args": [
          {
            "name": "mechanism",
            "type": "Dict",
            "source": "causal_mechanism"
          }
        ],
        "returns": {
          "type": "float",
          "binding": "mechanism_strength"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "calculate_mechanism_strength",
        "purpose": "Calculate individual mechanism strength",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "mechanism",
              "type": "Dict",
              "source": "causal_mechanism"
            }
          ],
          "return_type": "float",
          "source_file": "dereck_beach.py"
        }
      },
      {
        "step": 3,
        "adapter": "financial_viability",
        "adapter_class": "FinancialViabilityAdapter",
        "method": "estimate_causal_effects",
        "args": [
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "source": "financial_causal_dag"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "financial_effects"
        },
        "source_module": "financiero_viabilidad_tablas.py",
        "source_class": "FinancialViabilityAdapter",
        "source_method": "estimate_causal_effects",
        "purpose": "Estimate financial causal effects",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "graph",
              "type": "nx.DiGraph",
              "source": "financial_causal_dag"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "financiero_viabilidad_tablas.py"
        }
      },
      {
        "step": 4,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "sensitivity_analysis",
        "args": [
          {
            "name": "effects",
            "type": "List[Dict]",
            "source": "estimated_effects"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "sensitivity_results"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "sensitivity_analysis",
        "purpose": "Perform sensitivity analysis on causal effects",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "effects",
              "type": "List[Dict]",
              "source": "estimated_effects"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      }
    ],
    "contributing_modules": [
      "dereck_beach.py",
      "financiero_viabilidad_tablas.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "teoria_cambio",
    "evidence_types": [
      "estimated_effects",
      "financial_effects",
      "mechanism_strength",
      "sensitivity_results"
    ],
    "aggregation_strategy": "effect_estimation_synthesis",
    "confidence_threshold": 0.82,
    "total_steps": 4
  },
  "P2-D5-Q2": {
    "question_id": "P2-D5-Q2",
    "point": "P2",
    "dimension": "D5",
    "question_number": 2,
    "question_text": "Estimate causal effects and strengths",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "estimate_causal_effects",
        "args": [
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "source": "complete_causal_dag"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "estimated_effects"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "estimate_causal_effects",
        "purpose": "Estimate all causal effects in DAG",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "graph",
              "type": "nx.DiGraph",
              "source": "complete_causal_dag"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 2,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "calculate_mechanism_strength",
        "args": [
          {
            "name": "mechanism",
            "type": "Dict",
            "source": "causal_mechanism"
          }
        ],
        "returns": {
          "type": "float",
          "binding": "mechanism_strength"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "calculate_mechanism_strength",
        "purpose": "Calculate individual mechanism strength",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "mechanism",
              "type": "Dict",
              "source": "causal_mechanism"
            }
          ],
          "return_type": "float",
          "source_file": "dereck_beach.py"
        }
      },
      {
        "step": 3,
        "adapter": "financial_viability",
        "adapter_class": "FinancialViabilityAdapter",
        "method": "estimate_causal_effects",
        "args": [
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "source": "financial_causal_dag"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "financial_effects"
        },
        "source_module": "financiero_viabilidad_tablas.py",
        "source_class": "FinancialViabilityAdapter",
        "source_method": "estimate_causal_effects",
        "purpose": "Estimate financial causal effects",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "graph",
              "type": "nx.DiGraph",
              "source": "financial_causal_dag"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "financiero_viabilidad_tablas.py"
        }
      },
      {
        "step": 4,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "sensitivity_analysis",
        "args": [
          {
            "name": "effects",
            "type": "List[Dict]",
            "source": "estimated_effects"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "sensitivity_results"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "sensitivity_analysis",
        "purpose": "Perform sensitivity analysis on causal effects",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "effects",
              "type": "List[Dict]",
              "source": "estimated_effects"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      }
    ],
    "contributing_modules": [
      "dereck_beach.py",
      "financiero_viabilidad_tablas.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "teoria_cambio",
    "evidence_types": [
      "estimated_effects",
      "financial_effects",
      "mechanism_strength",
      "sensitivity_results"
    ],
    "aggregation_strategy": "effect_estimation_synthesis",
    "confidence_threshold": 0.82,
    "total_steps": 4
  },
  "P3-D5-Q2": {
    "question_id": "P3-D5-Q2",
    "point": "P3",
    "dimension": "D5",
    "question_number": 2,
    "question_text": "Estimate causal effects and strengths",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "estimate_causal_effects",
        "args": [
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "source": "complete_causal_dag"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "estimated_effects"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "estimate_causal_effects",
        "purpose": "Estimate all causal effects in DAG",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "graph",
              "type": "nx.DiGraph",
              "source": "complete_causal_dag"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 2,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "calculate_mechanism_strength",
        "args": [
          {
            "name": "mechanism",
            "type": "Dict",
            "source": "causal_mechanism"
          }
        ],
        "returns": {
          "type": "float",
          "binding": "mechanism_strength"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "calculate_mechanism_strength",
        "purpose": "Calculate individual mechanism strength",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "mechanism",
              "type": "Dict",
              "source": "causal_mechanism"
            }
          ],
          "return_type": "float",
          "source_file": "dereck_beach.py"
        }
      },
      {
        "step": 3,
        "adapter": "financial_viability",
        "adapter_class": "FinancialViabilityAdapter",
        "method": "estimate_causal_effects",
        "args": [
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "source": "financial_causal_dag"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "financial_effects"
        },
        "source_module": "financiero_viabilidad_tablas.py",
        "source_class": "FinancialViabilityAdapter",
        "source_method": "estimate_causal_effects",
        "purpose": "Estimate financial causal effects",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "graph",
              "type": "nx.DiGraph",
              "source": "financial_causal_dag"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "financiero_viabilidad_tablas.py"
        }
      },
      {
        "step": 4,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "sensitivity_analysis",
        "args": [
          {
            "name": "effects",
            "type": "List[Dict]",
            "source": "estimated_effects"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "sensitivity_results"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "sensitivity_analysis",
        "purpose": "Perform sensitivity analysis on causal effects",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "effects",
              "type": "List[Dict]",
              "source": "estimated_effects"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      }
    ],
    "contributing_modules": [
      "dereck_beach.py",
      "financiero_viabilidad_tablas.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "teoria_cambio",
    "evidence_types": [
      "estimated_effects",
      "financial_effects",
      "mechanism_strength",
      "sensitivity_results"
    ],
    "aggregation_strategy": "effect_estimation_synthesis",
    "confidence_threshold": 0.82,
    "total_steps": 4
  },
  "P4-D5-Q2": {
    "question_id": "P4-D5-Q2",
    "point": "P4",
    "dimension": "D5",
    "question_number": 2,
    "question_text": "Estimate causal effects and strengths",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "estimate_causal_effects",
        "args": [
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "source": "complete_causal_dag"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "estimated_effects"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "estimate_causal_effects",
        "purpose": "Estimate all causal effects in DAG",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "graph",
              "type": "nx.DiGraph",
              "source": "complete_causal_dag"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 2,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "calculate_mechanism_strength",
        "args": [
          {
            "name": "mechanism",
            "type": "Dict",
            "source": "causal_mechanism"
          }
        ],
        "returns": {
          "type": "float",
          "binding": "mechanism_strength"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "calculate_mechanism_strength",
        "purpose": "Calculate individual mechanism strength",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "mechanism",
              "type": "Dict",
              "source": "causal_mechanism"
            }
          ],
          "return_type": "float",
          "source_file": "dereck_beach.py"
        }
      },
      {
        "step": 3,
        "adapter": "financial_viability",
        "adapter_class": "FinancialViabilityAdapter",
        "method": "estimate_causal_effects",
        "args": [
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "source": "financial_causal_dag"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "financial_effects"
        },
        "source_module": "financiero_viabilidad_tablas.py",
        "source_class": "FinancialViabilityAdapter",
        "source_method": "estimate_causal_effects",
        "purpose": "Estimate financial causal effects",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "graph",
              "type": "nx.DiGraph",
              "source": "financial_causal_dag"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "financiero_viabilidad_tablas.py"
        }
      },
      {
        "step": 4,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "sensitivity_analysis",
        "args": [
          {
            "name": "effects",
            "type": "List[Dict]",
            "source": "estimated_effects"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "sensitivity_results"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "sensitivity_analysis",
        "purpose": "Perform sensitivity analysis on causal effects",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "effects",
              "type": "List[Dict]",
              "source": "estimated_effects"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      }
    ],
    "contributing_modules": [
      "dereck_beach.py",
      "financiero_viabilidad_tablas.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "teoria_cambio",
    "evidence_types": [
      "estimated_effects",
      "financial_effects",
      "mechanism_strength",
      "sensitivity_results"
    ],
    "aggregation_strategy": "effect_estimation_synthesis",
    "confidence_threshold": 0.82,
    "total_steps": 4
  },
  "P5-D5-Q2": {
    "question_id": "P5-D5-Q2",
    "point": "P5",
    "dimension": "D5",
    "question_number": 2,
    "question_text": "Estimate causal effects and strengths",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "estimate_causal_effects",
        "args": [
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "source": "complete_causal_dag"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "estimated_effects"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "estimate_causal_effects",
        "purpose": "Estimate all causal effects in DAG",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "graph",
              "type": "nx.DiGraph",
              "source": "complete_causal_dag"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 2,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "calculate_mechanism_strength",
        "args": [
          {
            "name": "mechanism",
            "type": "Dict",
            "source": "causal_mechanism"
          }
        ],
        "returns": {
          "type": "float",
          "binding": "mechanism_strength"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "calculate_mechanism_strength",
        "purpose": "Calculate individual mechanism strength",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "mechanism",
              "type": "Dict",
              "source": "causal_mechanism"
            }
          ],
          "return_type": "float",
          "source_file": "dereck_beach.py"
        }
      },
      {
        "step": 3,
        "adapter": "financial_viability",
        "adapter_class": "FinancialViabilityAdapter",
        "method": "estimate_causal_effects",
        "args": [
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "source": "financial_causal_dag"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "financial_effects"
        },
        "source_module": "financiero_viabilidad_tablas.py",
        "source_class": "FinancialViabilityAdapter",
        "source_method": "estimate_causal_effects",
        "purpose": "Estimate financial causal effects",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "graph",
              "type": "nx.DiGraph",
              "source": "financial_causal_dag"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "financiero_viabilidad_tablas.py"
        }
      },
      {
        "step": 4,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "sensitivity_analysis",
        "args": [
          {
            "name": "effects",
            "type": "List[Dict]",
            "source": "estimated_effects"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "sensitivity_results"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "sensitivity_analysis",
        "purpose": "Perform sensitivity analysis on causal effects",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "effects",
              "type": "List[Dict]",
              "source": "estimated_effects"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      }
    ],
    "contributing_modules": [
      "dereck_beach.py",
      "financiero_viabilidad_tablas.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "teoria_cambio",
    "evidence_types": [
      "estimated_effects",
      "financial_effects",
      "mechanism_strength",
      "sensitivity_results"
    ],
    "aggregation_strategy": "effect_estimation_synthesis",
    "confidence_threshold": 0.82,
    "total_steps": 4
  },
  "P6-D5-Q2": {
    "question_id": "P6-D5-Q2",
    "point": "P6",
    "dimension": "D5",
    "question_number": 2,
    "question_text": "Estimate causal effects and strengths",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "estimate_causal_effects",
        "args": [
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "source": "complete_causal_dag"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "estimated_effects"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "estimate_causal_effects",
        "purpose": "Estimate all causal effects in DAG",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "graph",
              "type": "nx.DiGraph",
              "source": "complete_causal_dag"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 2,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "calculate_mechanism_strength",
        "args": [
          {
            "name": "mechanism",
            "type": "Dict",
            "source": "causal_mechanism"
          }
        ],
        "returns": {
          "type": "float",
          "binding": "mechanism_strength"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "calculate_mechanism_strength",
        "purpose": "Calculate individual mechanism strength",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "mechanism",
              "type": "Dict",
              "source": "causal_mechanism"
            }
          ],
          "return_type": "float",
          "source_file": "dereck_beach.py"
        }
      },
      {
        "step": 3,
        "adapter": "financial_viability",
        "adapter_class": "FinancialViabilityAdapter",
        "method": "estimate_causal_effects",
        "args": [
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "source": "financial_causal_dag"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "financial_effects"
        },
        "source_module": "financiero_viabilidad_tablas.py",
        "source_class": "FinancialViabilityAdapter",
        "source_method": "estimate_causal_effects",
        "purpose": "Estimate financial causal effects",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "graph",
              "type": "nx.DiGraph",
              "source": "financial_causal_dag"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "financiero_viabilidad_tablas.py"
        }
      },
      {
        "step": 4,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "sensitivity_analysis",
        "args": [
          {
            "name": "effects",
            "type": "List[Dict]",
            "source": "estimated_effects"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "sensitivity_results"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "sensitivity_analysis",
        "purpose": "Perform sensitivity analysis on causal effects",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "effects",
              "type": "List[Dict]",
              "source": "estimated_effects"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      }
    ],
    "contributing_modules": [
      "dereck_beach.py",
      "financiero_viabilidad_tablas.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "teoria_cambio",
    "evidence_types": [
      "estimated_effects",
      "financial_effects",
      "mechanism_strength",
      "sensitivity_results"
    ],
    "aggregation_strategy": "effect_estimation_synthesis",
    "confidence_threshold": 0.82,
    "total_steps": 4
  },
  "P7-D5-Q2": {
    "question_id": "P7-D5-Q2",
    "point": "P7",
    "dimension": "D5",
    "question_number": 2,
    "question_text": "Estimate causal effects and strengths",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "estimate_causal_effects",
        "args": [
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "source": "complete_causal_dag"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "estimated_effects"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "estimate_causal_effects",
        "purpose": "Estimate all causal effects in DAG",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "graph",
              "type": "nx.DiGraph",
              "source": "complete_causal_dag"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 2,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "calculate_mechanism_strength",
        "args": [
          {
            "name": "mechanism",
            "type": "Dict",
            "source": "causal_mechanism"
          }
        ],
        "returns": {
          "type": "float",
          "binding": "mechanism_strength"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "calculate_mechanism_strength",
        "purpose": "Calculate individual mechanism strength",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "mechanism",
              "type": "Dict",
              "source": "causal_mechanism"
            }
          ],
          "return_type": "float",
          "source_file": "dereck_beach.py"
        }
      },
      {
        "step": 3,
        "adapter": "financial_viability",
        "adapter_class": "FinancialViabilityAdapter",
        "method": "estimate_causal_effects",
        "args": [
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "source": "financial_causal_dag"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "financial_effects"
        },
        "source_module": "financiero_viabilidad_tablas.py",
        "source_class": "FinancialViabilityAdapter",
        "source_method": "estimate_causal_effects",
        "purpose": "Estimate financial causal effects",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "graph",
              "type": "nx.DiGraph",
              "source": "financial_causal_dag"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "financiero_viabilidad_tablas.py"
        }
      },
      {
        "step": 4,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "sensitivity_analysis",
        "args": [
          {
            "name": "effects",
            "type": "List[Dict]",
            "source": "estimated_effects"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "sensitivity_results"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "sensitivity_analysis",
        "purpose": "Perform sensitivity analysis on causal effects",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "effects",
              "type": "List[Dict]",
              "source": "estimated_effects"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      }
    ],
    "contributing_modules": [
      "dereck_beach.py",
      "financiero_viabilidad_tablas.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "teoria_cambio",
    "evidence_types": [
      "estimated_effects",
      "financial_effects",
      "mechanism_strength",
      "sensitivity_results"
    ],
    "aggregation_strategy": "effect_estimation_synthesis",
    "confidence_threshold": 0.82,
    "total_steps": 4
  },
  "P8-D5-Q2": {
    "question_id": "P8-D5-Q2",
    "point": "P8",
    "dimension": "D5",
    "question_number": 2,
    "question_text": "Estimate causal effects and strengths",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "estimate_causal_effects",
        "args": [
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "source": "complete_causal_dag"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "estimated_effects"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "estimate_causal_effects",
        "purpose": "Estimate all causal effects in DAG",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "graph",
              "type": "nx.DiGraph",
              "source": "complete_causal_dag"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 2,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "calculate_mechanism_strength",
        "args": [
          {
            "name": "mechanism",
            "type": "Dict",
            "source": "causal_mechanism"
          }
        ],
        "returns": {
          "type": "float",
          "binding": "mechanism_strength"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "calculate_mechanism_strength",
        "purpose": "Calculate individual mechanism strength",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "mechanism",
              "type": "Dict",
              "source": "causal_mechanism"
            }
          ],
          "return_type": "float",
          "source_file": "dereck_beach.py"
        }
      },
      {
        "step": 3,
        "adapter": "financial_viability",
        "adapter_class": "FinancialViabilityAdapter",
        "method": "estimate_causal_effects",
        "args": [
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "source": "financial_causal_dag"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "financial_effects"
        },
        "source_module": "financiero_viabilidad_tablas.py",
        "source_class": "FinancialViabilityAdapter",
        "source_method": "estimate_causal_effects",
        "purpose": "Estimate financial causal effects",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "graph",
              "type": "nx.DiGraph",
              "source": "financial_causal_dag"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "financiero_viabilidad_tablas.py"
        }
      },
      {
        "step": 4,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "sensitivity_analysis",
        "args": [
          {
            "name": "effects",
            "type": "List[Dict]",
            "source": "estimated_effects"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "sensitivity_results"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "sensitivity_analysis",
        "purpose": "Perform sensitivity analysis on causal effects",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "effects",
              "type": "List[Dict]",
              "source": "estimated_effects"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      }
    ],
    "contributing_modules": [
      "dereck_beach.py",
      "financiero_viabilidad_tablas.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "teoria_cambio",
    "evidence_types": [
      "estimated_effects",
      "financial_effects",
      "mechanism_strength",
      "sensitivity_results"
    ],
    "aggregation_strategy": "effect_estimation_synthesis",
    "confidence_threshold": 0.82,
    "total_steps": 4
  },
  "P9-D5-Q2": {
    "question_id": "P9-D5-Q2",
    "point": "P9",
    "dimension": "D5",
    "question_number": 2,
    "question_text": "Estimate causal effects and strengths",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "estimate_causal_effects",
        "args": [
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "source": "complete_causal_dag"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "estimated_effects"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "estimate_causal_effects",
        "purpose": "Estimate all causal effects in DAG",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "graph",
              "type": "nx.DiGraph",
              "source": "complete_causal_dag"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 2,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "calculate_mechanism_strength",
        "args": [
          {
            "name": "mechanism",
            "type": "Dict",
            "source": "causal_mechanism"
          }
        ],
        "returns": {
          "type": "float",
          "binding": "mechanism_strength"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "calculate_mechanism_strength",
        "purpose": "Calculate individual mechanism strength",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "mechanism",
              "type": "Dict",
              "source": "causal_mechanism"
            }
          ],
          "return_type": "float",
          "source_file": "dereck_beach.py"
        }
      },
      {
        "step": 3,
        "adapter": "financial_viability",
        "adapter_class": "FinancialViabilityAdapter",
        "method": "estimate_causal_effects",
        "args": [
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "source": "financial_causal_dag"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "financial_effects"
        },
        "source_module": "financiero_viabilidad_tablas.py",
        "source_class": "FinancialViabilityAdapter",
        "source_method": "estimate_causal_effects",
        "purpose": "Estimate financial causal effects",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "graph",
              "type": "nx.DiGraph",
              "source": "financial_causal_dag"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "financiero_viabilidad_tablas.py"
        }
      },
      {
        "step": 4,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "sensitivity_analysis",
        "args": [
          {
            "name": "effects",
            "type": "List[Dict]",
            "source": "estimated_effects"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "sensitivity_results"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "sensitivity_analysis",
        "purpose": "Perform sensitivity analysis on causal effects",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "effects",
              "type": "List[Dict]",
              "source": "estimated_effects"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      }
    ],
    "contributing_modules": [
      "dereck_beach.py",
      "financiero_viabilidad_tablas.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "teoria_cambio",
    "evidence_types": [
      "estimated_effects",
      "financial_effects",
      "mechanism_strength",
      "sensitivity_results"
    ],
    "aggregation_strategy": "effect_estimation_synthesis",
    "confidence_threshold": 0.82,
    "total_steps": 4
  },
  "P10-D5-Q2": {
    "question_id": "P10-D5-Q2",
    "point": "P10",
    "dimension": "D5",
    "question_number": 2,
    "question_text": "Estimate causal effects and strengths",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "estimate_causal_effects",
        "args": [
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "source": "complete_causal_dag"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "estimated_effects"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "estimate_causal_effects",
        "purpose": "Estimate all causal effects in DAG",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "graph",
              "type": "nx.DiGraph",
              "source": "complete_causal_dag"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 2,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "calculate_mechanism_strength",
        "args": [
          {
            "name": "mechanism",
            "type": "Dict",
            "source": "causal_mechanism"
          }
        ],
        "returns": {
          "type": "float",
          "binding": "mechanism_strength"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "calculate_mechanism_strength",
        "purpose": "Calculate individual mechanism strength",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "mechanism",
              "type": "Dict",
              "source": "causal_mechanism"
            }
          ],
          "return_type": "float",
          "source_file": "dereck_beach.py"
        }
      },
      {
        "step": 3,
        "adapter": "financial_viability",
        "adapter_class": "FinancialViabilityAdapter",
        "method": "estimate_causal_effects",
        "args": [
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "source": "financial_causal_dag"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "financial_effects"
        },
        "source_module": "financiero_viabilidad_tablas.py",
        "source_class": "FinancialViabilityAdapter",
        "source_method": "estimate_causal_effects",
        "purpose": "Estimate financial causal effects",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "graph",
              "type": "nx.DiGraph",
              "source": "financial_causal_dag"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "financiero_viabilidad_tablas.py"
        }
      },
      {
        "step": 4,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "sensitivity_analysis",
        "args": [
          {
            "name": "effects",
            "type": "List[Dict]",
            "source": "estimated_effects"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "sensitivity_results"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "sensitivity_analysis",
        "purpose": "Perform sensitivity analysis on causal effects",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "effects",
              "type": "List[Dict]",
              "source": "estimated_effects"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      }
    ],
    "contributing_modules": [
      "dereck_beach.py",
      "financiero_viabilidad_tablas.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "teoria_cambio",
    "evidence_types": [
      "estimated_effects",
      "financial_effects",
      "mechanism_strength",
      "sensitivity_results"
    ],
    "aggregation_strategy": "effect_estimation_synthesis",
    "confidence_threshold": 0.82,
    "total_steps": 4
  },
  "P1-D5-Q3": {
    "question_id": "P1-D5-Q3",
    "point": "P1",
    "dimension": "D5",
    "question_number": 3,
    "question_text": "Test causal assumptions and identify confounders",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "identify_confounders",
        "args": [
          {
            "name": "source",
            "type": "str",
            "source": "cause_variable"
          },
          {
            "name": "target",
            "type": "str",
            "source": "effect_variable"
          },
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "source": "complete_causal_dag"
          }
        ],
        "returns": {
          "type": "List",
          "binding": "identified_confounders"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "identify_confounders",
        "purpose": "Identify potential confounding variables",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "source",
              "type": "str",
              "source": "cause_variable"
            },
            {
              "name": "target",
              "type": "str",
              "source": "effect_variable"
            },
            {
              "name": "graph",
              "type": "nx.DiGraph",
              "source": "complete_causal_dag"
            }
          ],
          "return_type": "List",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 2,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "test_causal_assumptions",
        "args": [
          {
            "name": "mechanism",
            "type": "Dict",
            "source": "causal_mechanism"
          },
          {
            "name": "evidence",
            "type": "List[Dict]",
            "source": "empirical_evidence"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "assumption_tests"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "test_causal_assumptions",
        "purpose": "Test causal assumptions against evidence",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "mechanism",
              "type": "Dict",
              "source": "causal_mechanism"
            },
            {
              "name": "evidence",
              "type": "List[Dict]",
              "source": "empirical_evidence"
            }
          ],
          "return_type": "Dict",
          "source_file": "dereck_beach.py"
        }
      },
      {
        "step": 3,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_has_logical_conflict",
        "args": [
          {
            "name": "stmt1",
            "type": "Dict",
            "source": "assumption1"
          },
          {
            "name": "stmt2",
            "type": "Dict",
            "source": "assumption2"
          }
        ],
        "returns": {
          "type": "bool",
          "binding": "assumption_conflict"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_has_logical_conflict",
        "purpose": "Check for logical conflicts in assumptions",
        "confidence_expected": 0.9,
        "signature": {
          "parameters": [
            {
              "name": "stmt1",
              "type": "Dict",
              "source": "assumption1"
            },
            {
              "name": "stmt2",
              "type": "Dict",
              "source": "assumption2"
            }
          ],
          "return_type": "bool",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 4,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "update_with_evidence",
        "args": [
          {
            "name": "hypothesis",
            "type": "Dict",
            "source": "causal_hypothesis"
          },
          {
            "name": "evidence",
            "type": "List",
            "source": "new_evidence"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "updated_belief"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "update_with_evidence",
        "purpose": "Update causal beliefs with new evidence",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "hypothesis",
              "type": "Dict",
              "source": "causal_hypothesis"
            },
            {
              "name": "evidence",
              "type": "List",
              "source": "new_evidence"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      }
    ],
    "contributing_modules": [
      "contradiction_deteccion.py",
      "dereck_beach.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "teoria_cambio",
    "evidence_types": [
      "assumption_conflict",
      "assumption_tests",
      "identified_confounders",
      "updated_belief"
    ],
    "aggregation_strategy": "assumption_validation",
    "confidence_threshold": 0.8,
    "total_steps": 4
  },
  "P2-D5-Q3": {
    "question_id": "P2-D5-Q3",
    "point": "P2",
    "dimension": "D5",
    "question_number": 3,
    "question_text": "Test causal assumptions and identify confounders",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "identify_confounders",
        "args": [
          {
            "name": "source",
            "type": "str",
            "source": "cause_variable"
          },
          {
            "name": "target",
            "type": "str",
            "source": "effect_variable"
          },
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "source": "complete_causal_dag"
          }
        ],
        "returns": {
          "type": "List",
          "binding": "identified_confounders"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "identify_confounders",
        "purpose": "Identify potential confounding variables",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "source",
              "type": "str",
              "source": "cause_variable"
            },
            {
              "name": "target",
              "type": "str",
              "source": "effect_variable"
            },
            {
              "name": "graph",
              "type": "nx.DiGraph",
              "source": "complete_causal_dag"
            }
          ],
          "return_type": "List",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 2,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "test_causal_assumptions",
        "args": [
          {
            "name": "mechanism",
            "type": "Dict",
            "source": "causal_mechanism"
          },
          {
            "name": "evidence",
            "type": "List[Dict]",
            "source": "empirical_evidence"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "assumption_tests"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "test_causal_assumptions",
        "purpose": "Test causal assumptions against evidence",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "mechanism",
              "type": "Dict",
              "source": "causal_mechanism"
            },
            {
              "name": "evidence",
              "type": "List[Dict]",
              "source": "empirical_evidence"
            }
          ],
          "return_type": "Dict",
          "source_file": "dereck_beach.py"
        }
      },
      {
        "step": 3,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_has_logical_conflict",
        "args": [
          {
            "name": "stmt1",
            "type": "Dict",
            "source": "assumption1"
          },
          {
            "name": "stmt2",
            "type": "Dict",
            "source": "assumption2"
          }
        ],
        "returns": {
          "type": "bool",
          "binding": "assumption_conflict"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_has_logical_conflict",
        "purpose": "Check for logical conflicts in assumptions",
        "confidence_expected": 0.9,
        "signature": {
          "parameters": [
            {
              "name": "stmt1",
              "type": "Dict",
              "source": "assumption1"
            },
            {
              "name": "stmt2",
              "type": "Dict",
              "source": "assumption2"
            }
          ],
          "return_type": "bool",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 4,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "update_with_evidence",
        "args": [
          {
            "name": "hypothesis",
            "type": "Dict",
            "source": "causal_hypothesis"
          },
          {
            "name": "evidence",
            "type": "List",
            "source": "new_evidence"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "updated_belief"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "update_with_evidence",
        "purpose": "Update causal beliefs with new evidence",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "hypothesis",
              "type": "Dict",
              "source": "causal_hypothesis"
            },
            {
              "name": "evidence",
              "type": "List",
              "source": "new_evidence"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      }
    ],
    "contributing_modules": [
      "contradiction_deteccion.py",
      "dereck_beach.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "teoria_cambio",
    "evidence_types": [
      "assumption_conflict",
      "assumption_tests",
      "identified_confounders",
      "updated_belief"
    ],
    "aggregation_strategy": "assumption_validation",
    "confidence_threshold": 0.8,
    "total_steps": 4
  },
  "P3-D5-Q3": {
    "question_id": "P3-D5-Q3",
    "point": "P3",
    "dimension": "D5",
    "question_number": 3,
    "question_text": "Test causal assumptions and identify confounders",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "identify_confounders",
        "args": [
          {
            "name": "source",
            "type": "str",
            "source": "cause_variable"
          },
          {
            "name": "target",
            "type": "str",
            "source": "effect_variable"
          },
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "source": "complete_causal_dag"
          }
        ],
        "returns": {
          "type": "List",
          "binding": "identified_confounders"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "identify_confounders",
        "purpose": "Identify potential confounding variables",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "source",
              "type": "str",
              "source": "cause_variable"
            },
            {
              "name": "target",
              "type": "str",
              "source": "effect_variable"
            },
            {
              "name": "graph",
              "type": "nx.DiGraph",
              "source": "complete_causal_dag"
            }
          ],
          "return_type": "List",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 2,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "test_causal_assumptions",
        "args": [
          {
            "name": "mechanism",
            "type": "Dict",
            "source": "causal_mechanism"
          },
          {
            "name": "evidence",
            "type": "List[Dict]",
            "source": "empirical_evidence"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "assumption_tests"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "test_causal_assumptions",
        "purpose": "Test causal assumptions against evidence",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "mechanism",
              "type": "Dict",
              "source": "causal_mechanism"
            },
            {
              "name": "evidence",
              "type": "List[Dict]",
              "source": "empirical_evidence"
            }
          ],
          "return_type": "Dict",
          "source_file": "dereck_beach.py"
        }
      },
      {
        "step": 3,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_has_logical_conflict",
        "args": [
          {
            "name": "stmt1",
            "type": "Dict",
            "source": "assumption1"
          },
          {
            "name": "stmt2",
            "type": "Dict",
            "source": "assumption2"
          }
        ],
        "returns": {
          "type": "bool",
          "binding": "assumption_conflict"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_has_logical_conflict",
        "purpose": "Check for logical conflicts in assumptions",
        "confidence_expected": 0.9,
        "signature": {
          "parameters": [
            {
              "name": "stmt1",
              "type": "Dict",
              "source": "assumption1"
            },
            {
              "name": "stmt2",
              "type": "Dict",
              "source": "assumption2"
            }
          ],
          "return_type": "bool",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 4,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "update_with_evidence",
        "args": [
          {
            "name": "hypothesis",
            "type": "Dict",
            "source": "causal_hypothesis"
          },
          {
            "name": "evidence",
            "type": "List",
            "source": "new_evidence"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "updated_belief"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "update_with_evidence",
        "purpose": "Update causal beliefs with new evidence",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "hypothesis",
              "type": "Dict",
              "source": "causal_hypothesis"
            },
            {
              "name": "evidence",
              "type": "List",
              "source": "new_evidence"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      }
    ],
    "contributing_modules": [
      "contradiction_deteccion.py",
      "dereck_beach.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "teoria_cambio",
    "evidence_types": [
      "assumption_conflict",
      "assumption_tests",
      "identified_confounders",
      "updated_belief"
    ],
    "aggregation_strategy": "assumption_validation",
    "confidence_threshold": 0.8,
    "total_steps": 4
  },
  "P4-D5-Q3": {
    "question_id": "P4-D5-Q3",
    "point": "P4",
    "dimension": "D5",
    "question_number": 3,
    "question_text": "Test causal assumptions and identify confounders",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "identify_confounders",
        "args": [
          {
            "name": "source",
            "type": "str",
            "source": "cause_variable"
          },
          {
            "name": "target",
            "type": "str",
            "source": "effect_variable"
          },
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "source": "complete_causal_dag"
          }
        ],
        "returns": {
          "type": "List",
          "binding": "identified_confounders"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "identify_confounders",
        "purpose": "Identify potential confounding variables",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "source",
              "type": "str",
              "source": "cause_variable"
            },
            {
              "name": "target",
              "type": "str",
              "source": "effect_variable"
            },
            {
              "name": "graph",
              "type": "nx.DiGraph",
              "source": "complete_causal_dag"
            }
          ],
          "return_type": "List",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 2,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "test_causal_assumptions",
        "args": [
          {
            "name": "mechanism",
            "type": "Dict",
            "source": "causal_mechanism"
          },
          {
            "name": "evidence",
            "type": "List[Dict]",
            "source": "empirical_evidence"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "assumption_tests"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "test_causal_assumptions",
        "purpose": "Test causal assumptions against evidence",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "mechanism",
              "type": "Dict",
              "source": "causal_mechanism"
            },
            {
              "name": "evidence",
              "type": "List[Dict]",
              "source": "empirical_evidence"
            }
          ],
          "return_type": "Dict",
          "source_file": "dereck_beach.py"
        }
      },
      {
        "step": 3,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_has_logical_conflict",
        "args": [
          {
            "name": "stmt1",
            "type": "Dict",
            "source": "assumption1"
          },
          {
            "name": "stmt2",
            "type": "Dict",
            "source": "assumption2"
          }
        ],
        "returns": {
          "type": "bool",
          "binding": "assumption_conflict"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_has_logical_conflict",
        "purpose": "Check for logical conflicts in assumptions",
        "confidence_expected": 0.9,
        "signature": {
          "parameters": [
            {
              "name": "stmt1",
              "type": "Dict",
              "source": "assumption1"
            },
            {
              "name": "stmt2",
              "type": "Dict",
              "source": "assumption2"
            }
          ],
          "return_type": "bool",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 4,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "update_with_evidence",
        "args": [
          {
            "name": "hypothesis",
            "type": "Dict",
            "source": "causal_hypothesis"
          },
          {
            "name": "evidence",
            "type": "List",
            "source": "new_evidence"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "updated_belief"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "update_with_evidence",
        "purpose": "Update causal beliefs with new evidence",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "hypothesis",
              "type": "Dict",
              "source": "causal_hypothesis"
            },
            {
              "name": "evidence",
              "type": "List",
              "source": "new_evidence"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      }
    ],
    "contributing_modules": [
      "contradiction_deteccion.py",
      "dereck_beach.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "teoria_cambio",
    "evidence_types": [
      "assumption_conflict",
      "assumption_tests",
      "identified_confounders",
      "updated_belief"
    ],
    "aggregation_strategy": "assumption_validation",
    "confidence_threshold": 0.8,
    "total_steps": 4
  },
  "P5-D5-Q3": {
    "question_id": "P5-D5-Q3",
    "point": "P5",
    "dimension": "D5",
    "question_number": 3,
    "question_text": "Test causal assumptions and identify confounders",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "identify_confounders",
        "args": [
          {
            "name": "source",
            "type": "str",
            "source": "cause_variable"
          },
          {
            "name": "target",
            "type": "str",
            "source": "effect_variable"
          },
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "source": "complete_causal_dag"
          }
        ],
        "returns": {
          "type": "List",
          "binding": "identified_confounders"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "identify_confounders",
        "purpose": "Identify potential confounding variables",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "source",
              "type": "str",
              "source": "cause_variable"
            },
            {
              "name": "target",
              "type": "str",
              "source": "effect_variable"
            },
            {
              "name": "graph",
              "type": "nx.DiGraph",
              "source": "complete_causal_dag"
            }
          ],
          "return_type": "List",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 2,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "test_causal_assumptions",
        "args": [
          {
            "name": "mechanism",
            "type": "Dict",
            "source": "causal_mechanism"
          },
          {
            "name": "evidence",
            "type": "List[Dict]",
            "source": "empirical_evidence"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "assumption_tests"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "test_causal_assumptions",
        "purpose": "Test causal assumptions against evidence",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "mechanism",
              "type": "Dict",
              "source": "causal_mechanism"
            },
            {
              "name": "evidence",
              "type": "List[Dict]",
              "source": "empirical_evidence"
            }
          ],
          "return_type": "Dict",
          "source_file": "dereck_beach.py"
        }
      },
      {
        "step": 3,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_has_logical_conflict",
        "args": [
          {
            "name": "stmt1",
            "type": "Dict",
            "source": "assumption1"
          },
          {
            "name": "stmt2",
            "type": "Dict",
            "source": "assumption2"
          }
        ],
        "returns": {
          "type": "bool",
          "binding": "assumption_conflict"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_has_logical_conflict",
        "purpose": "Check for logical conflicts in assumptions",
        "confidence_expected": 0.9,
        "signature": {
          "parameters": [
            {
              "name": "stmt1",
              "type": "Dict",
              "source": "assumption1"
            },
            {
              "name": "stmt2",
              "type": "Dict",
              "source": "assumption2"
            }
          ],
          "return_type": "bool",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 4,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "update_with_evidence",
        "args": [
          {
            "name": "hypothesis",
            "type": "Dict",
            "source": "causal_hypothesis"
          },
          {
            "name": "evidence",
            "type": "List",
            "source": "new_evidence"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "updated_belief"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "update_with_evidence",
        "purpose": "Update causal beliefs with new evidence",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "hypothesis",
              "type": "Dict",
              "source": "causal_hypothesis"
            },
            {
              "name": "evidence",
              "type": "List",
              "source": "new_evidence"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      }
    ],
    "contributing_modules": [
      "contradiction_deteccion.py",
      "dereck_beach.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "teoria_cambio",
    "evidence_types": [
      "assumption_conflict",
      "assumption_tests",
      "identified_confounders",
      "updated_belief"
    ],
    "aggregation_strategy": "assumption_validation",
    "confidence_threshold": 0.8,
    "total_steps": 4
  },
  "P6-D5-Q3": {
    "question_id": "P6-D5-Q3",
    "point": "P6",
    "dimension": "D5",
    "question_number": 3,
    "question_text": "Test causal assumptions and identify confounders",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "identify_confounders",
        "args": [
          {
            "name": "source",
            "type": "str",
            "source": "cause_variable"
          },
          {
            "name": "target",
            "type": "str",
            "source": "effect_variable"
          },
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "source": "complete_causal_dag"
          }
        ],
        "returns": {
          "type": "List",
          "binding": "identified_confounders"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "identify_confounders",
        "purpose": "Identify potential confounding variables",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "source",
              "type": "str",
              "source": "cause_variable"
            },
            {
              "name": "target",
              "type": "str",
              "source": "effect_variable"
            },
            {
              "name": "graph",
              "type": "nx.DiGraph",
              "source": "complete_causal_dag"
            }
          ],
          "return_type": "List",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 2,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "test_causal_assumptions",
        "args": [
          {
            "name": "mechanism",
            "type": "Dict",
            "source": "causal_mechanism"
          },
          {
            "name": "evidence",
            "type": "List[Dict]",
            "source": "empirical_evidence"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "assumption_tests"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "test_causal_assumptions",
        "purpose": "Test causal assumptions against evidence",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "mechanism",
              "type": "Dict",
              "source": "causal_mechanism"
            },
            {
              "name": "evidence",
              "type": "List[Dict]",
              "source": "empirical_evidence"
            }
          ],
          "return_type": "Dict",
          "source_file": "dereck_beach.py"
        }
      },
      {
        "step": 3,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_has_logical_conflict",
        "args": [
          {
            "name": "stmt1",
            "type": "Dict",
            "source": "assumption1"
          },
          {
            "name": "stmt2",
            "type": "Dict",
            "source": "assumption2"
          }
        ],
        "returns": {
          "type": "bool",
          "binding": "assumption_conflict"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_has_logical_conflict",
        "purpose": "Check for logical conflicts in assumptions",
        "confidence_expected": 0.9,
        "signature": {
          "parameters": [
            {
              "name": "stmt1",
              "type": "Dict",
              "source": "assumption1"
            },
            {
              "name": "stmt2",
              "type": "Dict",
              "source": "assumption2"
            }
          ],
          "return_type": "bool",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 4,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "update_with_evidence",
        "args": [
          {
            "name": "hypothesis",
            "type": "Dict",
            "source": "causal_hypothesis"
          },
          {
            "name": "evidence",
            "type": "List",
            "source": "new_evidence"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "updated_belief"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "update_with_evidence",
        "purpose": "Update causal beliefs with new evidence",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "hypothesis",
              "type": "Dict",
              "source": "causal_hypothesis"
            },
            {
              "name": "evidence",
              "type": "List",
              "source": "new_evidence"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      }
    ],
    "contributing_modules": [
      "contradiction_deteccion.py",
      "dereck_beach.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "teoria_cambio",
    "evidence_types": [
      "assumption_conflict",
      "assumption_tests",
      "identified_confounders",
      "updated_belief"
    ],
    "aggregation_strategy": "assumption_validation",
    "confidence_threshold": 0.8,
    "total_steps": 4
  },
  "P7-D5-Q3": {
    "question_id": "P7-D5-Q3",
    "point": "P7",
    "dimension": "D5",
    "question_number": 3,
    "question_text": "Test causal assumptions and identify confounders",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "identify_confounders",
        "args": [
          {
            "name": "source",
            "type": "str",
            "source": "cause_variable"
          },
          {
            "name": "target",
            "type": "str",
            "source": "effect_variable"
          },
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "source": "complete_causal_dag"
          }
        ],
        "returns": {
          "type": "List",
          "binding": "identified_confounders"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "identify_confounders",
        "purpose": "Identify potential confounding variables",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "source",
              "type": "str",
              "source": "cause_variable"
            },
            {
              "name": "target",
              "type": "str",
              "source": "effect_variable"
            },
            {
              "name": "graph",
              "type": "nx.DiGraph",
              "source": "complete_causal_dag"
            }
          ],
          "return_type": "List",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 2,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "test_causal_assumptions",
        "args": [
          {
            "name": "mechanism",
            "type": "Dict",
            "source": "causal_mechanism"
          },
          {
            "name": "evidence",
            "type": "List[Dict]",
            "source": "empirical_evidence"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "assumption_tests"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "test_causal_assumptions",
        "purpose": "Test causal assumptions against evidence",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "mechanism",
              "type": "Dict",
              "source": "causal_mechanism"
            },
            {
              "name": "evidence",
              "type": "List[Dict]",
              "source": "empirical_evidence"
            }
          ],
          "return_type": "Dict",
          "source_file": "dereck_beach.py"
        }
      },
      {
        "step": 3,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_has_logical_conflict",
        "args": [
          {
            "name": "stmt1",
            "type": "Dict",
            "source": "assumption1"
          },
          {
            "name": "stmt2",
            "type": "Dict",
            "source": "assumption2"
          }
        ],
        "returns": {
          "type": "bool",
          "binding": "assumption_conflict"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_has_logical_conflict",
        "purpose": "Check for logical conflicts in assumptions",
        "confidence_expected": 0.9,
        "signature": {
          "parameters": [
            {
              "name": "stmt1",
              "type": "Dict",
              "source": "assumption1"
            },
            {
              "name": "stmt2",
              "type": "Dict",
              "source": "assumption2"
            }
          ],
          "return_type": "bool",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 4,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "update_with_evidence",
        "args": [
          {
            "name": "hypothesis",
            "type": "Dict",
            "source": "causal_hypothesis"
          },
          {
            "name": "evidence",
            "type": "List",
            "source": "new_evidence"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "updated_belief"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "update_with_evidence",
        "purpose": "Update causal beliefs with new evidence",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "hypothesis",
              "type": "Dict",
              "source": "causal_hypothesis"
            },
            {
              "name": "evidence",
              "type": "List",
              "source": "new_evidence"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      }
    ],
    "contributing_modules": [
      "contradiction_deteccion.py",
      "dereck_beach.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "teoria_cambio",
    "evidence_types": [
      "assumption_conflict",
      "assumption_tests",
      "identified_confounders",
      "updated_belief"
    ],
    "aggregation_strategy": "assumption_validation",
    "confidence_threshold": 0.8,
    "total_steps": 4
  },
  "P8-D5-Q3": {
    "question_id": "P8-D5-Q3",
    "point": "P8",
    "dimension": "D5",
    "question_number": 3,
    "question_text": "Test causal assumptions and identify confounders",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "identify_confounders",
        "args": [
          {
            "name": "source",
            "type": "str",
            "source": "cause_variable"
          },
          {
            "name": "target",
            "type": "str",
            "source": "effect_variable"
          },
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "source": "complete_causal_dag"
          }
        ],
        "returns": {
          "type": "List",
          "binding": "identified_confounders"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "identify_confounders",
        "purpose": "Identify potential confounding variables",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "source",
              "type": "str",
              "source": "cause_variable"
            },
            {
              "name": "target",
              "type": "str",
              "source": "effect_variable"
            },
            {
              "name": "graph",
              "type": "nx.DiGraph",
              "source": "complete_causal_dag"
            }
          ],
          "return_type": "List",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 2,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "test_causal_assumptions",
        "args": [
          {
            "name": "mechanism",
            "type": "Dict",
            "source": "causal_mechanism"
          },
          {
            "name": "evidence",
            "type": "List[Dict]",
            "source": "empirical_evidence"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "assumption_tests"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "test_causal_assumptions",
        "purpose": "Test causal assumptions against evidence",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "mechanism",
              "type": "Dict",
              "source": "causal_mechanism"
            },
            {
              "name": "evidence",
              "type": "List[Dict]",
              "source": "empirical_evidence"
            }
          ],
          "return_type": "Dict",
          "source_file": "dereck_beach.py"
        }
      },
      {
        "step": 3,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_has_logical_conflict",
        "args": [
          {
            "name": "stmt1",
            "type": "Dict",
            "source": "assumption1"
          },
          {
            "name": "stmt2",
            "type": "Dict",
            "source": "assumption2"
          }
        ],
        "returns": {
          "type": "bool",
          "binding": "assumption_conflict"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_has_logical_conflict",
        "purpose": "Check for logical conflicts in assumptions",
        "confidence_expected": 0.9,
        "signature": {
          "parameters": [
            {
              "name": "stmt1",
              "type": "Dict",
              "source": "assumption1"
            },
            {
              "name": "stmt2",
              "type": "Dict",
              "source": "assumption2"
            }
          ],
          "return_type": "bool",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 4,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "update_with_evidence",
        "args": [
          {
            "name": "hypothesis",
            "type": "Dict",
            "source": "causal_hypothesis"
          },
          {
            "name": "evidence",
            "type": "List",
            "source": "new_evidence"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "updated_belief"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "update_with_evidence",
        "purpose": "Update causal beliefs with new evidence",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "hypothesis",
              "type": "Dict",
              "source": "causal_hypothesis"
            },
            {
              "name": "evidence",
              "type": "List",
              "source": "new_evidence"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      }
    ],
    "contributing_modules": [
      "contradiction_deteccion.py",
      "dereck_beach.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "teoria_cambio",
    "evidence_types": [
      "assumption_conflict",
      "assumption_tests",
      "identified_confounders",
      "updated_belief"
    ],
    "aggregation_strategy": "assumption_validation",
    "confidence_threshold": 0.8,
    "total_steps": 4
  },
  "P9-D5-Q3": {
    "question_id": "P9-D5-Q3",
    "point": "P9",
    "dimension": "D5",
    "question_number": 3,
    "question_text": "Test causal assumptions and identify confounders",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "identify_confounders",
        "args": [
          {
            "name": "source",
            "type": "str",
            "source": "cause_variable"
          },
          {
            "name": "target",
            "type": "str",
            "source": "effect_variable"
          },
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "source": "complete_causal_dag"
          }
        ],
        "returns": {
          "type": "List",
          "binding": "identified_confounders"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "identify_confounders",
        "purpose": "Identify potential confounding variables",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "source",
              "type": "str",
              "source": "cause_variable"
            },
            {
              "name": "target",
              "type": "str",
              "source": "effect_variable"
            },
            {
              "name": "graph",
              "type": "nx.DiGraph",
              "source": "complete_causal_dag"
            }
          ],
          "return_type": "List",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 2,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "test_causal_assumptions",
        "args": [
          {
            "name": "mechanism",
            "type": "Dict",
            "source": "causal_mechanism"
          },
          {
            "name": "evidence",
            "type": "List[Dict]",
            "source": "empirical_evidence"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "assumption_tests"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "test_causal_assumptions",
        "purpose": "Test causal assumptions against evidence",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "mechanism",
              "type": "Dict",
              "source": "causal_mechanism"
            },
            {
              "name": "evidence",
              "type": "List[Dict]",
              "source": "empirical_evidence"
            }
          ],
          "return_type": "Dict",
          "source_file": "dereck_beach.py"
        }
      },
      {
        "step": 3,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_has_logical_conflict",
        "args": [
          {
            "name": "stmt1",
            "type": "Dict",
            "source": "assumption1"
          },
          {
            "name": "stmt2",
            "type": "Dict",
            "source": "assumption2"
          }
        ],
        "returns": {
          "type": "bool",
          "binding": "assumption_conflict"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_has_logical_conflict",
        "purpose": "Check for logical conflicts in assumptions",
        "confidence_expected": 0.9,
        "signature": {
          "parameters": [
            {
              "name": "stmt1",
              "type": "Dict",
              "source": "assumption1"
            },
            {
              "name": "stmt2",
              "type": "Dict",
              "source": "assumption2"
            }
          ],
          "return_type": "bool",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 4,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "update_with_evidence",
        "args": [
          {
            "name": "hypothesis",
            "type": "Dict",
            "source": "causal_hypothesis"
          },
          {
            "name": "evidence",
            "type": "List",
            "source": "new_evidence"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "updated_belief"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "update_with_evidence",
        "purpose": "Update causal beliefs with new evidence",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "hypothesis",
              "type": "Dict",
              "source": "causal_hypothesis"
            },
            {
              "name": "evidence",
              "type": "List",
              "source": "new_evidence"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      }
    ],
    "contributing_modules": [
      "contradiction_deteccion.py",
      "dereck_beach.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "teoria_cambio",
    "evidence_types": [
      "assumption_conflict",
      "assumption_tests",
      "identified_confounders",
      "updated_belief"
    ],
    "aggregation_strategy": "assumption_validation",
    "confidence_threshold": 0.8,
    "total_steps": 4
  },
  "P10-D5-Q3": {
    "question_id": "P10-D5-Q3",
    "point": "P10",
    "dimension": "D5",
    "question_number": 3,
    "question_text": "Test causal assumptions and identify confounders",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "identify_confounders",
        "args": [
          {
            "name": "source",
            "type": "str",
            "source": "cause_variable"
          },
          {
            "name": "target",
            "type": "str",
            "source": "effect_variable"
          },
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "source": "complete_causal_dag"
          }
        ],
        "returns": {
          "type": "List",
          "binding": "identified_confounders"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "identify_confounders",
        "purpose": "Identify potential confounding variables",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "source",
              "type": "str",
              "source": "cause_variable"
            },
            {
              "name": "target",
              "type": "str",
              "source": "effect_variable"
            },
            {
              "name": "graph",
              "type": "nx.DiGraph",
              "source": "complete_causal_dag"
            }
          ],
          "return_type": "List",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 2,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "test_causal_assumptions",
        "args": [
          {
            "name": "mechanism",
            "type": "Dict",
            "source": "causal_mechanism"
          },
          {
            "name": "evidence",
            "type": "List[Dict]",
            "source": "empirical_evidence"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "assumption_tests"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "test_causal_assumptions",
        "purpose": "Test causal assumptions against evidence",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "mechanism",
              "type": "Dict",
              "source": "causal_mechanism"
            },
            {
              "name": "evidence",
              "type": "List[Dict]",
              "source": "empirical_evidence"
            }
          ],
          "return_type": "Dict",
          "source_file": "dereck_beach.py"
        }
      },
      {
        "step": 3,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_has_logical_conflict",
        "args": [
          {
            "name": "stmt1",
            "type": "Dict",
            "source": "assumption1"
          },
          {
            "name": "stmt2",
            "type": "Dict",
            "source": "assumption2"
          }
        ],
        "returns": {
          "type": "bool",
          "binding": "assumption_conflict"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_has_logical_conflict",
        "purpose": "Check for logical conflicts in assumptions",
        "confidence_expected": 0.9,
        "signature": {
          "parameters": [
            {
              "name": "stmt1",
              "type": "Dict",
              "source": "assumption1"
            },
            {
              "name": "stmt2",
              "type": "Dict",
              "source": "assumption2"
            }
          ],
          "return_type": "bool",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 4,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "update_with_evidence",
        "args": [
          {
            "name": "hypothesis",
            "type": "Dict",
            "source": "causal_hypothesis"
          },
          {
            "name": "evidence",
            "type": "List",
            "source": "new_evidence"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "updated_belief"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "update_with_evidence",
        "purpose": "Update causal beliefs with new evidence",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "hypothesis",
              "type": "Dict",
              "source": "causal_hypothesis"
            },
            {
              "name": "evidence",
              "type": "List",
              "source": "new_evidence"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      }
    ],
    "contributing_modules": [
      "contradiction_deteccion.py",
      "dereck_beach.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "teoria_cambio",
    "evidence_types": [
      "assumption_conflict",
      "assumption_tests",
      "identified_confounders",
      "updated_belief"
    ],
    "aggregation_strategy": "assumption_validation",
    "confidence_threshold": 0.8,
    "total_steps": 4
  },
  "P1-D6-Q1": {
    "question_id": "P1-D6-Q1",
    "point": "P1",
    "dimension": "D6",
    "question_number": 1,
    "question_text": "Collect and catalog evidence sources",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "policy_processor",
        "adapter_class": "PolicyProcessorAdapter",
        "method": "_construct_evidence_bundle",
        "args": [
          {
            "name": "matches",
            "type": "List",
            "source": "pattern_matches"
          },
          {
            "name": "point",
            "type": "Dict",
            "source": "evidence_point"
          }
        ],
        "returns": {
          "type": "EvidenceBundle",
          "binding": "evidence_bundle"
        },
        "source_module": "policy_processor.py",
        "source_class": "PolicyProcessorAdapter",
        "source_method": "_construct_evidence_bundle",
        "purpose": "Construct evidence bundle from matches",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "matches",
              "type": "List",
              "source": "pattern_matches"
            },
            {
              "name": "point",
              "type": "Dict",
              "source": "evidence_point"
            }
          ],
          "return_type": "EvidenceBundle",
          "source_file": "policy_processor.py"
        }
      },
      {
        "step": 2,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "score_evidence_strength",
        "args": [
          {
            "name": "evidence",
            "type": "List[Dict]",
            "source": "collected_evidence"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "evidence_strength_scores"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "score_evidence_strength",
        "purpose": "Score strength of collected evidence",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "evidence",
              "type": "List[Dict]",
              "source": "collected_evidence"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 3,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "collect_empirical_evidence",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          },
          {
            "name": "mechanism",
            "type": "Dict",
            "source": "target_mechanism"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "empirical_evidence"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "collect_empirical_evidence",
        "purpose": "Collect empirical evidence for mechanisms",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            },
            {
              "name": "mechanism",
              "type": "Dict",
              "source": "target_mechanism"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "dereck_beach.py"
        }
      },
      {
        "step": 4,
        "adapter": "semantic_chunking_policy",
        "adapter_class": "SemanticChunkingPolicyAdapter",
        "method": "bayesian_evidence_integration",
        "args": [
          {
            "name": "chunks",
            "type": "List[Dict]",
            "source": "evidence_chunks"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "integrated_evidence"
        },
        "source_module": "semantic_chunking_policy.py",
        "source_class": "SemanticChunkingPolicyAdapter",
        "source_method": "bayesian_evidence_integration",
        "purpose": "Integrate evidence using Bayesian methods",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "chunks",
              "type": "List[Dict]",
              "source": "evidence_chunks"
            }
          ],
          "return_type": "Dict",
          "source_file": "semantic_chunking_policy.py"
        }
      }
    ],
    "contributing_modules": [
      "dereck_beach.py",
      "policy_processor.py",
      "semantic_chunking_policy.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "policy_processor",
    "evidence_types": [
      "empirical_evidence",
      "evidence_bundle",
      "evidence_strength_scores",
      "integrated_evidence"
    ],
    "aggregation_strategy": "evidence_consolidation",
    "confidence_threshold": 0.82,
    "total_steps": 4
  },
  "P2-D6-Q1": {
    "question_id": "P2-D6-Q1",
    "point": "P2",
    "dimension": "D6",
    "question_number": 1,
    "question_text": "Collect and catalog evidence sources",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "policy_processor",
        "adapter_class": "PolicyProcessorAdapter",
        "method": "_construct_evidence_bundle",
        "args": [
          {
            "name": "matches",
            "type": "List",
            "source": "pattern_matches"
          },
          {
            "name": "point",
            "type": "Dict",
            "source": "evidence_point"
          }
        ],
        "returns": {
          "type": "EvidenceBundle",
          "binding": "evidence_bundle"
        },
        "source_module": "policy_processor.py",
        "source_class": "PolicyProcessorAdapter",
        "source_method": "_construct_evidence_bundle",
        "purpose": "Construct evidence bundle from matches",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "matches",
              "type": "List",
              "source": "pattern_matches"
            },
            {
              "name": "point",
              "type": "Dict",
              "source": "evidence_point"
            }
          ],
          "return_type": "EvidenceBundle",
          "source_file": "policy_processor.py"
        }
      },
      {
        "step": 2,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "score_evidence_strength",
        "args": [
          {
            "name": "evidence",
            "type": "List[Dict]",
            "source": "collected_evidence"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "evidence_strength_scores"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "score_evidence_strength",
        "purpose": "Score strength of collected evidence",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "evidence",
              "type": "List[Dict]",
              "source": "collected_evidence"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 3,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "collect_empirical_evidence",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          },
          {
            "name": "mechanism",
            "type": "Dict",
            "source": "target_mechanism"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "empirical_evidence"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "collect_empirical_evidence",
        "purpose": "Collect empirical evidence for mechanisms",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            },
            {
              "name": "mechanism",
              "type": "Dict",
              "source": "target_mechanism"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "dereck_beach.py"
        }
      },
      {
        "step": 4,
        "adapter": "semantic_chunking_policy",
        "adapter_class": "SemanticChunkingPolicyAdapter",
        "method": "bayesian_evidence_integration",
        "args": [
          {
            "name": "chunks",
            "type": "List[Dict]",
            "source": "evidence_chunks"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "integrated_evidence"
        },
        "source_module": "semantic_chunking_policy.py",
        "source_class": "SemanticChunkingPolicyAdapter",
        "source_method": "bayesian_evidence_integration",
        "purpose": "Integrate evidence using Bayesian methods",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "chunks",
              "type": "List[Dict]",
              "source": "evidence_chunks"
            }
          ],
          "return_type": "Dict",
          "source_file": "semantic_chunking_policy.py"
        }
      }
    ],
    "contributing_modules": [
      "dereck_beach.py",
      "policy_processor.py",
      "semantic_chunking_policy.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "policy_processor",
    "evidence_types": [
      "empirical_evidence",
      "evidence_bundle",
      "evidence_strength_scores",
      "integrated_evidence"
    ],
    "aggregation_strategy": "evidence_consolidation",
    "confidence_threshold": 0.82,
    "total_steps": 4
  },
  "P3-D6-Q1": {
    "question_id": "P3-D6-Q1",
    "point": "P3",
    "dimension": "D6",
    "question_number": 1,
    "question_text": "Collect and catalog evidence sources",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "policy_processor",
        "adapter_class": "PolicyProcessorAdapter",
        "method": "_construct_evidence_bundle",
        "args": [
          {
            "name": "matches",
            "type": "List",
            "source": "pattern_matches"
          },
          {
            "name": "point",
            "type": "Dict",
            "source": "evidence_point"
          }
        ],
        "returns": {
          "type": "EvidenceBundle",
          "binding": "evidence_bundle"
        },
        "source_module": "policy_processor.py",
        "source_class": "PolicyProcessorAdapter",
        "source_method": "_construct_evidence_bundle",
        "purpose": "Construct evidence bundle from matches",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "matches",
              "type": "List",
              "source": "pattern_matches"
            },
            {
              "name": "point",
              "type": "Dict",
              "source": "evidence_point"
            }
          ],
          "return_type": "EvidenceBundle",
          "source_file": "policy_processor.py"
        }
      },
      {
        "step": 2,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "score_evidence_strength",
        "args": [
          {
            "name": "evidence",
            "type": "List[Dict]",
            "source": "collected_evidence"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "evidence_strength_scores"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "score_evidence_strength",
        "purpose": "Score strength of collected evidence",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "evidence",
              "type": "List[Dict]",
              "source": "collected_evidence"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 3,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "collect_empirical_evidence",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          },
          {
            "name": "mechanism",
            "type": "Dict",
            "source": "target_mechanism"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "empirical_evidence"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "collect_empirical_evidence",
        "purpose": "Collect empirical evidence for mechanisms",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            },
            {
              "name": "mechanism",
              "type": "Dict",
              "source": "target_mechanism"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "dereck_beach.py"
        }
      },
      {
        "step": 4,
        "adapter": "semantic_chunking_policy",
        "adapter_class": "SemanticChunkingPolicyAdapter",
        "method": "bayesian_evidence_integration",
        "args": [
          {
            "name": "chunks",
            "type": "List[Dict]",
            "source": "evidence_chunks"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "integrated_evidence"
        },
        "source_module": "semantic_chunking_policy.py",
        "source_class": "SemanticChunkingPolicyAdapter",
        "source_method": "bayesian_evidence_integration",
        "purpose": "Integrate evidence using Bayesian methods",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "chunks",
              "type": "List[Dict]",
              "source": "evidence_chunks"
            }
          ],
          "return_type": "Dict",
          "source_file": "semantic_chunking_policy.py"
        }
      }
    ],
    "contributing_modules": [
      "dereck_beach.py",
      "policy_processor.py",
      "semantic_chunking_policy.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "policy_processor",
    "evidence_types": [
      "empirical_evidence",
      "evidence_bundle",
      "evidence_strength_scores",
      "integrated_evidence"
    ],
    "aggregation_strategy": "evidence_consolidation",
    "confidence_threshold": 0.82,
    "total_steps": 4
  },
  "P4-D6-Q1": {
    "question_id": "P4-D6-Q1",
    "point": "P4",
    "dimension": "D6",
    "question_number": 1,
    "question_text": "Collect and catalog evidence sources",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "policy_processor",
        "adapter_class": "PolicyProcessorAdapter",
        "method": "_construct_evidence_bundle",
        "args": [
          {
            "name": "matches",
            "type": "List",
            "source": "pattern_matches"
          },
          {
            "name": "point",
            "type": "Dict",
            "source": "evidence_point"
          }
        ],
        "returns": {
          "type": "EvidenceBundle",
          "binding": "evidence_bundle"
        },
        "source_module": "policy_processor.py",
        "source_class": "PolicyProcessorAdapter",
        "source_method": "_construct_evidence_bundle",
        "purpose": "Construct evidence bundle from matches",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "matches",
              "type": "List",
              "source": "pattern_matches"
            },
            {
              "name": "point",
              "type": "Dict",
              "source": "evidence_point"
            }
          ],
          "return_type": "EvidenceBundle",
          "source_file": "policy_processor.py"
        }
      },
      {
        "step": 2,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "score_evidence_strength",
        "args": [
          {
            "name": "evidence",
            "type": "List[Dict]",
            "source": "collected_evidence"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "evidence_strength_scores"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "score_evidence_strength",
        "purpose": "Score strength of collected evidence",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "evidence",
              "type": "List[Dict]",
              "source": "collected_evidence"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 3,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "collect_empirical_evidence",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          },
          {
            "name": "mechanism",
            "type": "Dict",
            "source": "target_mechanism"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "empirical_evidence"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "collect_empirical_evidence",
        "purpose": "Collect empirical evidence for mechanisms",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            },
            {
              "name": "mechanism",
              "type": "Dict",
              "source": "target_mechanism"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "dereck_beach.py"
        }
      },
      {
        "step": 4,
        "adapter": "semantic_chunking_policy",
        "adapter_class": "SemanticChunkingPolicyAdapter",
        "method": "bayesian_evidence_integration",
        "args": [
          {
            "name": "chunks",
            "type": "List[Dict]",
            "source": "evidence_chunks"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "integrated_evidence"
        },
        "source_module": "semantic_chunking_policy.py",
        "source_class": "SemanticChunkingPolicyAdapter",
        "source_method": "bayesian_evidence_integration",
        "purpose": "Integrate evidence using Bayesian methods",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "chunks",
              "type": "List[Dict]",
              "source": "evidence_chunks"
            }
          ],
          "return_type": "Dict",
          "source_file": "semantic_chunking_policy.py"
        }
      }
    ],
    "contributing_modules": [
      "dereck_beach.py",
      "policy_processor.py",
      "semantic_chunking_policy.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "policy_processor",
    "evidence_types": [
      "empirical_evidence",
      "evidence_bundle",
      "evidence_strength_scores",
      "integrated_evidence"
    ],
    "aggregation_strategy": "evidence_consolidation",
    "confidence_threshold": 0.82,
    "total_steps": 4
  },
  "P5-D6-Q1": {
    "question_id": "P5-D6-Q1",
    "point": "P5",
    "dimension": "D6",
    "question_number": 1,
    "question_text": "Collect and catalog evidence sources",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "policy_processor",
        "adapter_class": "PolicyProcessorAdapter",
        "method": "_construct_evidence_bundle",
        "args": [
          {
            "name": "matches",
            "type": "List",
            "source": "pattern_matches"
          },
          {
            "name": "point",
            "type": "Dict",
            "source": "evidence_point"
          }
        ],
        "returns": {
          "type": "EvidenceBundle",
          "binding": "evidence_bundle"
        },
        "source_module": "policy_processor.py",
        "source_class": "PolicyProcessorAdapter",
        "source_method": "_construct_evidence_bundle",
        "purpose": "Construct evidence bundle from matches",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "matches",
              "type": "List",
              "source": "pattern_matches"
            },
            {
              "name": "point",
              "type": "Dict",
              "source": "evidence_point"
            }
          ],
          "return_type": "EvidenceBundle",
          "source_file": "policy_processor.py"
        }
      },
      {
        "step": 2,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "score_evidence_strength",
        "args": [
          {
            "name": "evidence",
            "type": "List[Dict]",
            "source": "collected_evidence"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "evidence_strength_scores"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "score_evidence_strength",
        "purpose": "Score strength of collected evidence",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "evidence",
              "type": "List[Dict]",
              "source": "collected_evidence"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 3,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "collect_empirical_evidence",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          },
          {
            "name": "mechanism",
            "type": "Dict",
            "source": "target_mechanism"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "empirical_evidence"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "collect_empirical_evidence",
        "purpose": "Collect empirical evidence for mechanisms",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            },
            {
              "name": "mechanism",
              "type": "Dict",
              "source": "target_mechanism"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "dereck_beach.py"
        }
      },
      {
        "step": 4,
        "adapter": "semantic_chunking_policy",
        "adapter_class": "SemanticChunkingPolicyAdapter",
        "method": "bayesian_evidence_integration",
        "args": [
          {
            "name": "chunks",
            "type": "List[Dict]",
            "source": "evidence_chunks"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "integrated_evidence"
        },
        "source_module": "semantic_chunking_policy.py",
        "source_class": "SemanticChunkingPolicyAdapter",
        "source_method": "bayesian_evidence_integration",
        "purpose": "Integrate evidence using Bayesian methods",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "chunks",
              "type": "List[Dict]",
              "source": "evidence_chunks"
            }
          ],
          "return_type": "Dict",
          "source_file": "semantic_chunking_policy.py"
        }
      }
    ],
    "contributing_modules": [
      "dereck_beach.py",
      "policy_processor.py",
      "semantic_chunking_policy.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "policy_processor",
    "evidence_types": [
      "empirical_evidence",
      "evidence_bundle",
      "evidence_strength_scores",
      "integrated_evidence"
    ],
    "aggregation_strategy": "evidence_consolidation",
    "confidence_threshold": 0.82,
    "total_steps": 4
  },
  "P6-D6-Q1": {
    "question_id": "P6-D6-Q1",
    "point": "P6",
    "dimension": "D6",
    "question_number": 1,
    "question_text": "Collect and catalog evidence sources",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "policy_processor",
        "adapter_class": "PolicyProcessorAdapter",
        "method": "_construct_evidence_bundle",
        "args": [
          {
            "name": "matches",
            "type": "List",
            "source": "pattern_matches"
          },
          {
            "name": "point",
            "type": "Dict",
            "source": "evidence_point"
          }
        ],
        "returns": {
          "type": "EvidenceBundle",
          "binding": "evidence_bundle"
        },
        "source_module": "policy_processor.py",
        "source_class": "PolicyProcessorAdapter",
        "source_method": "_construct_evidence_bundle",
        "purpose": "Construct evidence bundle from matches",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "matches",
              "type": "List",
              "source": "pattern_matches"
            },
            {
              "name": "point",
              "type": "Dict",
              "source": "evidence_point"
            }
          ],
          "return_type": "EvidenceBundle",
          "source_file": "policy_processor.py"
        }
      },
      {
        "step": 2,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "score_evidence_strength",
        "args": [
          {
            "name": "evidence",
            "type": "List[Dict]",
            "source": "collected_evidence"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "evidence_strength_scores"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "score_evidence_strength",
        "purpose": "Score strength of collected evidence",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "evidence",
              "type": "List[Dict]",
              "source": "collected_evidence"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 3,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "collect_empirical_evidence",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          },
          {
            "name": "mechanism",
            "type": "Dict",
            "source": "target_mechanism"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "empirical_evidence"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "collect_empirical_evidence",
        "purpose": "Collect empirical evidence for mechanisms",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            },
            {
              "name": "mechanism",
              "type": "Dict",
              "source": "target_mechanism"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "dereck_beach.py"
        }
      },
      {
        "step": 4,
        "adapter": "semantic_chunking_policy",
        "adapter_class": "SemanticChunkingPolicyAdapter",
        "method": "bayesian_evidence_integration",
        "args": [
          {
            "name": "chunks",
            "type": "List[Dict]",
            "source": "evidence_chunks"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "integrated_evidence"
        },
        "source_module": "semantic_chunking_policy.py",
        "source_class": "SemanticChunkingPolicyAdapter",
        "source_method": "bayesian_evidence_integration",
        "purpose": "Integrate evidence using Bayesian methods",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "chunks",
              "type": "List[Dict]",
              "source": "evidence_chunks"
            }
          ],
          "return_type": "Dict",
          "source_file": "semantic_chunking_policy.py"
        }
      }
    ],
    "contributing_modules": [
      "dereck_beach.py",
      "policy_processor.py",
      "semantic_chunking_policy.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "policy_processor",
    "evidence_types": [
      "empirical_evidence",
      "evidence_bundle",
      "evidence_strength_scores",
      "integrated_evidence"
    ],
    "aggregation_strategy": "evidence_consolidation",
    "confidence_threshold": 0.82,
    "total_steps": 4
  },
  "P7-D6-Q1": {
    "question_id": "P7-D6-Q1",
    "point": "P7",
    "dimension": "D6",
    "question_number": 1,
    "question_text": "Collect and catalog evidence sources",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "policy_processor",
        "adapter_class": "PolicyProcessorAdapter",
        "method": "_construct_evidence_bundle",
        "args": [
          {
            "name": "matches",
            "type": "List",
            "source": "pattern_matches"
          },
          {
            "name": "point",
            "type": "Dict",
            "source": "evidence_point"
          }
        ],
        "returns": {
          "type": "EvidenceBundle",
          "binding": "evidence_bundle"
        },
        "source_module": "policy_processor.py",
        "source_class": "PolicyProcessorAdapter",
        "source_method": "_construct_evidence_bundle",
        "purpose": "Construct evidence bundle from matches",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "matches",
              "type": "List",
              "source": "pattern_matches"
            },
            {
              "name": "point",
              "type": "Dict",
              "source": "evidence_point"
            }
          ],
          "return_type": "EvidenceBundle",
          "source_file": "policy_processor.py"
        }
      },
      {
        "step": 2,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "score_evidence_strength",
        "args": [
          {
            "name": "evidence",
            "type": "List[Dict]",
            "source": "collected_evidence"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "evidence_strength_scores"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "score_evidence_strength",
        "purpose": "Score strength of collected evidence",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "evidence",
              "type": "List[Dict]",
              "source": "collected_evidence"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 3,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "collect_empirical_evidence",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          },
          {
            "name": "mechanism",
            "type": "Dict",
            "source": "target_mechanism"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "empirical_evidence"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "collect_empirical_evidence",
        "purpose": "Collect empirical evidence for mechanisms",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            },
            {
              "name": "mechanism",
              "type": "Dict",
              "source": "target_mechanism"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "dereck_beach.py"
        }
      },
      {
        "step": 4,
        "adapter": "semantic_chunking_policy",
        "adapter_class": "SemanticChunkingPolicyAdapter",
        "method": "bayesian_evidence_integration",
        "args": [
          {
            "name": "chunks",
            "type": "List[Dict]",
            "source": "evidence_chunks"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "integrated_evidence"
        },
        "source_module": "semantic_chunking_policy.py",
        "source_class": "SemanticChunkingPolicyAdapter",
        "source_method": "bayesian_evidence_integration",
        "purpose": "Integrate evidence using Bayesian methods",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "chunks",
              "type": "List[Dict]",
              "source": "evidence_chunks"
            }
          ],
          "return_type": "Dict",
          "source_file": "semantic_chunking_policy.py"
        }
      }
    ],
    "contributing_modules": [
      "dereck_beach.py",
      "policy_processor.py",
      "semantic_chunking_policy.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "policy_processor",
    "evidence_types": [
      "empirical_evidence",
      "evidence_bundle",
      "evidence_strength_scores",
      "integrated_evidence"
    ],
    "aggregation_strategy": "evidence_consolidation",
    "confidence_threshold": 0.82,
    "total_steps": 4
  },
  "P8-D6-Q1": {
    "question_id": "P8-D6-Q1",
    "point": "P8",
    "dimension": "D6",
    "question_number": 1,
    "question_text": "Collect and catalog evidence sources",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "policy_processor",
        "adapter_class": "PolicyProcessorAdapter",
        "method": "_construct_evidence_bundle",
        "args": [
          {
            "name": "matches",
            "type": "List",
            "source": "pattern_matches"
          },
          {
            "name": "point",
            "type": "Dict",
            "source": "evidence_point"
          }
        ],
        "returns": {
          "type": "EvidenceBundle",
          "binding": "evidence_bundle"
        },
        "source_module": "policy_processor.py",
        "source_class": "PolicyProcessorAdapter",
        "source_method": "_construct_evidence_bundle",
        "purpose": "Construct evidence bundle from matches",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "matches",
              "type": "List",
              "source": "pattern_matches"
            },
            {
              "name": "point",
              "type": "Dict",
              "source": "evidence_point"
            }
          ],
          "return_type": "EvidenceBundle",
          "source_file": "policy_processor.py"
        }
      },
      {
        "step": 2,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "score_evidence_strength",
        "args": [
          {
            "name": "evidence",
            "type": "List[Dict]",
            "source": "collected_evidence"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "evidence_strength_scores"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "score_evidence_strength",
        "purpose": "Score strength of collected evidence",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "evidence",
              "type": "List[Dict]",
              "source": "collected_evidence"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 3,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "collect_empirical_evidence",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          },
          {
            "name": "mechanism",
            "type": "Dict",
            "source": "target_mechanism"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "empirical_evidence"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "collect_empirical_evidence",
        "purpose": "Collect empirical evidence for mechanisms",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            },
            {
              "name": "mechanism",
              "type": "Dict",
              "source": "target_mechanism"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "dereck_beach.py"
        }
      },
      {
        "step": 4,
        "adapter": "semantic_chunking_policy",
        "adapter_class": "SemanticChunkingPolicyAdapter",
        "method": "bayesian_evidence_integration",
        "args": [
          {
            "name": "chunks",
            "type": "List[Dict]",
            "source": "evidence_chunks"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "integrated_evidence"
        },
        "source_module": "semantic_chunking_policy.py",
        "source_class": "SemanticChunkingPolicyAdapter",
        "source_method": "bayesian_evidence_integration",
        "purpose": "Integrate evidence using Bayesian methods",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "chunks",
              "type": "List[Dict]",
              "source": "evidence_chunks"
            }
          ],
          "return_type": "Dict",
          "source_file": "semantic_chunking_policy.py"
        }
      }
    ],
    "contributing_modules": [
      "dereck_beach.py",
      "policy_processor.py",
      "semantic_chunking_policy.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "policy_processor",
    "evidence_types": [
      "empirical_evidence",
      "evidence_bundle",
      "evidence_strength_scores",
      "integrated_evidence"
    ],
    "aggregation_strategy": "evidence_consolidation",
    "confidence_threshold": 0.82,
    "total_steps": 4
  },
  "P9-D6-Q1": {
    "question_id": "P9-D6-Q1",
    "point": "P9",
    "dimension": "D6",
    "question_number": 1,
    "question_text": "Collect and catalog evidence sources",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "policy_processor",
        "adapter_class": "PolicyProcessorAdapter",
        "method": "_construct_evidence_bundle",
        "args": [
          {
            "name": "matches",
            "type": "List",
            "source": "pattern_matches"
          },
          {
            "name": "point",
            "type": "Dict",
            "source": "evidence_point"
          }
        ],
        "returns": {
          "type": "EvidenceBundle",
          "binding": "evidence_bundle"
        },
        "source_module": "policy_processor.py",
        "source_class": "PolicyProcessorAdapter",
        "source_method": "_construct_evidence_bundle",
        "purpose": "Construct evidence bundle from matches",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "matches",
              "type": "List",
              "source": "pattern_matches"
            },
            {
              "name": "point",
              "type": "Dict",
              "source": "evidence_point"
            }
          ],
          "return_type": "EvidenceBundle",
          "source_file": "policy_processor.py"
        }
      },
      {
        "step": 2,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "score_evidence_strength",
        "args": [
          {
            "name": "evidence",
            "type": "List[Dict]",
            "source": "collected_evidence"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "evidence_strength_scores"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "score_evidence_strength",
        "purpose": "Score strength of collected evidence",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "evidence",
              "type": "List[Dict]",
              "source": "collected_evidence"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 3,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "collect_empirical_evidence",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          },
          {
            "name": "mechanism",
            "type": "Dict",
            "source": "target_mechanism"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "empirical_evidence"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "collect_empirical_evidence",
        "purpose": "Collect empirical evidence for mechanisms",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            },
            {
              "name": "mechanism",
              "type": "Dict",
              "source": "target_mechanism"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "dereck_beach.py"
        }
      },
      {
        "step": 4,
        "adapter": "semantic_chunking_policy",
        "adapter_class": "SemanticChunkingPolicyAdapter",
        "method": "bayesian_evidence_integration",
        "args": [
          {
            "name": "chunks",
            "type": "List[Dict]",
            "source": "evidence_chunks"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "integrated_evidence"
        },
        "source_module": "semantic_chunking_policy.py",
        "source_class": "SemanticChunkingPolicyAdapter",
        "source_method": "bayesian_evidence_integration",
        "purpose": "Integrate evidence using Bayesian methods",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "chunks",
              "type": "List[Dict]",
              "source": "evidence_chunks"
            }
          ],
          "return_type": "Dict",
          "source_file": "semantic_chunking_policy.py"
        }
      }
    ],
    "contributing_modules": [
      "dereck_beach.py",
      "policy_processor.py",
      "semantic_chunking_policy.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "policy_processor",
    "evidence_types": [
      "empirical_evidence",
      "evidence_bundle",
      "evidence_strength_scores",
      "integrated_evidence"
    ],
    "aggregation_strategy": "evidence_consolidation",
    "confidence_threshold": 0.82,
    "total_steps": 4
  },
  "P10-D6-Q1": {
    "question_id": "P10-D6-Q1",
    "point": "P10",
    "dimension": "D6",
    "question_number": 1,
    "question_text": "Collect and catalog evidence sources",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "policy_processor",
        "adapter_class": "PolicyProcessorAdapter",
        "method": "_construct_evidence_bundle",
        "args": [
          {
            "name": "matches",
            "type": "List",
            "source": "pattern_matches"
          },
          {
            "name": "point",
            "type": "Dict",
            "source": "evidence_point"
          }
        ],
        "returns": {
          "type": "EvidenceBundle",
          "binding": "evidence_bundle"
        },
        "source_module": "policy_processor.py",
        "source_class": "PolicyProcessorAdapter",
        "source_method": "_construct_evidence_bundle",
        "purpose": "Construct evidence bundle from matches",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "matches",
              "type": "List",
              "source": "pattern_matches"
            },
            {
              "name": "point",
              "type": "Dict",
              "source": "evidence_point"
            }
          ],
          "return_type": "EvidenceBundle",
          "source_file": "policy_processor.py"
        }
      },
      {
        "step": 2,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "score_evidence_strength",
        "args": [
          {
            "name": "evidence",
            "type": "List[Dict]",
            "source": "collected_evidence"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "evidence_strength_scores"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "score_evidence_strength",
        "purpose": "Score strength of collected evidence",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "evidence",
              "type": "List[Dict]",
              "source": "collected_evidence"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 3,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "collect_empirical_evidence",
        "args": [
          {
            "name": "text",
            "type": "str",
            "source": "normalized_text"
          },
          {
            "name": "mechanism",
            "type": "Dict",
            "source": "target_mechanism"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "empirical_evidence"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "collect_empirical_evidence",
        "purpose": "Collect empirical evidence for mechanisms",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "text",
              "type": "str",
              "source": "normalized_text"
            },
            {
              "name": "mechanism",
              "type": "Dict",
              "source": "target_mechanism"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "dereck_beach.py"
        }
      },
      {
        "step": 4,
        "adapter": "semantic_chunking_policy",
        "adapter_class": "SemanticChunkingPolicyAdapter",
        "method": "bayesian_evidence_integration",
        "args": [
          {
            "name": "chunks",
            "type": "List[Dict]",
            "source": "evidence_chunks"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "integrated_evidence"
        },
        "source_module": "semantic_chunking_policy.py",
        "source_class": "SemanticChunkingPolicyAdapter",
        "source_method": "bayesian_evidence_integration",
        "purpose": "Integrate evidence using Bayesian methods",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "chunks",
              "type": "List[Dict]",
              "source": "evidence_chunks"
            }
          ],
          "return_type": "Dict",
          "source_file": "semantic_chunking_policy.py"
        }
      }
    ],
    "contributing_modules": [
      "dereck_beach.py",
      "policy_processor.py",
      "semantic_chunking_policy.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "policy_processor",
    "evidence_types": [
      "empirical_evidence",
      "evidence_bundle",
      "evidence_strength_scores",
      "integrated_evidence"
    ],
    "aggregation_strategy": "evidence_consolidation",
    "confidence_threshold": 0.82,
    "total_steps": 4
  },
  "P1-D6-Q2": {
    "question_id": "P1-D6-Q2",
    "point": "P1",
    "dimension": "D6",
    "question_number": 2,
    "question_text": "Assess quality and reliability of evidence",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "calculate_evidence_weight",
        "args": [
          {
            "name": "evidence_type",
            "type": "str",
            "source": "evidence_category"
          },
          {
            "name": "quality_indicators",
            "type": "Dict",
            "source": "quality_metrics"
          }
        ],
        "returns": {
          "type": "float",
          "binding": "evidence_weight"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "calculate_evidence_weight",
        "purpose": "Calculate evidence weight based on quality",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "evidence_type",
              "type": "str",
              "source": "evidence_category"
            },
            {
              "name": "quality_indicators",
              "type": "Dict",
              "source": "quality_metrics"
            }
          ],
          "return_type": "float",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 2,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "assess_evidence_quality",
        "args": [
          {
            "name": "evidence",
            "type": "Dict",
            "source": "evidence_item"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "quality_assessment"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "assess_evidence_quality",
        "purpose": "Assess evidence quality using Beach criteria",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "evidence",
              "type": "Dict",
              "source": "evidence_item"
            }
          ],
          "return_type": "Dict",
          "source_file": "dereck_beach.py"
        }
      },
      {
        "step": 3,
        "adapter": "policy_processor",
        "adapter_class": "PolicyProcessorAdapter",
        "method": "compute_evidence_score",
        "args": [
          {
            "name": "matches",
            "type": "List",
            "source": "evidence_matches"
          },
          {
            "name": "context",
            "type": "str",
            "source": "evidence_context"
          }
        ],
        "returns": {
          "type": "float",
          "binding": "evidence_score"
        },
        "source_module": "policy_processor.py",
        "source_class": "PolicyProcessorAdapter",
        "source_method": "compute_evidence_score",
        "purpose": "Compute overall evidence score",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "matches",
              "type": "List",
              "source": "evidence_matches"
            },
            {
              "name": "context",
              "type": "str",
              "source": "evidence_context"
            }
          ],
          "return_type": "float",
          "source_file": "policy_processor.py"
        }
      },
      {
        "step": 4,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_calculate_contradiction_entropy",
        "args": [],
        "returns": {
          "type": "float",
          "binding": "evidence_entropy"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_calculate_contradiction_entropy",
        "purpose": "Calculate entropy as evidence quality indicator",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [],
          "return_type": "float",
          "source_file": "contradiction_deteccion.py"
        }
      }
    ],
    "contributing_modules": [
      "contradiction_deteccion.py",
      "dereck_beach.py",
      "policy_processor.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "teoria_cambio",
    "evidence_types": [
      "evidence_entropy",
      "evidence_score",
      "evidence_weight",
      "quality_assessment"
    ],
    "aggregation_strategy": "quality_weighted_average",
    "confidence_threshold": 0.83,
    "total_steps": 4
  },
  "P2-D6-Q2": {
    "question_id": "P2-D6-Q2",
    "point": "P2",
    "dimension": "D6",
    "question_number": 2,
    "question_text": "Assess quality and reliability of evidence",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "calculate_evidence_weight",
        "args": [
          {
            "name": "evidence_type",
            "type": "str",
            "source": "evidence_category"
          },
          {
            "name": "quality_indicators",
            "type": "Dict",
            "source": "quality_metrics"
          }
        ],
        "returns": {
          "type": "float",
          "binding": "evidence_weight"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "calculate_evidence_weight",
        "purpose": "Calculate evidence weight based on quality",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "evidence_type",
              "type": "str",
              "source": "evidence_category"
            },
            {
              "name": "quality_indicators",
              "type": "Dict",
              "source": "quality_metrics"
            }
          ],
          "return_type": "float",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 2,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "assess_evidence_quality",
        "args": [
          {
            "name": "evidence",
            "type": "Dict",
            "source": "evidence_item"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "quality_assessment"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "assess_evidence_quality",
        "purpose": "Assess evidence quality using Beach criteria",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "evidence",
              "type": "Dict",
              "source": "evidence_item"
            }
          ],
          "return_type": "Dict",
          "source_file": "dereck_beach.py"
        }
      },
      {
        "step": 3,
        "adapter": "policy_processor",
        "adapter_class": "PolicyProcessorAdapter",
        "method": "compute_evidence_score",
        "args": [
          {
            "name": "matches",
            "type": "List",
            "source": "evidence_matches"
          },
          {
            "name": "context",
            "type": "str",
            "source": "evidence_context"
          }
        ],
        "returns": {
          "type": "float",
          "binding": "evidence_score"
        },
        "source_module": "policy_processor.py",
        "source_class": "PolicyProcessorAdapter",
        "source_method": "compute_evidence_score",
        "purpose": "Compute overall evidence score",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "matches",
              "type": "List",
              "source": "evidence_matches"
            },
            {
              "name": "context",
              "type": "str",
              "source": "evidence_context"
            }
          ],
          "return_type": "float",
          "source_file": "policy_processor.py"
        }
      },
      {
        "step": 4,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_calculate_contradiction_entropy",
        "args": [],
        "returns": {
          "type": "float",
          "binding": "evidence_entropy"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_calculate_contradiction_entropy",
        "purpose": "Calculate entropy as evidence quality indicator",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [],
          "return_type": "float",
          "source_file": "contradiction_deteccion.py"
        }
      }
    ],
    "contributing_modules": [
      "contradiction_deteccion.py",
      "dereck_beach.py",
      "policy_processor.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "teoria_cambio",
    "evidence_types": [
      "evidence_entropy",
      "evidence_score",
      "evidence_weight",
      "quality_assessment"
    ],
    "aggregation_strategy": "quality_weighted_average",
    "confidence_threshold": 0.83,
    "total_steps": 4
  },
  "P3-D6-Q2": {
    "question_id": "P3-D6-Q2",
    "point": "P3",
    "dimension": "D6",
    "question_number": 2,
    "question_text": "Assess quality and reliability of evidence",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "calculate_evidence_weight",
        "args": [
          {
            "name": "evidence_type",
            "type": "str",
            "source": "evidence_category"
          },
          {
            "name": "quality_indicators",
            "type": "Dict",
            "source": "quality_metrics"
          }
        ],
        "returns": {
          "type": "float",
          "binding": "evidence_weight"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "calculate_evidence_weight",
        "purpose": "Calculate evidence weight based on quality",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "evidence_type",
              "type": "str",
              "source": "evidence_category"
            },
            {
              "name": "quality_indicators",
              "type": "Dict",
              "source": "quality_metrics"
            }
          ],
          "return_type": "float",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 2,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "assess_evidence_quality",
        "args": [
          {
            "name": "evidence",
            "type": "Dict",
            "source": "evidence_item"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "quality_assessment"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "assess_evidence_quality",
        "purpose": "Assess evidence quality using Beach criteria",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "evidence",
              "type": "Dict",
              "source": "evidence_item"
            }
          ],
          "return_type": "Dict",
          "source_file": "dereck_beach.py"
        }
      },
      {
        "step": 3,
        "adapter": "policy_processor",
        "adapter_class": "PolicyProcessorAdapter",
        "method": "compute_evidence_score",
        "args": [
          {
            "name": "matches",
            "type": "List",
            "source": "evidence_matches"
          },
          {
            "name": "context",
            "type": "str",
            "source": "evidence_context"
          }
        ],
        "returns": {
          "type": "float",
          "binding": "evidence_score"
        },
        "source_module": "policy_processor.py",
        "source_class": "PolicyProcessorAdapter",
        "source_method": "compute_evidence_score",
        "purpose": "Compute overall evidence score",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "matches",
              "type": "List",
              "source": "evidence_matches"
            },
            {
              "name": "context",
              "type": "str",
              "source": "evidence_context"
            }
          ],
          "return_type": "float",
          "source_file": "policy_processor.py"
        }
      },
      {
        "step": 4,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_calculate_contradiction_entropy",
        "args": [],
        "returns": {
          "type": "float",
          "binding": "evidence_entropy"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_calculate_contradiction_entropy",
        "purpose": "Calculate entropy as evidence quality indicator",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [],
          "return_type": "float",
          "source_file": "contradiction_deteccion.py"
        }
      }
    ],
    "contributing_modules": [
      "contradiction_deteccion.py",
      "dereck_beach.py",
      "policy_processor.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "teoria_cambio",
    "evidence_types": [
      "evidence_entropy",
      "evidence_score",
      "evidence_weight",
      "quality_assessment"
    ],
    "aggregation_strategy": "quality_weighted_average",
    "confidence_threshold": 0.83,
    "total_steps": 4
  },
  "P4-D6-Q2": {
    "question_id": "P4-D6-Q2",
    "point": "P4",
    "dimension": "D6",
    "question_number": 2,
    "question_text": "Assess quality and reliability of evidence",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "calculate_evidence_weight",
        "args": [
          {
            "name": "evidence_type",
            "type": "str",
            "source": "evidence_category"
          },
          {
            "name": "quality_indicators",
            "type": "Dict",
            "source": "quality_metrics"
          }
        ],
        "returns": {
          "type": "float",
          "binding": "evidence_weight"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "calculate_evidence_weight",
        "purpose": "Calculate evidence weight based on quality",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "evidence_type",
              "type": "str",
              "source": "evidence_category"
            },
            {
              "name": "quality_indicators",
              "type": "Dict",
              "source": "quality_metrics"
            }
          ],
          "return_type": "float",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 2,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "assess_evidence_quality",
        "args": [
          {
            "name": "evidence",
            "type": "Dict",
            "source": "evidence_item"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "quality_assessment"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "assess_evidence_quality",
        "purpose": "Assess evidence quality using Beach criteria",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "evidence",
              "type": "Dict",
              "source": "evidence_item"
            }
          ],
          "return_type": "Dict",
          "source_file": "dereck_beach.py"
        }
      },
      {
        "step": 3,
        "adapter": "policy_processor",
        "adapter_class": "PolicyProcessorAdapter",
        "method": "compute_evidence_score",
        "args": [
          {
            "name": "matches",
            "type": "List",
            "source": "evidence_matches"
          },
          {
            "name": "context",
            "type": "str",
            "source": "evidence_context"
          }
        ],
        "returns": {
          "type": "float",
          "binding": "evidence_score"
        },
        "source_module": "policy_processor.py",
        "source_class": "PolicyProcessorAdapter",
        "source_method": "compute_evidence_score",
        "purpose": "Compute overall evidence score",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "matches",
              "type": "List",
              "source": "evidence_matches"
            },
            {
              "name": "context",
              "type": "str",
              "source": "evidence_context"
            }
          ],
          "return_type": "float",
          "source_file": "policy_processor.py"
        }
      },
      {
        "step": 4,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_calculate_contradiction_entropy",
        "args": [],
        "returns": {
          "type": "float",
          "binding": "evidence_entropy"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_calculate_contradiction_entropy",
        "purpose": "Calculate entropy as evidence quality indicator",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [],
          "return_type": "float",
          "source_file": "contradiction_deteccion.py"
        }
      }
    ],
    "contributing_modules": [
      "contradiction_deteccion.py",
      "dereck_beach.py",
      "policy_processor.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "teoria_cambio",
    "evidence_types": [
      "evidence_entropy",
      "evidence_score",
      "evidence_weight",
      "quality_assessment"
    ],
    "aggregation_strategy": "quality_weighted_average",
    "confidence_threshold": 0.83,
    "total_steps": 4
  },
  "P5-D6-Q2": {
    "question_id": "P5-D6-Q2",
    "point": "P5",
    "dimension": "D6",
    "question_number": 2,
    "question_text": "Assess quality and reliability of evidence",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "calculate_evidence_weight",
        "args": [
          {
            "name": "evidence_type",
            "type": "str",
            "source": "evidence_category"
          },
          {
            "name": "quality_indicators",
            "type": "Dict",
            "source": "quality_metrics"
          }
        ],
        "returns": {
          "type": "float",
          "binding": "evidence_weight"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "calculate_evidence_weight",
        "purpose": "Calculate evidence weight based on quality",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "evidence_type",
              "type": "str",
              "source": "evidence_category"
            },
            {
              "name": "quality_indicators",
              "type": "Dict",
              "source": "quality_metrics"
            }
          ],
          "return_type": "float",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 2,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "assess_evidence_quality",
        "args": [
          {
            "name": "evidence",
            "type": "Dict",
            "source": "evidence_item"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "quality_assessment"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "assess_evidence_quality",
        "purpose": "Assess evidence quality using Beach criteria",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "evidence",
              "type": "Dict",
              "source": "evidence_item"
            }
          ],
          "return_type": "Dict",
          "source_file": "dereck_beach.py"
        }
      },
      {
        "step": 3,
        "adapter": "policy_processor",
        "adapter_class": "PolicyProcessorAdapter",
        "method": "compute_evidence_score",
        "args": [
          {
            "name": "matches",
            "type": "List",
            "source": "evidence_matches"
          },
          {
            "name": "context",
            "type": "str",
            "source": "evidence_context"
          }
        ],
        "returns": {
          "type": "float",
          "binding": "evidence_score"
        },
        "source_module": "policy_processor.py",
        "source_class": "PolicyProcessorAdapter",
        "source_method": "compute_evidence_score",
        "purpose": "Compute overall evidence score",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "matches",
              "type": "List",
              "source": "evidence_matches"
            },
            {
              "name": "context",
              "type": "str",
              "source": "evidence_context"
            }
          ],
          "return_type": "float",
          "source_file": "policy_processor.py"
        }
      },
      {
        "step": 4,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_calculate_contradiction_entropy",
        "args": [],
        "returns": {
          "type": "float",
          "binding": "evidence_entropy"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_calculate_contradiction_entropy",
        "purpose": "Calculate entropy as evidence quality indicator",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [],
          "return_type": "float",
          "source_file": "contradiction_deteccion.py"
        }
      }
    ],
    "contributing_modules": [
      "contradiction_deteccion.py",
      "dereck_beach.py",
      "policy_processor.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "teoria_cambio",
    "evidence_types": [
      "evidence_entropy",
      "evidence_score",
      "evidence_weight",
      "quality_assessment"
    ],
    "aggregation_strategy": "quality_weighted_average",
    "confidence_threshold": 0.83,
    "total_steps": 4
  },
  "P6-D6-Q2": {
    "question_id": "P6-D6-Q2",
    "point": "P6",
    "dimension": "D6",
    "question_number": 2,
    "question_text": "Assess quality and reliability of evidence",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "calculate_evidence_weight",
        "args": [
          {
            "name": "evidence_type",
            "type": "str",
            "source": "evidence_category"
          },
          {
            "name": "quality_indicators",
            "type": "Dict",
            "source": "quality_metrics"
          }
        ],
        "returns": {
          "type": "float",
          "binding": "evidence_weight"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "calculate_evidence_weight",
        "purpose": "Calculate evidence weight based on quality",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "evidence_type",
              "type": "str",
              "source": "evidence_category"
            },
            {
              "name": "quality_indicators",
              "type": "Dict",
              "source": "quality_metrics"
            }
          ],
          "return_type": "float",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 2,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "assess_evidence_quality",
        "args": [
          {
            "name": "evidence",
            "type": "Dict",
            "source": "evidence_item"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "quality_assessment"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "assess_evidence_quality",
        "purpose": "Assess evidence quality using Beach criteria",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "evidence",
              "type": "Dict",
              "source": "evidence_item"
            }
          ],
          "return_type": "Dict",
          "source_file": "dereck_beach.py"
        }
      },
      {
        "step": 3,
        "adapter": "policy_processor",
        "adapter_class": "PolicyProcessorAdapter",
        "method": "compute_evidence_score",
        "args": [
          {
            "name": "matches",
            "type": "List",
            "source": "evidence_matches"
          },
          {
            "name": "context",
            "type": "str",
            "source": "evidence_context"
          }
        ],
        "returns": {
          "type": "float",
          "binding": "evidence_score"
        },
        "source_module": "policy_processor.py",
        "source_class": "PolicyProcessorAdapter",
        "source_method": "compute_evidence_score",
        "purpose": "Compute overall evidence score",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "matches",
              "type": "List",
              "source": "evidence_matches"
            },
            {
              "name": "context",
              "type": "str",
              "source": "evidence_context"
            }
          ],
          "return_type": "float",
          "source_file": "policy_processor.py"
        }
      },
      {
        "step": 4,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_calculate_contradiction_entropy",
        "args": [],
        "returns": {
          "type": "float",
          "binding": "evidence_entropy"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_calculate_contradiction_entropy",
        "purpose": "Calculate entropy as evidence quality indicator",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [],
          "return_type": "float",
          "source_file": "contradiction_deteccion.py"
        }
      }
    ],
    "contributing_modules": [
      "contradiction_deteccion.py",
      "dereck_beach.py",
      "policy_processor.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "teoria_cambio",
    "evidence_types": [
      "evidence_entropy",
      "evidence_score",
      "evidence_weight",
      "quality_assessment"
    ],
    "aggregation_strategy": "quality_weighted_average",
    "confidence_threshold": 0.83,
    "total_steps": 4
  },
  "P7-D6-Q2": {
    "question_id": "P7-D6-Q2",
    "point": "P7",
    "dimension": "D6",
    "question_number": 2,
    "question_text": "Assess quality and reliability of evidence",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "calculate_evidence_weight",
        "args": [
          {
            "name": "evidence_type",
            "type": "str",
            "source": "evidence_category"
          },
          {
            "name": "quality_indicators",
            "type": "Dict",
            "source": "quality_metrics"
          }
        ],
        "returns": {
          "type": "float",
          "binding": "evidence_weight"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "calculate_evidence_weight",
        "purpose": "Calculate evidence weight based on quality",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "evidence_type",
              "type": "str",
              "source": "evidence_category"
            },
            {
              "name": "quality_indicators",
              "type": "Dict",
              "source": "quality_metrics"
            }
          ],
          "return_type": "float",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 2,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "assess_evidence_quality",
        "args": [
          {
            "name": "evidence",
            "type": "Dict",
            "source": "evidence_item"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "quality_assessment"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "assess_evidence_quality",
        "purpose": "Assess evidence quality using Beach criteria",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "evidence",
              "type": "Dict",
              "source": "evidence_item"
            }
          ],
          "return_type": "Dict",
          "source_file": "dereck_beach.py"
        }
      },
      {
        "step": 3,
        "adapter": "policy_processor",
        "adapter_class": "PolicyProcessorAdapter",
        "method": "compute_evidence_score",
        "args": [
          {
            "name": "matches",
            "type": "List",
            "source": "evidence_matches"
          },
          {
            "name": "context",
            "type": "str",
            "source": "evidence_context"
          }
        ],
        "returns": {
          "type": "float",
          "binding": "evidence_score"
        },
        "source_module": "policy_processor.py",
        "source_class": "PolicyProcessorAdapter",
        "source_method": "compute_evidence_score",
        "purpose": "Compute overall evidence score",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "matches",
              "type": "List",
              "source": "evidence_matches"
            },
            {
              "name": "context",
              "type": "str",
              "source": "evidence_context"
            }
          ],
          "return_type": "float",
          "source_file": "policy_processor.py"
        }
      },
      {
        "step": 4,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_calculate_contradiction_entropy",
        "args": [],
        "returns": {
          "type": "float",
          "binding": "evidence_entropy"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_calculate_contradiction_entropy",
        "purpose": "Calculate entropy as evidence quality indicator",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [],
          "return_type": "float",
          "source_file": "contradiction_deteccion.py"
        }
      }
    ],
    "contributing_modules": [
      "contradiction_deteccion.py",
      "dereck_beach.py",
      "policy_processor.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "teoria_cambio",
    "evidence_types": [
      "evidence_entropy",
      "evidence_score",
      "evidence_weight",
      "quality_assessment"
    ],
    "aggregation_strategy": "quality_weighted_average",
    "confidence_threshold": 0.83,
    "total_steps": 4
  },
  "P8-D6-Q2": {
    "question_id": "P8-D6-Q2",
    "point": "P8",
    "dimension": "D6",
    "question_number": 2,
    "question_text": "Assess quality and reliability of evidence",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "calculate_evidence_weight",
        "args": [
          {
            "name": "evidence_type",
            "type": "str",
            "source": "evidence_category"
          },
          {
            "name": "quality_indicators",
            "type": "Dict",
            "source": "quality_metrics"
          }
        ],
        "returns": {
          "type": "float",
          "binding": "evidence_weight"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "calculate_evidence_weight",
        "purpose": "Calculate evidence weight based on quality",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "evidence_type",
              "type": "str",
              "source": "evidence_category"
            },
            {
              "name": "quality_indicators",
              "type": "Dict",
              "source": "quality_metrics"
            }
          ],
          "return_type": "float",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 2,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "assess_evidence_quality",
        "args": [
          {
            "name": "evidence",
            "type": "Dict",
            "source": "evidence_item"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "quality_assessment"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "assess_evidence_quality",
        "purpose": "Assess evidence quality using Beach criteria",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "evidence",
              "type": "Dict",
              "source": "evidence_item"
            }
          ],
          "return_type": "Dict",
          "source_file": "dereck_beach.py"
        }
      },
      {
        "step": 3,
        "adapter": "policy_processor",
        "adapter_class": "PolicyProcessorAdapter",
        "method": "compute_evidence_score",
        "args": [
          {
            "name": "matches",
            "type": "List",
            "source": "evidence_matches"
          },
          {
            "name": "context",
            "type": "str",
            "source": "evidence_context"
          }
        ],
        "returns": {
          "type": "float",
          "binding": "evidence_score"
        },
        "source_module": "policy_processor.py",
        "source_class": "PolicyProcessorAdapter",
        "source_method": "compute_evidence_score",
        "purpose": "Compute overall evidence score",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "matches",
              "type": "List",
              "source": "evidence_matches"
            },
            {
              "name": "context",
              "type": "str",
              "source": "evidence_context"
            }
          ],
          "return_type": "float",
          "source_file": "policy_processor.py"
        }
      },
      {
        "step": 4,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_calculate_contradiction_entropy",
        "args": [],
        "returns": {
          "type": "float",
          "binding": "evidence_entropy"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_calculate_contradiction_entropy",
        "purpose": "Calculate entropy as evidence quality indicator",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [],
          "return_type": "float",
          "source_file": "contradiction_deteccion.py"
        }
      }
    ],
    "contributing_modules": [
      "contradiction_deteccion.py",
      "dereck_beach.py",
      "policy_processor.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "teoria_cambio",
    "evidence_types": [
      "evidence_entropy",
      "evidence_score",
      "evidence_weight",
      "quality_assessment"
    ],
    "aggregation_strategy": "quality_weighted_average",
    "confidence_threshold": 0.83,
    "total_steps": 4
  },
  "P9-D6-Q2": {
    "question_id": "P9-D6-Q2",
    "point": "P9",
    "dimension": "D6",
    "question_number": 2,
    "question_text": "Assess quality and reliability of evidence",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "calculate_evidence_weight",
        "args": [
          {
            "name": "evidence_type",
            "type": "str",
            "source": "evidence_category"
          },
          {
            "name": "quality_indicators",
            "type": "Dict",
            "source": "quality_metrics"
          }
        ],
        "returns": {
          "type": "float",
          "binding": "evidence_weight"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "calculate_evidence_weight",
        "purpose": "Calculate evidence weight based on quality",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "evidence_type",
              "type": "str",
              "source": "evidence_category"
            },
            {
              "name": "quality_indicators",
              "type": "Dict",
              "source": "quality_metrics"
            }
          ],
          "return_type": "float",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 2,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "assess_evidence_quality",
        "args": [
          {
            "name": "evidence",
            "type": "Dict",
            "source": "evidence_item"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "quality_assessment"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "assess_evidence_quality",
        "purpose": "Assess evidence quality using Beach criteria",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "evidence",
              "type": "Dict",
              "source": "evidence_item"
            }
          ],
          "return_type": "Dict",
          "source_file": "dereck_beach.py"
        }
      },
      {
        "step": 3,
        "adapter": "policy_processor",
        "adapter_class": "PolicyProcessorAdapter",
        "method": "compute_evidence_score",
        "args": [
          {
            "name": "matches",
            "type": "List",
            "source": "evidence_matches"
          },
          {
            "name": "context",
            "type": "str",
            "source": "evidence_context"
          }
        ],
        "returns": {
          "type": "float",
          "binding": "evidence_score"
        },
        "source_module": "policy_processor.py",
        "source_class": "PolicyProcessorAdapter",
        "source_method": "compute_evidence_score",
        "purpose": "Compute overall evidence score",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "matches",
              "type": "List",
              "source": "evidence_matches"
            },
            {
              "name": "context",
              "type": "str",
              "source": "evidence_context"
            }
          ],
          "return_type": "float",
          "source_file": "policy_processor.py"
        }
      },
      {
        "step": 4,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_calculate_contradiction_entropy",
        "args": [],
        "returns": {
          "type": "float",
          "binding": "evidence_entropy"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_calculate_contradiction_entropy",
        "purpose": "Calculate entropy as evidence quality indicator",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [],
          "return_type": "float",
          "source_file": "contradiction_deteccion.py"
        }
      }
    ],
    "contributing_modules": [
      "contradiction_deteccion.py",
      "dereck_beach.py",
      "policy_processor.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "teoria_cambio",
    "evidence_types": [
      "evidence_entropy",
      "evidence_score",
      "evidence_weight",
      "quality_assessment"
    ],
    "aggregation_strategy": "quality_weighted_average",
    "confidence_threshold": 0.83,
    "total_steps": 4
  },
  "P10-D6-Q2": {
    "question_id": "P10-D6-Q2",
    "point": "P10",
    "dimension": "D6",
    "question_number": 2,
    "question_text": "Assess quality and reliability of evidence",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "calculate_evidence_weight",
        "args": [
          {
            "name": "evidence_type",
            "type": "str",
            "source": "evidence_category"
          },
          {
            "name": "quality_indicators",
            "type": "Dict",
            "source": "quality_metrics"
          }
        ],
        "returns": {
          "type": "float",
          "binding": "evidence_weight"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "calculate_evidence_weight",
        "purpose": "Calculate evidence weight based on quality",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "evidence_type",
              "type": "str",
              "source": "evidence_category"
            },
            {
              "name": "quality_indicators",
              "type": "Dict",
              "source": "quality_metrics"
            }
          ],
          "return_type": "float",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 2,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "assess_evidence_quality",
        "args": [
          {
            "name": "evidence",
            "type": "Dict",
            "source": "evidence_item"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "quality_assessment"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "assess_evidence_quality",
        "purpose": "Assess evidence quality using Beach criteria",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "evidence",
              "type": "Dict",
              "source": "evidence_item"
            }
          ],
          "return_type": "Dict",
          "source_file": "dereck_beach.py"
        }
      },
      {
        "step": 3,
        "adapter": "policy_processor",
        "adapter_class": "PolicyProcessorAdapter",
        "method": "compute_evidence_score",
        "args": [
          {
            "name": "matches",
            "type": "List",
            "source": "evidence_matches"
          },
          {
            "name": "context",
            "type": "str",
            "source": "evidence_context"
          }
        ],
        "returns": {
          "type": "float",
          "binding": "evidence_score"
        },
        "source_module": "policy_processor.py",
        "source_class": "PolicyProcessorAdapter",
        "source_method": "compute_evidence_score",
        "purpose": "Compute overall evidence score",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "matches",
              "type": "List",
              "source": "evidence_matches"
            },
            {
              "name": "context",
              "type": "str",
              "source": "evidence_context"
            }
          ],
          "return_type": "float",
          "source_file": "policy_processor.py"
        }
      },
      {
        "step": 4,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_calculate_contradiction_entropy",
        "args": [],
        "returns": {
          "type": "float",
          "binding": "evidence_entropy"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_calculate_contradiction_entropy",
        "purpose": "Calculate entropy as evidence quality indicator",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [],
          "return_type": "float",
          "source_file": "contradiction_deteccion.py"
        }
      }
    ],
    "contributing_modules": [
      "contradiction_deteccion.py",
      "dereck_beach.py",
      "policy_processor.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "teoria_cambio",
    "evidence_types": [
      "evidence_entropy",
      "evidence_score",
      "evidence_weight",
      "quality_assessment"
    ],
    "aggregation_strategy": "quality_weighted_average",
    "confidence_threshold": 0.83,
    "total_steps": 4
  },
  "P1-D6-Q3": {
    "question_id": "P1-D6-Q3",
    "point": "P1",
    "dimension": "D6",
    "question_number": 3,
    "question_text": "Establish evidence traceability and linkages",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "trace_financial_flows",
        "args": [
          {
            "name": "allocations",
            "type": "List[Dict]",
            "source": "budget_allocations"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "financial_trace"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "trace_financial_flows",
        "purpose": "Trace financial evidence flows",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "allocations",
              "type": "List[Dict]",
              "source": "budget_allocations"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 2,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "trace_causal_pathway",
        "args": [
          {
            "name": "from_node",
            "type": "str",
            "source": "evidence_source"
          },
          {
            "name": "to_node",
            "type": "str",
            "source": "evidence_target"
          },
          {
            "name": "dag",
            "type": "nx.DiGraph",
            "source": "evidence_dag"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "causal_trace"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "trace_causal_pathway",
        "purpose": "Trace causal pathways in evidence",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "from_node",
              "type": "str",
              "source": "evidence_source"
            },
            {
              "name": "to_node",
              "type": "str",
              "source": "evidence_target"
            },
            {
              "name": "dag",
              "type": "nx.DiGraph",
              "source": "evidence_dag"
            }
          ],
          "return_type": "Dict",
          "source_file": "dereck_beach.py"
        }
      },
      {
        "step": 3,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_identify_dependencies",
        "args": [
          {
            "name": "statement",
            "type": "Dict",
            "source": "evidence_statement"
          }
        ],
        "returns": {
          "type": "List[str]",
          "binding": "evidence_dependencies"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_identify_dependencies",
        "purpose": "Identify evidence dependencies",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "statement",
              "type": "Dict",
              "source": "evidence_statement"
            }
          ],
          "return_type": "List[str]",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 4,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "trace_numerical_chain",
        "args": [
          {
            "name": "claims",
            "type": "List[Dict]",
            "source": "numerical_evidence"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "numerical_trace"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "trace_numerical_chain",
        "purpose": "Trace chain of numerical evidence",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "claims",
              "type": "List[Dict]",
              "source": "numerical_evidence"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "emebedding_policy.py"
        }
      }
    ],
    "contributing_modules": [
      "contradiction_deteccion.py",
      "dereck_beach.py",
      "emebedding_policy.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "teoria_cambio",
    "evidence_types": [
      "causal_trace",
      "evidence_dependencies",
      "financial_trace",
      "numerical_trace"
    ],
    "aggregation_strategy": "traceability_synthesis",
    "confidence_threshold": 0.83,
    "total_steps": 4
  },
  "P2-D6-Q3": {
    "question_id": "P2-D6-Q3",
    "point": "P2",
    "dimension": "D6",
    "question_number": 3,
    "question_text": "Establish evidence traceability and linkages",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "trace_financial_flows",
        "args": [
          {
            "name": "allocations",
            "type": "List[Dict]",
            "source": "budget_allocations"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "financial_trace"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "trace_financial_flows",
        "purpose": "Trace financial evidence flows",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "allocations",
              "type": "List[Dict]",
              "source": "budget_allocations"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 2,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "trace_causal_pathway",
        "args": [
          {
            "name": "from_node",
            "type": "str",
            "source": "evidence_source"
          },
          {
            "name": "to_node",
            "type": "str",
            "source": "evidence_target"
          },
          {
            "name": "dag",
            "type": "nx.DiGraph",
            "source": "evidence_dag"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "causal_trace"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "trace_causal_pathway",
        "purpose": "Trace causal pathways in evidence",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "from_node",
              "type": "str",
              "source": "evidence_source"
            },
            {
              "name": "to_node",
              "type": "str",
              "source": "evidence_target"
            },
            {
              "name": "dag",
              "type": "nx.DiGraph",
              "source": "evidence_dag"
            }
          ],
          "return_type": "Dict",
          "source_file": "dereck_beach.py"
        }
      },
      {
        "step": 3,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_identify_dependencies",
        "args": [
          {
            "name": "statement",
            "type": "Dict",
            "source": "evidence_statement"
          }
        ],
        "returns": {
          "type": "List[str]",
          "binding": "evidence_dependencies"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_identify_dependencies",
        "purpose": "Identify evidence dependencies",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "statement",
              "type": "Dict",
              "source": "evidence_statement"
            }
          ],
          "return_type": "List[str]",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 4,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "trace_numerical_chain",
        "args": [
          {
            "name": "claims",
            "type": "List[Dict]",
            "source": "numerical_evidence"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "numerical_trace"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "trace_numerical_chain",
        "purpose": "Trace chain of numerical evidence",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "claims",
              "type": "List[Dict]",
              "source": "numerical_evidence"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "emebedding_policy.py"
        }
      }
    ],
    "contributing_modules": [
      "contradiction_deteccion.py",
      "dereck_beach.py",
      "emebedding_policy.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "teoria_cambio",
    "evidence_types": [
      "causal_trace",
      "evidence_dependencies",
      "financial_trace",
      "numerical_trace"
    ],
    "aggregation_strategy": "traceability_synthesis",
    "confidence_threshold": 0.83,
    "total_steps": 4
  },
  "P3-D6-Q3": {
    "question_id": "P3-D6-Q3",
    "point": "P3",
    "dimension": "D6",
    "question_number": 3,
    "question_text": "Establish evidence traceability and linkages",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "trace_financial_flows",
        "args": [
          {
            "name": "allocations",
            "type": "List[Dict]",
            "source": "budget_allocations"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "financial_trace"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "trace_financial_flows",
        "purpose": "Trace financial evidence flows",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "allocations",
              "type": "List[Dict]",
              "source": "budget_allocations"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 2,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "trace_causal_pathway",
        "args": [
          {
            "name": "from_node",
            "type": "str",
            "source": "evidence_source"
          },
          {
            "name": "to_node",
            "type": "str",
            "source": "evidence_target"
          },
          {
            "name": "dag",
            "type": "nx.DiGraph",
            "source": "evidence_dag"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "causal_trace"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "trace_causal_pathway",
        "purpose": "Trace causal pathways in evidence",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "from_node",
              "type": "str",
              "source": "evidence_source"
            },
            {
              "name": "to_node",
              "type": "str",
              "source": "evidence_target"
            },
            {
              "name": "dag",
              "type": "nx.DiGraph",
              "source": "evidence_dag"
            }
          ],
          "return_type": "Dict",
          "source_file": "dereck_beach.py"
        }
      },
      {
        "step": 3,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_identify_dependencies",
        "args": [
          {
            "name": "statement",
            "type": "Dict",
            "source": "evidence_statement"
          }
        ],
        "returns": {
          "type": "List[str]",
          "binding": "evidence_dependencies"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_identify_dependencies",
        "purpose": "Identify evidence dependencies",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "statement",
              "type": "Dict",
              "source": "evidence_statement"
            }
          ],
          "return_type": "List[str]",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 4,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "trace_numerical_chain",
        "args": [
          {
            "name": "claims",
            "type": "List[Dict]",
            "source": "numerical_evidence"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "numerical_trace"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "trace_numerical_chain",
        "purpose": "Trace chain of numerical evidence",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "claims",
              "type": "List[Dict]",
              "source": "numerical_evidence"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "emebedding_policy.py"
        }
      }
    ],
    "contributing_modules": [
      "contradiction_deteccion.py",
      "dereck_beach.py",
      "emebedding_policy.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "teoria_cambio",
    "evidence_types": [
      "causal_trace",
      "evidence_dependencies",
      "financial_trace",
      "numerical_trace"
    ],
    "aggregation_strategy": "traceability_synthesis",
    "confidence_threshold": 0.83,
    "total_steps": 4
  },
  "P4-D6-Q3": {
    "question_id": "P4-D6-Q3",
    "point": "P4",
    "dimension": "D6",
    "question_number": 3,
    "question_text": "Establish evidence traceability and linkages",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "trace_financial_flows",
        "args": [
          {
            "name": "allocations",
            "type": "List[Dict]",
            "source": "budget_allocations"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "financial_trace"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "trace_financial_flows",
        "purpose": "Trace financial evidence flows",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "allocations",
              "type": "List[Dict]",
              "source": "budget_allocations"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 2,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "trace_causal_pathway",
        "args": [
          {
            "name": "from_node",
            "type": "str",
            "source": "evidence_source"
          },
          {
            "name": "to_node",
            "type": "str",
            "source": "evidence_target"
          },
          {
            "name": "dag",
            "type": "nx.DiGraph",
            "source": "evidence_dag"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "causal_trace"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "trace_causal_pathway",
        "purpose": "Trace causal pathways in evidence",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "from_node",
              "type": "str",
              "source": "evidence_source"
            },
            {
              "name": "to_node",
              "type": "str",
              "source": "evidence_target"
            },
            {
              "name": "dag",
              "type": "nx.DiGraph",
              "source": "evidence_dag"
            }
          ],
          "return_type": "Dict",
          "source_file": "dereck_beach.py"
        }
      },
      {
        "step": 3,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_identify_dependencies",
        "args": [
          {
            "name": "statement",
            "type": "Dict",
            "source": "evidence_statement"
          }
        ],
        "returns": {
          "type": "List[str]",
          "binding": "evidence_dependencies"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_identify_dependencies",
        "purpose": "Identify evidence dependencies",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "statement",
              "type": "Dict",
              "source": "evidence_statement"
            }
          ],
          "return_type": "List[str]",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 4,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "trace_numerical_chain",
        "args": [
          {
            "name": "claims",
            "type": "List[Dict]",
            "source": "numerical_evidence"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "numerical_trace"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "trace_numerical_chain",
        "purpose": "Trace chain of numerical evidence",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "claims",
              "type": "List[Dict]",
              "source": "numerical_evidence"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "emebedding_policy.py"
        }
      }
    ],
    "contributing_modules": [
      "contradiction_deteccion.py",
      "dereck_beach.py",
      "emebedding_policy.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "teoria_cambio",
    "evidence_types": [
      "causal_trace",
      "evidence_dependencies",
      "financial_trace",
      "numerical_trace"
    ],
    "aggregation_strategy": "traceability_synthesis",
    "confidence_threshold": 0.83,
    "total_steps": 4
  },
  "P5-D6-Q3": {
    "question_id": "P5-D6-Q3",
    "point": "P5",
    "dimension": "D6",
    "question_number": 3,
    "question_text": "Establish evidence traceability and linkages",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "trace_financial_flows",
        "args": [
          {
            "name": "allocations",
            "type": "List[Dict]",
            "source": "budget_allocations"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "financial_trace"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "trace_financial_flows",
        "purpose": "Trace financial evidence flows",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "allocations",
              "type": "List[Dict]",
              "source": "budget_allocations"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 2,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "trace_causal_pathway",
        "args": [
          {
            "name": "from_node",
            "type": "str",
            "source": "evidence_source"
          },
          {
            "name": "to_node",
            "type": "str",
            "source": "evidence_target"
          },
          {
            "name": "dag",
            "type": "nx.DiGraph",
            "source": "evidence_dag"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "causal_trace"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "trace_causal_pathway",
        "purpose": "Trace causal pathways in evidence",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "from_node",
              "type": "str",
              "source": "evidence_source"
            },
            {
              "name": "to_node",
              "type": "str",
              "source": "evidence_target"
            },
            {
              "name": "dag",
              "type": "nx.DiGraph",
              "source": "evidence_dag"
            }
          ],
          "return_type": "Dict",
          "source_file": "dereck_beach.py"
        }
      },
      {
        "step": 3,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_identify_dependencies",
        "args": [
          {
            "name": "statement",
            "type": "Dict",
            "source": "evidence_statement"
          }
        ],
        "returns": {
          "type": "List[str]",
          "binding": "evidence_dependencies"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_identify_dependencies",
        "purpose": "Identify evidence dependencies",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "statement",
              "type": "Dict",
              "source": "evidence_statement"
            }
          ],
          "return_type": "List[str]",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 4,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "trace_numerical_chain",
        "args": [
          {
            "name": "claims",
            "type": "List[Dict]",
            "source": "numerical_evidence"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "numerical_trace"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "trace_numerical_chain",
        "purpose": "Trace chain of numerical evidence",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "claims",
              "type": "List[Dict]",
              "source": "numerical_evidence"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "emebedding_policy.py"
        }
      }
    ],
    "contributing_modules": [
      "contradiction_deteccion.py",
      "dereck_beach.py",
      "emebedding_policy.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "teoria_cambio",
    "evidence_types": [
      "causal_trace",
      "evidence_dependencies",
      "financial_trace",
      "numerical_trace"
    ],
    "aggregation_strategy": "traceability_synthesis",
    "confidence_threshold": 0.83,
    "total_steps": 4
  },
  "P6-D6-Q3": {
    "question_id": "P6-D6-Q3",
    "point": "P6",
    "dimension": "D6",
    "question_number": 3,
    "question_text": "Establish evidence traceability and linkages",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "trace_financial_flows",
        "args": [
          {
            "name": "allocations",
            "type": "List[Dict]",
            "source": "budget_allocations"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "financial_trace"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "trace_financial_flows",
        "purpose": "Trace financial evidence flows",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "allocations",
              "type": "List[Dict]",
              "source": "budget_allocations"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 2,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "trace_causal_pathway",
        "args": [
          {
            "name": "from_node",
            "type": "str",
            "source": "evidence_source"
          },
          {
            "name": "to_node",
            "type": "str",
            "source": "evidence_target"
          },
          {
            "name": "dag",
            "type": "nx.DiGraph",
            "source": "evidence_dag"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "causal_trace"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "trace_causal_pathway",
        "purpose": "Trace causal pathways in evidence",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "from_node",
              "type": "str",
              "source": "evidence_source"
            },
            {
              "name": "to_node",
              "type": "str",
              "source": "evidence_target"
            },
            {
              "name": "dag",
              "type": "nx.DiGraph",
              "source": "evidence_dag"
            }
          ],
          "return_type": "Dict",
          "source_file": "dereck_beach.py"
        }
      },
      {
        "step": 3,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_identify_dependencies",
        "args": [
          {
            "name": "statement",
            "type": "Dict",
            "source": "evidence_statement"
          }
        ],
        "returns": {
          "type": "List[str]",
          "binding": "evidence_dependencies"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_identify_dependencies",
        "purpose": "Identify evidence dependencies",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "statement",
              "type": "Dict",
              "source": "evidence_statement"
            }
          ],
          "return_type": "List[str]",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 4,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "trace_numerical_chain",
        "args": [
          {
            "name": "claims",
            "type": "List[Dict]",
            "source": "numerical_evidence"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "numerical_trace"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "trace_numerical_chain",
        "purpose": "Trace chain of numerical evidence",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "claims",
              "type": "List[Dict]",
              "source": "numerical_evidence"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "emebedding_policy.py"
        }
      }
    ],
    "contributing_modules": [
      "contradiction_deteccion.py",
      "dereck_beach.py",
      "emebedding_policy.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "teoria_cambio",
    "evidence_types": [
      "causal_trace",
      "evidence_dependencies",
      "financial_trace",
      "numerical_trace"
    ],
    "aggregation_strategy": "traceability_synthesis",
    "confidence_threshold": 0.83,
    "total_steps": 4
  },
  "P7-D6-Q3": {
    "question_id": "P7-D6-Q3",
    "point": "P7",
    "dimension": "D6",
    "question_number": 3,
    "question_text": "Establish evidence traceability and linkages",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "trace_financial_flows",
        "args": [
          {
            "name": "allocations",
            "type": "List[Dict]",
            "source": "budget_allocations"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "financial_trace"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "trace_financial_flows",
        "purpose": "Trace financial evidence flows",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "allocations",
              "type": "List[Dict]",
              "source": "budget_allocations"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 2,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "trace_causal_pathway",
        "args": [
          {
            "name": "from_node",
            "type": "str",
            "source": "evidence_source"
          },
          {
            "name": "to_node",
            "type": "str",
            "source": "evidence_target"
          },
          {
            "name": "dag",
            "type": "nx.DiGraph",
            "source": "evidence_dag"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "causal_trace"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "trace_causal_pathway",
        "purpose": "Trace causal pathways in evidence",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "from_node",
              "type": "str",
              "source": "evidence_source"
            },
            {
              "name": "to_node",
              "type": "str",
              "source": "evidence_target"
            },
            {
              "name": "dag",
              "type": "nx.DiGraph",
              "source": "evidence_dag"
            }
          ],
          "return_type": "Dict",
          "source_file": "dereck_beach.py"
        }
      },
      {
        "step": 3,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_identify_dependencies",
        "args": [
          {
            "name": "statement",
            "type": "Dict",
            "source": "evidence_statement"
          }
        ],
        "returns": {
          "type": "List[str]",
          "binding": "evidence_dependencies"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_identify_dependencies",
        "purpose": "Identify evidence dependencies",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "statement",
              "type": "Dict",
              "source": "evidence_statement"
            }
          ],
          "return_type": "List[str]",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 4,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "trace_numerical_chain",
        "args": [
          {
            "name": "claims",
            "type": "List[Dict]",
            "source": "numerical_evidence"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "numerical_trace"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "trace_numerical_chain",
        "purpose": "Trace chain of numerical evidence",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "claims",
              "type": "List[Dict]",
              "source": "numerical_evidence"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "emebedding_policy.py"
        }
      }
    ],
    "contributing_modules": [
      "contradiction_deteccion.py",
      "dereck_beach.py",
      "emebedding_policy.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "teoria_cambio",
    "evidence_types": [
      "causal_trace",
      "evidence_dependencies",
      "financial_trace",
      "numerical_trace"
    ],
    "aggregation_strategy": "traceability_synthesis",
    "confidence_threshold": 0.83,
    "total_steps": 4
  },
  "P8-D6-Q3": {
    "question_id": "P8-D6-Q3",
    "point": "P8",
    "dimension": "D6",
    "question_number": 3,
    "question_text": "Establish evidence traceability and linkages",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "trace_financial_flows",
        "args": [
          {
            "name": "allocations",
            "type": "List[Dict]",
            "source": "budget_allocations"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "financial_trace"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "trace_financial_flows",
        "purpose": "Trace financial evidence flows",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "allocations",
              "type": "List[Dict]",
              "source": "budget_allocations"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 2,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "trace_causal_pathway",
        "args": [
          {
            "name": "from_node",
            "type": "str",
            "source": "evidence_source"
          },
          {
            "name": "to_node",
            "type": "str",
            "source": "evidence_target"
          },
          {
            "name": "dag",
            "type": "nx.DiGraph",
            "source": "evidence_dag"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "causal_trace"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "trace_causal_pathway",
        "purpose": "Trace causal pathways in evidence",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "from_node",
              "type": "str",
              "source": "evidence_source"
            },
            {
              "name": "to_node",
              "type": "str",
              "source": "evidence_target"
            },
            {
              "name": "dag",
              "type": "nx.DiGraph",
              "source": "evidence_dag"
            }
          ],
          "return_type": "Dict",
          "source_file": "dereck_beach.py"
        }
      },
      {
        "step": 3,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_identify_dependencies",
        "args": [
          {
            "name": "statement",
            "type": "Dict",
            "source": "evidence_statement"
          }
        ],
        "returns": {
          "type": "List[str]",
          "binding": "evidence_dependencies"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_identify_dependencies",
        "purpose": "Identify evidence dependencies",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "statement",
              "type": "Dict",
              "source": "evidence_statement"
            }
          ],
          "return_type": "List[str]",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 4,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "trace_numerical_chain",
        "args": [
          {
            "name": "claims",
            "type": "List[Dict]",
            "source": "numerical_evidence"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "numerical_trace"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "trace_numerical_chain",
        "purpose": "Trace chain of numerical evidence",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "claims",
              "type": "List[Dict]",
              "source": "numerical_evidence"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "emebedding_policy.py"
        }
      }
    ],
    "contributing_modules": [
      "contradiction_deteccion.py",
      "dereck_beach.py",
      "emebedding_policy.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "teoria_cambio",
    "evidence_types": [
      "causal_trace",
      "evidence_dependencies",
      "financial_trace",
      "numerical_trace"
    ],
    "aggregation_strategy": "traceability_synthesis",
    "confidence_threshold": 0.83,
    "total_steps": 4
  },
  "P9-D6-Q3": {
    "question_id": "P9-D6-Q3",
    "point": "P9",
    "dimension": "D6",
    "question_number": 3,
    "question_text": "Establish evidence traceability and linkages",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "trace_financial_flows",
        "args": [
          {
            "name": "allocations",
            "type": "List[Dict]",
            "source": "budget_allocations"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "financial_trace"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "trace_financial_flows",
        "purpose": "Trace financial evidence flows",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "allocations",
              "type": "List[Dict]",
              "source": "budget_allocations"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 2,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "trace_causal_pathway",
        "args": [
          {
            "name": "from_node",
            "type": "str",
            "source": "evidence_source"
          },
          {
            "name": "to_node",
            "type": "str",
            "source": "evidence_target"
          },
          {
            "name": "dag",
            "type": "nx.DiGraph",
            "source": "evidence_dag"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "causal_trace"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "trace_causal_pathway",
        "purpose": "Trace causal pathways in evidence",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "from_node",
              "type": "str",
              "source": "evidence_source"
            },
            {
              "name": "to_node",
              "type": "str",
              "source": "evidence_target"
            },
            {
              "name": "dag",
              "type": "nx.DiGraph",
              "source": "evidence_dag"
            }
          ],
          "return_type": "Dict",
          "source_file": "dereck_beach.py"
        }
      },
      {
        "step": 3,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_identify_dependencies",
        "args": [
          {
            "name": "statement",
            "type": "Dict",
            "source": "evidence_statement"
          }
        ],
        "returns": {
          "type": "List[str]",
          "binding": "evidence_dependencies"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_identify_dependencies",
        "purpose": "Identify evidence dependencies",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "statement",
              "type": "Dict",
              "source": "evidence_statement"
            }
          ],
          "return_type": "List[str]",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 4,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "trace_numerical_chain",
        "args": [
          {
            "name": "claims",
            "type": "List[Dict]",
            "source": "numerical_evidence"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "numerical_trace"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "trace_numerical_chain",
        "purpose": "Trace chain of numerical evidence",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "claims",
              "type": "List[Dict]",
              "source": "numerical_evidence"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "emebedding_policy.py"
        }
      }
    ],
    "contributing_modules": [
      "contradiction_deteccion.py",
      "dereck_beach.py",
      "emebedding_policy.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "teoria_cambio",
    "evidence_types": [
      "causal_trace",
      "evidence_dependencies",
      "financial_trace",
      "numerical_trace"
    ],
    "aggregation_strategy": "traceability_synthesis",
    "confidence_threshold": 0.83,
    "total_steps": 4
  },
  "P10-D6-Q3": {
    "question_id": "P10-D6-Q3",
    "point": "P10",
    "dimension": "D6",
    "question_number": 3,
    "question_text": "Establish evidence traceability and linkages",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "trace_financial_flows",
        "args": [
          {
            "name": "allocations",
            "type": "List[Dict]",
            "source": "budget_allocations"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "financial_trace"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "trace_financial_flows",
        "purpose": "Trace financial evidence flows",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "allocations",
              "type": "List[Dict]",
              "source": "budget_allocations"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 2,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "trace_causal_pathway",
        "args": [
          {
            "name": "from_node",
            "type": "str",
            "source": "evidence_source"
          },
          {
            "name": "to_node",
            "type": "str",
            "source": "evidence_target"
          },
          {
            "name": "dag",
            "type": "nx.DiGraph",
            "source": "evidence_dag"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "causal_trace"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "trace_causal_pathway",
        "purpose": "Trace causal pathways in evidence",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "from_node",
              "type": "str",
              "source": "evidence_source"
            },
            {
              "name": "to_node",
              "type": "str",
              "source": "evidence_target"
            },
            {
              "name": "dag",
              "type": "nx.DiGraph",
              "source": "evidence_dag"
            }
          ],
          "return_type": "Dict",
          "source_file": "dereck_beach.py"
        }
      },
      {
        "step": 3,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_identify_dependencies",
        "args": [
          {
            "name": "statement",
            "type": "Dict",
            "source": "evidence_statement"
          }
        ],
        "returns": {
          "type": "List[str]",
          "binding": "evidence_dependencies"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_identify_dependencies",
        "purpose": "Identify evidence dependencies",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "statement",
              "type": "Dict",
              "source": "evidence_statement"
            }
          ],
          "return_type": "List[str]",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 4,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "trace_numerical_chain",
        "args": [
          {
            "name": "claims",
            "type": "List[Dict]",
            "source": "numerical_evidence"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "numerical_trace"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "trace_numerical_chain",
        "purpose": "Trace chain of numerical evidence",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "claims",
              "type": "List[Dict]",
              "source": "numerical_evidence"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "emebedding_policy.py"
        }
      }
    ],
    "contributing_modules": [
      "contradiction_deteccion.py",
      "dereck_beach.py",
      "emebedding_policy.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "teoria_cambio",
    "evidence_types": [
      "causal_trace",
      "evidence_dependencies",
      "financial_trace",
      "numerical_trace"
    ],
    "aggregation_strategy": "traceability_synthesis",
    "confidence_threshold": 0.83,
    "total_steps": 4
  },
  "P1-D6-Q4": {
    "question_id": "P1-D6-Q4",
    "point": "P1",
    "dimension": "D6",
    "question_number": 4,
    "question_text": "Validate evidence across multiple sources",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "detect",
        "args": [
          {
            "name": "document",
            "type": "str",
            "source": "normalized_text"
          },
          {
            "name": "metadata",
            "type": "dict",
            "value": {
              "analysis_type": "evidence_validation"
            }
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "evidence_contradictions"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "detect",
        "purpose": "Detect contradictions in evidence",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "document",
              "type": "str",
              "source": "normalized_text"
            },
            {
              "name": "metadata",
              "type": "dict",
              "value": {
                "analysis_type": "evidence_validation"
              }
            }
          ],
          "return_type": "Dict",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 2,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "triangulate_evidence",
        "args": [
          {
            "name": "sources",
            "type": "List[Dict]",
            "source": "evidence_sources"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "triangulated_evidence"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "triangulate_evidence",
        "purpose": "Triangulate evidence from multiple sources",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "sources",
              "type": "List[Dict]",
              "source": "evidence_sources"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 3,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "cross_validate_embeddings",
        "args": [
          {
            "name": "embeddings",
            "type": "List[np.ndarray]",
            "source": "evidence_embeddings"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "embedding_validation"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "cross_validate_embeddings",
        "purpose": "Cross-validate semantic embeddings",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "embeddings",
              "type": "List[np.ndarray]",
              "source": "evidence_embeddings"
            }
          ],
          "return_type": "Dict",
          "source_file": "emebedding_policy.py"
        }
      },
      {
        "step": 4,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "cross_validate_mechanisms",
        "args": [
          {
            "name": "mechanisms",
            "type": "List[Dict]",
            "source": "identified_mechanisms"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "mechanism_validation"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "cross_validate_mechanisms",
        "purpose": "Cross-validate causal mechanisms",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "mechanisms",
              "type": "List[Dict]",
              "source": "identified_mechanisms"
            }
          ],
          "return_type": "Dict",
          "source_file": "dereck_beach.py"
        }
      }
    ],
    "contributing_modules": [
      "contradiction_deteccion.py",
      "dereck_beach.py",
      "emebedding_policy.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "contradiction_detection",
    "evidence_types": [
      "embedding_validation",
      "evidence_contradictions",
      "mechanism_validation",
      "triangulated_evidence"
    ],
    "aggregation_strategy": "cross_validation_consensus",
    "confidence_threshold": 0.85,
    "total_steps": 4
  },
  "P2-D6-Q4": {
    "question_id": "P2-D6-Q4",
    "point": "P2",
    "dimension": "D6",
    "question_number": 4,
    "question_text": "Validate evidence across multiple sources",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "detect",
        "args": [
          {
            "name": "document",
            "type": "str",
            "source": "normalized_text"
          },
          {
            "name": "metadata",
            "type": "dict",
            "value": {
              "analysis_type": "evidence_validation"
            }
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "evidence_contradictions"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "detect",
        "purpose": "Detect contradictions in evidence",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "document",
              "type": "str",
              "source": "normalized_text"
            },
            {
              "name": "metadata",
              "type": "dict",
              "value": {
                "analysis_type": "evidence_validation"
              }
            }
          ],
          "return_type": "Dict",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 2,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "triangulate_evidence",
        "args": [
          {
            "name": "sources",
            "type": "List[Dict]",
            "source": "evidence_sources"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "triangulated_evidence"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "triangulate_evidence",
        "purpose": "Triangulate evidence from multiple sources",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "sources",
              "type": "List[Dict]",
              "source": "evidence_sources"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 3,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "cross_validate_embeddings",
        "args": [
          {
            "name": "embeddings",
            "type": "List[np.ndarray]",
            "source": "evidence_embeddings"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "embedding_validation"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "cross_validate_embeddings",
        "purpose": "Cross-validate semantic embeddings",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "embeddings",
              "type": "List[np.ndarray]",
              "source": "evidence_embeddings"
            }
          ],
          "return_type": "Dict",
          "source_file": "emebedding_policy.py"
        }
      },
      {
        "step": 4,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "cross_validate_mechanisms",
        "args": [
          {
            "name": "mechanisms",
            "type": "List[Dict]",
            "source": "identified_mechanisms"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "mechanism_validation"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "cross_validate_mechanisms",
        "purpose": "Cross-validate causal mechanisms",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "mechanisms",
              "type": "List[Dict]",
              "source": "identified_mechanisms"
            }
          ],
          "return_type": "Dict",
          "source_file": "dereck_beach.py"
        }
      }
    ],
    "contributing_modules": [
      "contradiction_deteccion.py",
      "dereck_beach.py",
      "emebedding_policy.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "contradiction_detection",
    "evidence_types": [
      "embedding_validation",
      "evidence_contradictions",
      "mechanism_validation",
      "triangulated_evidence"
    ],
    "aggregation_strategy": "cross_validation_consensus",
    "confidence_threshold": 0.85,
    "total_steps": 4
  },
  "P3-D6-Q4": {
    "question_id": "P3-D6-Q4",
    "point": "P3",
    "dimension": "D6",
    "question_number": 4,
    "question_text": "Validate evidence across multiple sources",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "detect",
        "args": [
          {
            "name": "document",
            "type": "str",
            "source": "normalized_text"
          },
          {
            "name": "metadata",
            "type": "dict",
            "value": {
              "analysis_type": "evidence_validation"
            }
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "evidence_contradictions"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "detect",
        "purpose": "Detect contradictions in evidence",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "document",
              "type": "str",
              "source": "normalized_text"
            },
            {
              "name": "metadata",
              "type": "dict",
              "value": {
                "analysis_type": "evidence_validation"
              }
            }
          ],
          "return_type": "Dict",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 2,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "triangulate_evidence",
        "args": [
          {
            "name": "sources",
            "type": "List[Dict]",
            "source": "evidence_sources"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "triangulated_evidence"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "triangulate_evidence",
        "purpose": "Triangulate evidence from multiple sources",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "sources",
              "type": "List[Dict]",
              "source": "evidence_sources"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 3,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "cross_validate_embeddings",
        "args": [
          {
            "name": "embeddings",
            "type": "List[np.ndarray]",
            "source": "evidence_embeddings"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "embedding_validation"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "cross_validate_embeddings",
        "purpose": "Cross-validate semantic embeddings",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "embeddings",
              "type": "List[np.ndarray]",
              "source": "evidence_embeddings"
            }
          ],
          "return_type": "Dict",
          "source_file": "emebedding_policy.py"
        }
      },
      {
        "step": 4,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "cross_validate_mechanisms",
        "args": [
          {
            "name": "mechanisms",
            "type": "List[Dict]",
            "source": "identified_mechanisms"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "mechanism_validation"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "cross_validate_mechanisms",
        "purpose": "Cross-validate causal mechanisms",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "mechanisms",
              "type": "List[Dict]",
              "source": "identified_mechanisms"
            }
          ],
          "return_type": "Dict",
          "source_file": "dereck_beach.py"
        }
      }
    ],
    "contributing_modules": [
      "contradiction_deteccion.py",
      "dereck_beach.py",
      "emebedding_policy.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "contradiction_detection",
    "evidence_types": [
      "embedding_validation",
      "evidence_contradictions",
      "mechanism_validation",
      "triangulated_evidence"
    ],
    "aggregation_strategy": "cross_validation_consensus",
    "confidence_threshold": 0.85,
    "total_steps": 4
  },
  "P4-D6-Q4": {
    "question_id": "P4-D6-Q4",
    "point": "P4",
    "dimension": "D6",
    "question_number": 4,
    "question_text": "Validate evidence across multiple sources",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "detect",
        "args": [
          {
            "name": "document",
            "type": "str",
            "source": "normalized_text"
          },
          {
            "name": "metadata",
            "type": "dict",
            "value": {
              "analysis_type": "evidence_validation"
            }
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "evidence_contradictions"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "detect",
        "purpose": "Detect contradictions in evidence",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "document",
              "type": "str",
              "source": "normalized_text"
            },
            {
              "name": "metadata",
              "type": "dict",
              "value": {
                "analysis_type": "evidence_validation"
              }
            }
          ],
          "return_type": "Dict",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 2,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "triangulate_evidence",
        "args": [
          {
            "name": "sources",
            "type": "List[Dict]",
            "source": "evidence_sources"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "triangulated_evidence"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "triangulate_evidence",
        "purpose": "Triangulate evidence from multiple sources",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "sources",
              "type": "List[Dict]",
              "source": "evidence_sources"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 3,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "cross_validate_embeddings",
        "args": [
          {
            "name": "embeddings",
            "type": "List[np.ndarray]",
            "source": "evidence_embeddings"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "embedding_validation"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "cross_validate_embeddings",
        "purpose": "Cross-validate semantic embeddings",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "embeddings",
              "type": "List[np.ndarray]",
              "source": "evidence_embeddings"
            }
          ],
          "return_type": "Dict",
          "source_file": "emebedding_policy.py"
        }
      },
      {
        "step": 4,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "cross_validate_mechanisms",
        "args": [
          {
            "name": "mechanisms",
            "type": "List[Dict]",
            "source": "identified_mechanisms"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "mechanism_validation"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "cross_validate_mechanisms",
        "purpose": "Cross-validate causal mechanisms",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "mechanisms",
              "type": "List[Dict]",
              "source": "identified_mechanisms"
            }
          ],
          "return_type": "Dict",
          "source_file": "dereck_beach.py"
        }
      }
    ],
    "contributing_modules": [
      "contradiction_deteccion.py",
      "dereck_beach.py",
      "emebedding_policy.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "contradiction_detection",
    "evidence_types": [
      "embedding_validation",
      "evidence_contradictions",
      "mechanism_validation",
      "triangulated_evidence"
    ],
    "aggregation_strategy": "cross_validation_consensus",
    "confidence_threshold": 0.85,
    "total_steps": 4
  },
  "P5-D6-Q4": {
    "question_id": "P5-D6-Q4",
    "point": "P5",
    "dimension": "D6",
    "question_number": 4,
    "question_text": "Validate evidence across multiple sources",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "detect",
        "args": [
          {
            "name": "document",
            "type": "str",
            "source": "normalized_text"
          },
          {
            "name": "metadata",
            "type": "dict",
            "value": {
              "analysis_type": "evidence_validation"
            }
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "evidence_contradictions"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "detect",
        "purpose": "Detect contradictions in evidence",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "document",
              "type": "str",
              "source": "normalized_text"
            },
            {
              "name": "metadata",
              "type": "dict",
              "value": {
                "analysis_type": "evidence_validation"
              }
            }
          ],
          "return_type": "Dict",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 2,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "triangulate_evidence",
        "args": [
          {
            "name": "sources",
            "type": "List[Dict]",
            "source": "evidence_sources"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "triangulated_evidence"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "triangulate_evidence",
        "purpose": "Triangulate evidence from multiple sources",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "sources",
              "type": "List[Dict]",
              "source": "evidence_sources"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 3,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "cross_validate_embeddings",
        "args": [
          {
            "name": "embeddings",
            "type": "List[np.ndarray]",
            "source": "evidence_embeddings"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "embedding_validation"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "cross_validate_embeddings",
        "purpose": "Cross-validate semantic embeddings",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "embeddings",
              "type": "List[np.ndarray]",
              "source": "evidence_embeddings"
            }
          ],
          "return_type": "Dict",
          "source_file": "emebedding_policy.py"
        }
      },
      {
        "step": 4,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "cross_validate_mechanisms",
        "args": [
          {
            "name": "mechanisms",
            "type": "List[Dict]",
            "source": "identified_mechanisms"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "mechanism_validation"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "cross_validate_mechanisms",
        "purpose": "Cross-validate causal mechanisms",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "mechanisms",
              "type": "List[Dict]",
              "source": "identified_mechanisms"
            }
          ],
          "return_type": "Dict",
          "source_file": "dereck_beach.py"
        }
      }
    ],
    "contributing_modules": [
      "contradiction_deteccion.py",
      "dereck_beach.py",
      "emebedding_policy.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "contradiction_detection",
    "evidence_types": [
      "embedding_validation",
      "evidence_contradictions",
      "mechanism_validation",
      "triangulated_evidence"
    ],
    "aggregation_strategy": "cross_validation_consensus",
    "confidence_threshold": 0.85,
    "total_steps": 4
  },
  "P6-D6-Q4": {
    "question_id": "P6-D6-Q4",
    "point": "P6",
    "dimension": "D6",
    "question_number": 4,
    "question_text": "Validate evidence across multiple sources",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "detect",
        "args": [
          {
            "name": "document",
            "type": "str",
            "source": "normalized_text"
          },
          {
            "name": "metadata",
            "type": "dict",
            "value": {
              "analysis_type": "evidence_validation"
            }
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "evidence_contradictions"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "detect",
        "purpose": "Detect contradictions in evidence",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "document",
              "type": "str",
              "source": "normalized_text"
            },
            {
              "name": "metadata",
              "type": "dict",
              "value": {
                "analysis_type": "evidence_validation"
              }
            }
          ],
          "return_type": "Dict",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 2,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "triangulate_evidence",
        "args": [
          {
            "name": "sources",
            "type": "List[Dict]",
            "source": "evidence_sources"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "triangulated_evidence"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "triangulate_evidence",
        "purpose": "Triangulate evidence from multiple sources",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "sources",
              "type": "List[Dict]",
              "source": "evidence_sources"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 3,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "cross_validate_embeddings",
        "args": [
          {
            "name": "embeddings",
            "type": "List[np.ndarray]",
            "source": "evidence_embeddings"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "embedding_validation"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "cross_validate_embeddings",
        "purpose": "Cross-validate semantic embeddings",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "embeddings",
              "type": "List[np.ndarray]",
              "source": "evidence_embeddings"
            }
          ],
          "return_type": "Dict",
          "source_file": "emebedding_policy.py"
        }
      },
      {
        "step": 4,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "cross_validate_mechanisms",
        "args": [
          {
            "name": "mechanisms",
            "type": "List[Dict]",
            "source": "identified_mechanisms"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "mechanism_validation"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "cross_validate_mechanisms",
        "purpose": "Cross-validate causal mechanisms",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "mechanisms",
              "type": "List[Dict]",
              "source": "identified_mechanisms"
            }
          ],
          "return_type": "Dict",
          "source_file": "dereck_beach.py"
        }
      }
    ],
    "contributing_modules": [
      "contradiction_deteccion.py",
      "dereck_beach.py",
      "emebedding_policy.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "contradiction_detection",
    "evidence_types": [
      "embedding_validation",
      "evidence_contradictions",
      "mechanism_validation",
      "triangulated_evidence"
    ],
    "aggregation_strategy": "cross_validation_consensus",
    "confidence_threshold": 0.85,
    "total_steps": 4
  },
  "P7-D6-Q4": {
    "question_id": "P7-D6-Q4",
    "point": "P7",
    "dimension": "D6",
    "question_number": 4,
    "question_text": "Validate evidence across multiple sources",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "detect",
        "args": [
          {
            "name": "document",
            "type": "str",
            "source": "normalized_text"
          },
          {
            "name": "metadata",
            "type": "dict",
            "value": {
              "analysis_type": "evidence_validation"
            }
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "evidence_contradictions"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "detect",
        "purpose": "Detect contradictions in evidence",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "document",
              "type": "str",
              "source": "normalized_text"
            },
            {
              "name": "metadata",
              "type": "dict",
              "value": {
                "analysis_type": "evidence_validation"
              }
            }
          ],
          "return_type": "Dict",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 2,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "triangulate_evidence",
        "args": [
          {
            "name": "sources",
            "type": "List[Dict]",
            "source": "evidence_sources"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "triangulated_evidence"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "triangulate_evidence",
        "purpose": "Triangulate evidence from multiple sources",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "sources",
              "type": "List[Dict]",
              "source": "evidence_sources"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 3,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "cross_validate_embeddings",
        "args": [
          {
            "name": "embeddings",
            "type": "List[np.ndarray]",
            "source": "evidence_embeddings"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "embedding_validation"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "cross_validate_embeddings",
        "purpose": "Cross-validate semantic embeddings",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "embeddings",
              "type": "List[np.ndarray]",
              "source": "evidence_embeddings"
            }
          ],
          "return_type": "Dict",
          "source_file": "emebedding_policy.py"
        }
      },
      {
        "step": 4,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "cross_validate_mechanisms",
        "args": [
          {
            "name": "mechanisms",
            "type": "List[Dict]",
            "source": "identified_mechanisms"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "mechanism_validation"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "cross_validate_mechanisms",
        "purpose": "Cross-validate causal mechanisms",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "mechanisms",
              "type": "List[Dict]",
              "source": "identified_mechanisms"
            }
          ],
          "return_type": "Dict",
          "source_file": "dereck_beach.py"
        }
      }
    ],
    "contributing_modules": [
      "contradiction_deteccion.py",
      "dereck_beach.py",
      "emebedding_policy.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "contradiction_detection",
    "evidence_types": [
      "embedding_validation",
      "evidence_contradictions",
      "mechanism_validation",
      "triangulated_evidence"
    ],
    "aggregation_strategy": "cross_validation_consensus",
    "confidence_threshold": 0.85,
    "total_steps": 4
  },
  "P8-D6-Q4": {
    "question_id": "P8-D6-Q4",
    "point": "P8",
    "dimension": "D6",
    "question_number": 4,
    "question_text": "Validate evidence across multiple sources",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "detect",
        "args": [
          {
            "name": "document",
            "type": "str",
            "source": "normalized_text"
          },
          {
            "name": "metadata",
            "type": "dict",
            "value": {
              "analysis_type": "evidence_validation"
            }
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "evidence_contradictions"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "detect",
        "purpose": "Detect contradictions in evidence",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "document",
              "type": "str",
              "source": "normalized_text"
            },
            {
              "name": "metadata",
              "type": "dict",
              "value": {
                "analysis_type": "evidence_validation"
              }
            }
          ],
          "return_type": "Dict",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 2,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "triangulate_evidence",
        "args": [
          {
            "name": "sources",
            "type": "List[Dict]",
            "source": "evidence_sources"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "triangulated_evidence"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "triangulate_evidence",
        "purpose": "Triangulate evidence from multiple sources",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "sources",
              "type": "List[Dict]",
              "source": "evidence_sources"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 3,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "cross_validate_embeddings",
        "args": [
          {
            "name": "embeddings",
            "type": "List[np.ndarray]",
            "source": "evidence_embeddings"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "embedding_validation"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "cross_validate_embeddings",
        "purpose": "Cross-validate semantic embeddings",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "embeddings",
              "type": "List[np.ndarray]",
              "source": "evidence_embeddings"
            }
          ],
          "return_type": "Dict",
          "source_file": "emebedding_policy.py"
        }
      },
      {
        "step": 4,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "cross_validate_mechanisms",
        "args": [
          {
            "name": "mechanisms",
            "type": "List[Dict]",
            "source": "identified_mechanisms"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "mechanism_validation"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "cross_validate_mechanisms",
        "purpose": "Cross-validate causal mechanisms",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "mechanisms",
              "type": "List[Dict]",
              "source": "identified_mechanisms"
            }
          ],
          "return_type": "Dict",
          "source_file": "dereck_beach.py"
        }
      }
    ],
    "contributing_modules": [
      "contradiction_deteccion.py",
      "dereck_beach.py",
      "emebedding_policy.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "contradiction_detection",
    "evidence_types": [
      "embedding_validation",
      "evidence_contradictions",
      "mechanism_validation",
      "triangulated_evidence"
    ],
    "aggregation_strategy": "cross_validation_consensus",
    "confidence_threshold": 0.85,
    "total_steps": 4
  },
  "P9-D6-Q4": {
    "question_id": "P9-D6-Q4",
    "point": "P9",
    "dimension": "D6",
    "question_number": 4,
    "question_text": "Validate evidence across multiple sources",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "detect",
        "args": [
          {
            "name": "document",
            "type": "str",
            "source": "normalized_text"
          },
          {
            "name": "metadata",
            "type": "dict",
            "value": {
              "analysis_type": "evidence_validation"
            }
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "evidence_contradictions"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "detect",
        "purpose": "Detect contradictions in evidence",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "document",
              "type": "str",
              "source": "normalized_text"
            },
            {
              "name": "metadata",
              "type": "dict",
              "value": {
                "analysis_type": "evidence_validation"
              }
            }
          ],
          "return_type": "Dict",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 2,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "triangulate_evidence",
        "args": [
          {
            "name": "sources",
            "type": "List[Dict]",
            "source": "evidence_sources"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "triangulated_evidence"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "triangulate_evidence",
        "purpose": "Triangulate evidence from multiple sources",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "sources",
              "type": "List[Dict]",
              "source": "evidence_sources"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 3,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "cross_validate_embeddings",
        "args": [
          {
            "name": "embeddings",
            "type": "List[np.ndarray]",
            "source": "evidence_embeddings"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "embedding_validation"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "cross_validate_embeddings",
        "purpose": "Cross-validate semantic embeddings",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "embeddings",
              "type": "List[np.ndarray]",
              "source": "evidence_embeddings"
            }
          ],
          "return_type": "Dict",
          "source_file": "emebedding_policy.py"
        }
      },
      {
        "step": 4,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "cross_validate_mechanisms",
        "args": [
          {
            "name": "mechanisms",
            "type": "List[Dict]",
            "source": "identified_mechanisms"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "mechanism_validation"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "cross_validate_mechanisms",
        "purpose": "Cross-validate causal mechanisms",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "mechanisms",
              "type": "List[Dict]",
              "source": "identified_mechanisms"
            }
          ],
          "return_type": "Dict",
          "source_file": "dereck_beach.py"
        }
      }
    ],
    "contributing_modules": [
      "contradiction_deteccion.py",
      "dereck_beach.py",
      "emebedding_policy.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "contradiction_detection",
    "evidence_types": [
      "embedding_validation",
      "evidence_contradictions",
      "mechanism_validation",
      "triangulated_evidence"
    ],
    "aggregation_strategy": "cross_validation_consensus",
    "confidence_threshold": 0.85,
    "total_steps": 4
  },
  "P10-D6-Q4": {
    "question_id": "P10-D6-Q4",
    "point": "P10",
    "dimension": "D6",
    "question_number": 4,
    "question_text": "Validate evidence across multiple sources",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "detect",
        "args": [
          {
            "name": "document",
            "type": "str",
            "source": "normalized_text"
          },
          {
            "name": "metadata",
            "type": "dict",
            "value": {
              "analysis_type": "evidence_validation"
            }
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "evidence_contradictions"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "detect",
        "purpose": "Detect contradictions in evidence",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "document",
              "type": "str",
              "source": "normalized_text"
            },
            {
              "name": "metadata",
              "type": "dict",
              "value": {
                "analysis_type": "evidence_validation"
              }
            }
          ],
          "return_type": "Dict",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 2,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "triangulate_evidence",
        "args": [
          {
            "name": "sources",
            "type": "List[Dict]",
            "source": "evidence_sources"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "triangulated_evidence"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "triangulate_evidence",
        "purpose": "Triangulate evidence from multiple sources",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "sources",
              "type": "List[Dict]",
              "source": "evidence_sources"
            }
          ],
          "return_type": "Dict",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 3,
        "adapter": "embedding_policy",
        "adapter_class": "EmbeddingPolicyAdapter",
        "method": "cross_validate_embeddings",
        "args": [
          {
            "name": "embeddings",
            "type": "List[np.ndarray]",
            "source": "evidence_embeddings"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "embedding_validation"
        },
        "source_module": "emebedding_policy.py",
        "source_class": "EmbeddingPolicyAdapter",
        "source_method": "cross_validate_embeddings",
        "purpose": "Cross-validate semantic embeddings",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "embeddings",
              "type": "List[np.ndarray]",
              "source": "evidence_embeddings"
            }
          ],
          "return_type": "Dict",
          "source_file": "emebedding_policy.py"
        }
      },
      {
        "step": 4,
        "adapter": "dereck_beach",
        "adapter_class": "DerekBeachAdapter",
        "method": "cross_validate_mechanisms",
        "args": [
          {
            "name": "mechanisms",
            "type": "List[Dict]",
            "source": "identified_mechanisms"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "mechanism_validation"
        },
        "source_module": "dereck_beach.py",
        "source_class": "DerekBeachAdapter",
        "source_method": "cross_validate_mechanisms",
        "purpose": "Cross-validate causal mechanisms",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "mechanisms",
              "type": "List[Dict]",
              "source": "identified_mechanisms"
            }
          ],
          "return_type": "Dict",
          "source_file": "dereck_beach.py"
        }
      }
    ],
    "contributing_modules": [
      "contradiction_deteccion.py",
      "dereck_beach.py",
      "emebedding_policy.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "contradiction_detection",
    "evidence_types": [
      "embedding_validation",
      "evidence_contradictions",
      "mechanism_validation",
      "triangulated_evidence"
    ],
    "aggregation_strategy": "cross_validation_consensus",
    "confidence_threshold": 0.85,
    "total_steps": 4
  },
  "P1-D6-Q5": {
    "question_id": "P1-D6-Q5",
    "point": "P1",
    "dimension": "D6",
    "question_number": 5,
    "question_text": "Generate evidence-based recommendations",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_generate_resolution_recommendations",
        "args": [
          {
            "name": "contradictions",
            "type": "List",
            "source": "identified_contradictions"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "resolution_recommendations"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_generate_resolution_recommendations",
        "purpose": "Generate recommendations to resolve contradictions",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [
            {
              "name": "contradictions",
              "type": "List",
              "source": "identified_contradictions"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 2,
        "adapter": "financial_viability",
        "adapter_class": "FinancialViabilityAdapter",
        "method": "generate_executive_report",
        "args": [
          {
            "name": "analysis_results",
            "type": "Dict",
            "source": "complete_analysis"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "executive_report"
        },
        "source_module": "financiero_viabilidad_tablas.py",
        "source_class": "FinancialViabilityAdapter",
        "source_method": "generate_executive_report",
        "purpose": "Generate executive report with recommendations",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "analysis_results",
              "type": "Dict",
              "source": "complete_analysis"
            }
          ],
          "return_type": "Dict",
          "source_file": "financiero_viabilidad_tablas.py"
        }
      },
      {
        "step": 3,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "generate_counterfactuals",
        "args": [
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "source": "evidence_dag"
          },
          {
            "name": "effects",
            "type": "List[Dict]",
            "source": "causal_effects"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "evidence_scenarios"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "generate_counterfactuals",
        "purpose": "Generate evidence-based counterfactual scenarios",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "graph",
              "type": "nx.DiGraph",
              "source": "evidence_dag"
            },
            {
              "name": "effects",
              "type": "List[Dict]",
              "source": "causal_effects"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 4,
        "adapter": "analyzer_one",
        "adapter_class": "AnalyzerOneAdapter",
        "method": "generate_recommendations",
        "args": [
          {
            "name": "analysis_results",
            "type": "Dict",
            "source": "complete_results"
          }
        ],
        "returns": {
          "type": "List[str]",
          "binding": "strategic_recommendations"
        },
        "source_module": "Analyzer_one.py",
        "source_class": "AnalyzerOneAdapter",
        "source_method": "generate_recommendations",
        "purpose": "Generate strategic recommendations",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "analysis_results",
              "type": "Dict",
              "source": "complete_results"
            }
          ],
          "return_type": "List[str]",
          "source_file": "Analyzer_one.py"
        }
      }
    ],
    "contributing_modules": [
      "Analyzer_one.py",
      "contradiction_deteccion.py",
      "financiero_viabilidad_tablas.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "contradiction_detection",
    "evidence_types": [
      "evidence_scenarios",
      "executive_report",
      "resolution_recommendations",
      "strategic_recommendations"
    ],
    "aggregation_strategy": "recommendation_synthesis",
    "confidence_threshold": 0.78,
    "total_steps": 4
  },
  "P2-D6-Q5": {
    "question_id": "P2-D6-Q5",
    "point": "P2",
    "dimension": "D6",
    "question_number": 5,
    "question_text": "Generate evidence-based recommendations",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_generate_resolution_recommendations",
        "args": [
          {
            "name": "contradictions",
            "type": "List",
            "source": "identified_contradictions"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "resolution_recommendations"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_generate_resolution_recommendations",
        "purpose": "Generate recommendations to resolve contradictions",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [
            {
              "name": "contradictions",
              "type": "List",
              "source": "identified_contradictions"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 2,
        "adapter": "financial_viability",
        "adapter_class": "FinancialViabilityAdapter",
        "method": "generate_executive_report",
        "args": [
          {
            "name": "analysis_results",
            "type": "Dict",
            "source": "complete_analysis"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "executive_report"
        },
        "source_module": "financiero_viabilidad_tablas.py",
        "source_class": "FinancialViabilityAdapter",
        "source_method": "generate_executive_report",
        "purpose": "Generate executive report with recommendations",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "analysis_results",
              "type": "Dict",
              "source": "complete_analysis"
            }
          ],
          "return_type": "Dict",
          "source_file": "financiero_viabilidad_tablas.py"
        }
      },
      {
        "step": 3,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "generate_counterfactuals",
        "args": [
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "source": "evidence_dag"
          },
          {
            "name": "effects",
            "type": "List[Dict]",
            "source": "causal_effects"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "evidence_scenarios"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "generate_counterfactuals",
        "purpose": "Generate evidence-based counterfactual scenarios",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "graph",
              "type": "nx.DiGraph",
              "source": "evidence_dag"
            },
            {
              "name": "effects",
              "type": "List[Dict]",
              "source": "causal_effects"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 4,
        "adapter": "analyzer_one",
        "adapter_class": "AnalyzerOneAdapter",
        "method": "generate_recommendations",
        "args": [
          {
            "name": "analysis_results",
            "type": "Dict",
            "source": "complete_results"
          }
        ],
        "returns": {
          "type": "List[str]",
          "binding": "strategic_recommendations"
        },
        "source_module": "Analyzer_one.py",
        "source_class": "AnalyzerOneAdapter",
        "source_method": "generate_recommendations",
        "purpose": "Generate strategic recommendations",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "analysis_results",
              "type": "Dict",
              "source": "complete_results"
            }
          ],
          "return_type": "List[str]",
          "source_file": "Analyzer_one.py"
        }
      }
    ],
    "contributing_modules": [
      "Analyzer_one.py",
      "contradiction_deteccion.py",
      "financiero_viabilidad_tablas.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "contradiction_detection",
    "evidence_types": [
      "evidence_scenarios",
      "executive_report",
      "resolution_recommendations",
      "strategic_recommendations"
    ],
    "aggregation_strategy": "recommendation_synthesis",
    "confidence_threshold": 0.78,
    "total_steps": 4
  },
  "P3-D6-Q5": {
    "question_id": "P3-D6-Q5",
    "point": "P3",
    "dimension": "D6",
    "question_number": 5,
    "question_text": "Generate evidence-based recommendations",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_generate_resolution_recommendations",
        "args": [
          {
            "name": "contradictions",
            "type": "List",
            "source": "identified_contradictions"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "resolution_recommendations"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_generate_resolution_recommendations",
        "purpose": "Generate recommendations to resolve contradictions",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [
            {
              "name": "contradictions",
              "type": "List",
              "source": "identified_contradictions"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 2,
        "adapter": "financial_viability",
        "adapter_class": "FinancialViabilityAdapter",
        "method": "generate_executive_report",
        "args": [
          {
            "name": "analysis_results",
            "type": "Dict",
            "source": "complete_analysis"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "executive_report"
        },
        "source_module": "financiero_viabilidad_tablas.py",
        "source_class": "FinancialViabilityAdapter",
        "source_method": "generate_executive_report",
        "purpose": "Generate executive report with recommendations",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "analysis_results",
              "type": "Dict",
              "source": "complete_analysis"
            }
          ],
          "return_type": "Dict",
          "source_file": "financiero_viabilidad_tablas.py"
        }
      },
      {
        "step": 3,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "generate_counterfactuals",
        "args": [
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "source": "evidence_dag"
          },
          {
            "name": "effects",
            "type": "List[Dict]",
            "source": "causal_effects"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "evidence_scenarios"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "generate_counterfactuals",
        "purpose": "Generate evidence-based counterfactual scenarios",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "graph",
              "type": "nx.DiGraph",
              "source": "evidence_dag"
            },
            {
              "name": "effects",
              "type": "List[Dict]",
              "source": "causal_effects"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 4,
        "adapter": "analyzer_one",
        "adapter_class": "AnalyzerOneAdapter",
        "method": "generate_recommendations",
        "args": [
          {
            "name": "analysis_results",
            "type": "Dict",
            "source": "complete_results"
          }
        ],
        "returns": {
          "type": "List[str]",
          "binding": "strategic_recommendations"
        },
        "source_module": "Analyzer_one.py",
        "source_class": "AnalyzerOneAdapter",
        "source_method": "generate_recommendations",
        "purpose": "Generate strategic recommendations",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "analysis_results",
              "type": "Dict",
              "source": "complete_results"
            }
          ],
          "return_type": "List[str]",
          "source_file": "Analyzer_one.py"
        }
      }
    ],
    "contributing_modules": [
      "Analyzer_one.py",
      "contradiction_deteccion.py",
      "financiero_viabilidad_tablas.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "contradiction_detection",
    "evidence_types": [
      "evidence_scenarios",
      "executive_report",
      "resolution_recommendations",
      "strategic_recommendations"
    ],
    "aggregation_strategy": "recommendation_synthesis",
    "confidence_threshold": 0.78,
    "total_steps": 4
  },
  "P4-D6-Q5": {
    "question_id": "P4-D6-Q5",
    "point": "P4",
    "dimension": "D6",
    "question_number": 5,
    "question_text": "Generate evidence-based recommendations",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_generate_resolution_recommendations",
        "args": [
          {
            "name": "contradictions",
            "type": "List",
            "source": "identified_contradictions"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "resolution_recommendations"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_generate_resolution_recommendations",
        "purpose": "Generate recommendations to resolve contradictions",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [
            {
              "name": "contradictions",
              "type": "List",
              "source": "identified_contradictions"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 2,
        "adapter": "financial_viability",
        "adapter_class": "FinancialViabilityAdapter",
        "method": "generate_executive_report",
        "args": [
          {
            "name": "analysis_results",
            "type": "Dict",
            "source": "complete_analysis"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "executive_report"
        },
        "source_module": "financiero_viabilidad_tablas.py",
        "source_class": "FinancialViabilityAdapter",
        "source_method": "generate_executive_report",
        "purpose": "Generate executive report with recommendations",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "analysis_results",
              "type": "Dict",
              "source": "complete_analysis"
            }
          ],
          "return_type": "Dict",
          "source_file": "financiero_viabilidad_tablas.py"
        }
      },
      {
        "step": 3,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "generate_counterfactuals",
        "args": [
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "source": "evidence_dag"
          },
          {
            "name": "effects",
            "type": "List[Dict]",
            "source": "causal_effects"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "evidence_scenarios"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "generate_counterfactuals",
        "purpose": "Generate evidence-based counterfactual scenarios",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "graph",
              "type": "nx.DiGraph",
              "source": "evidence_dag"
            },
            {
              "name": "effects",
              "type": "List[Dict]",
              "source": "causal_effects"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 4,
        "adapter": "analyzer_one",
        "adapter_class": "AnalyzerOneAdapter",
        "method": "generate_recommendations",
        "args": [
          {
            "name": "analysis_results",
            "type": "Dict",
            "source": "complete_results"
          }
        ],
        "returns": {
          "type": "List[str]",
          "binding": "strategic_recommendations"
        },
        "source_module": "Analyzer_one.py",
        "source_class": "AnalyzerOneAdapter",
        "source_method": "generate_recommendations",
        "purpose": "Generate strategic recommendations",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "analysis_results",
              "type": "Dict",
              "source": "complete_results"
            }
          ],
          "return_type": "List[str]",
          "source_file": "Analyzer_one.py"
        }
      }
    ],
    "contributing_modules": [
      "Analyzer_one.py",
      "contradiction_deteccion.py",
      "financiero_viabilidad_tablas.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "contradiction_detection",
    "evidence_types": [
      "evidence_scenarios",
      "executive_report",
      "resolution_recommendations",
      "strategic_recommendations"
    ],
    "aggregation_strategy": "recommendation_synthesis",
    "confidence_threshold": 0.78,
    "total_steps": 4
  },
  "P5-D6-Q5": {
    "question_id": "P5-D6-Q5",
    "point": "P5",
    "dimension": "D6",
    "question_number": 5,
    "question_text": "Generate evidence-based recommendations",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_generate_resolution_recommendations",
        "args": [
          {
            "name": "contradictions",
            "type": "List",
            "source": "identified_contradictions"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "resolution_recommendations"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_generate_resolution_recommendations",
        "purpose": "Generate recommendations to resolve contradictions",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [
            {
              "name": "contradictions",
              "type": "List",
              "source": "identified_contradictions"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 2,
        "adapter": "financial_viability",
        "adapter_class": "FinancialViabilityAdapter",
        "method": "generate_executive_report",
        "args": [
          {
            "name": "analysis_results",
            "type": "Dict",
            "source": "complete_analysis"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "executive_report"
        },
        "source_module": "financiero_viabilidad_tablas.py",
        "source_class": "FinancialViabilityAdapter",
        "source_method": "generate_executive_report",
        "purpose": "Generate executive report with recommendations",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "analysis_results",
              "type": "Dict",
              "source": "complete_analysis"
            }
          ],
          "return_type": "Dict",
          "source_file": "financiero_viabilidad_tablas.py"
        }
      },
      {
        "step": 3,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "generate_counterfactuals",
        "args": [
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "source": "evidence_dag"
          },
          {
            "name": "effects",
            "type": "List[Dict]",
            "source": "causal_effects"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "evidence_scenarios"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "generate_counterfactuals",
        "purpose": "Generate evidence-based counterfactual scenarios",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "graph",
              "type": "nx.DiGraph",
              "source": "evidence_dag"
            },
            {
              "name": "effects",
              "type": "List[Dict]",
              "source": "causal_effects"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 4,
        "adapter": "analyzer_one",
        "adapter_class": "AnalyzerOneAdapter",
        "method": "generate_recommendations",
        "args": [
          {
            "name": "analysis_results",
            "type": "Dict",
            "source": "complete_results"
          }
        ],
        "returns": {
          "type": "List[str]",
          "binding": "strategic_recommendations"
        },
        "source_module": "Analyzer_one.py",
        "source_class": "AnalyzerOneAdapter",
        "source_method": "generate_recommendations",
        "purpose": "Generate strategic recommendations",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "analysis_results",
              "type": "Dict",
              "source": "complete_results"
            }
          ],
          "return_type": "List[str]",
          "source_file": "Analyzer_one.py"
        }
      }
    ],
    "contributing_modules": [
      "Analyzer_one.py",
      "contradiction_deteccion.py",
      "financiero_viabilidad_tablas.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "contradiction_detection",
    "evidence_types": [
      "evidence_scenarios",
      "executive_report",
      "resolution_recommendations",
      "strategic_recommendations"
    ],
    "aggregation_strategy": "recommendation_synthesis",
    "confidence_threshold": 0.78,
    "total_steps": 4
  },
  "P6-D6-Q5": {
    "question_id": "P6-D6-Q5",
    "point": "P6",
    "dimension": "D6",
    "question_number": 5,
    "question_text": "Generate evidence-based recommendations",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_generate_resolution_recommendations",
        "args": [
          {
            "name": "contradictions",
            "type": "List",
            "source": "identified_contradictions"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "resolution_recommendations"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_generate_resolution_recommendations",
        "purpose": "Generate recommendations to resolve contradictions",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [
            {
              "name": "contradictions",
              "type": "List",
              "source": "identified_contradictions"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 2,
        "adapter": "financial_viability",
        "adapter_class": "FinancialViabilityAdapter",
        "method": "generate_executive_report",
        "args": [
          {
            "name": "analysis_results",
            "type": "Dict",
            "source": "complete_analysis"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "executive_report"
        },
        "source_module": "financiero_viabilidad_tablas.py",
        "source_class": "FinancialViabilityAdapter",
        "source_method": "generate_executive_report",
        "purpose": "Generate executive report with recommendations",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "analysis_results",
              "type": "Dict",
              "source": "complete_analysis"
            }
          ],
          "return_type": "Dict",
          "source_file": "financiero_viabilidad_tablas.py"
        }
      },
      {
        "step": 3,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "generate_counterfactuals",
        "args": [
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "source": "evidence_dag"
          },
          {
            "name": "effects",
            "type": "List[Dict]",
            "source": "causal_effects"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "evidence_scenarios"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "generate_counterfactuals",
        "purpose": "Generate evidence-based counterfactual scenarios",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "graph",
              "type": "nx.DiGraph",
              "source": "evidence_dag"
            },
            {
              "name": "effects",
              "type": "List[Dict]",
              "source": "causal_effects"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 4,
        "adapter": "analyzer_one",
        "adapter_class": "AnalyzerOneAdapter",
        "method": "generate_recommendations",
        "args": [
          {
            "name": "analysis_results",
            "type": "Dict",
            "source": "complete_results"
          }
        ],
        "returns": {
          "type": "List[str]",
          "binding": "strategic_recommendations"
        },
        "source_module": "Analyzer_one.py",
        "source_class": "AnalyzerOneAdapter",
        "source_method": "generate_recommendations",
        "purpose": "Generate strategic recommendations",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "analysis_results",
              "type": "Dict",
              "source": "complete_results"
            }
          ],
          "return_type": "List[str]",
          "source_file": "Analyzer_one.py"
        }
      }
    ],
    "contributing_modules": [
      "Analyzer_one.py",
      "contradiction_deteccion.py",
      "financiero_viabilidad_tablas.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "contradiction_detection",
    "evidence_types": [
      "evidence_scenarios",
      "executive_report",
      "resolution_recommendations",
      "strategic_recommendations"
    ],
    "aggregation_strategy": "recommendation_synthesis",
    "confidence_threshold": 0.78,
    "total_steps": 4
  },
  "P7-D6-Q5": {
    "question_id": "P7-D6-Q5",
    "point": "P7",
    "dimension": "D6",
    "question_number": 5,
    "question_text": "Generate evidence-based recommendations",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_generate_resolution_recommendations",
        "args": [
          {
            "name": "contradictions",
            "type": "List",
            "source": "identified_contradictions"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "resolution_recommendations"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_generate_resolution_recommendations",
        "purpose": "Generate recommendations to resolve contradictions",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [
            {
              "name": "contradictions",
              "type": "List",
              "source": "identified_contradictions"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 2,
        "adapter": "financial_viability",
        "adapter_class": "FinancialViabilityAdapter",
        "method": "generate_executive_report",
        "args": [
          {
            "name": "analysis_results",
            "type": "Dict",
            "source": "complete_analysis"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "executive_report"
        },
        "source_module": "financiero_viabilidad_tablas.py",
        "source_class": "FinancialViabilityAdapter",
        "source_method": "generate_executive_report",
        "purpose": "Generate executive report with recommendations",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "analysis_results",
              "type": "Dict",
              "source": "complete_analysis"
            }
          ],
          "return_type": "Dict",
          "source_file": "financiero_viabilidad_tablas.py"
        }
      },
      {
        "step": 3,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "generate_counterfactuals",
        "args": [
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "source": "evidence_dag"
          },
          {
            "name": "effects",
            "type": "List[Dict]",
            "source": "causal_effects"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "evidence_scenarios"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "generate_counterfactuals",
        "purpose": "Generate evidence-based counterfactual scenarios",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "graph",
              "type": "nx.DiGraph",
              "source": "evidence_dag"
            },
            {
              "name": "effects",
              "type": "List[Dict]",
              "source": "causal_effects"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 4,
        "adapter": "analyzer_one",
        "adapter_class": "AnalyzerOneAdapter",
        "method": "generate_recommendations",
        "args": [
          {
            "name": "analysis_results",
            "type": "Dict",
            "source": "complete_results"
          }
        ],
        "returns": {
          "type": "List[str]",
          "binding": "strategic_recommendations"
        },
        "source_module": "Analyzer_one.py",
        "source_class": "AnalyzerOneAdapter",
        "source_method": "generate_recommendations",
        "purpose": "Generate strategic recommendations",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "analysis_results",
              "type": "Dict",
              "source": "complete_results"
            }
          ],
          "return_type": "List[str]",
          "source_file": "Analyzer_one.py"
        }
      }
    ],
    "contributing_modules": [
      "Analyzer_one.py",
      "contradiction_deteccion.py",
      "financiero_viabilidad_tablas.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "contradiction_detection",
    "evidence_types": [
      "evidence_scenarios",
      "executive_report",
      "resolution_recommendations",
      "strategic_recommendations"
    ],
    "aggregation_strategy": "recommendation_synthesis",
    "confidence_threshold": 0.78,
    "total_steps": 4
  },
  "P8-D6-Q5": {
    "question_id": "P8-D6-Q5",
    "point": "P8",
    "dimension": "D6",
    "question_number": 5,
    "question_text": "Generate evidence-based recommendations",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_generate_resolution_recommendations",
        "args": [
          {
            "name": "contradictions",
            "type": "List",
            "source": "identified_contradictions"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "resolution_recommendations"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_generate_resolution_recommendations",
        "purpose": "Generate recommendations to resolve contradictions",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [
            {
              "name": "contradictions",
              "type": "List",
              "source": "identified_contradictions"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 2,
        "adapter": "financial_viability",
        "adapter_class": "FinancialViabilityAdapter",
        "method": "generate_executive_report",
        "args": [
          {
            "name": "analysis_results",
            "type": "Dict",
            "source": "complete_analysis"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "executive_report"
        },
        "source_module": "financiero_viabilidad_tablas.py",
        "source_class": "FinancialViabilityAdapter",
        "source_method": "generate_executive_report",
        "purpose": "Generate executive report with recommendations",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "analysis_results",
              "type": "Dict",
              "source": "complete_analysis"
            }
          ],
          "return_type": "Dict",
          "source_file": "financiero_viabilidad_tablas.py"
        }
      },
      {
        "step": 3,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "generate_counterfactuals",
        "args": [
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "source": "evidence_dag"
          },
          {
            "name": "effects",
            "type": "List[Dict]",
            "source": "causal_effects"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "evidence_scenarios"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "generate_counterfactuals",
        "purpose": "Generate evidence-based counterfactual scenarios",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "graph",
              "type": "nx.DiGraph",
              "source": "evidence_dag"
            },
            {
              "name": "effects",
              "type": "List[Dict]",
              "source": "causal_effects"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 4,
        "adapter": "analyzer_one",
        "adapter_class": "AnalyzerOneAdapter",
        "method": "generate_recommendations",
        "args": [
          {
            "name": "analysis_results",
            "type": "Dict",
            "source": "complete_results"
          }
        ],
        "returns": {
          "type": "List[str]",
          "binding": "strategic_recommendations"
        },
        "source_module": "Analyzer_one.py",
        "source_class": "AnalyzerOneAdapter",
        "source_method": "generate_recommendations",
        "purpose": "Generate strategic recommendations",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "analysis_results",
              "type": "Dict",
              "source": "complete_results"
            }
          ],
          "return_type": "List[str]",
          "source_file": "Analyzer_one.py"
        }
      }
    ],
    "contributing_modules": [
      "Analyzer_one.py",
      "contradiction_deteccion.py",
      "financiero_viabilidad_tablas.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "contradiction_detection",
    "evidence_types": [
      "evidence_scenarios",
      "executive_report",
      "resolution_recommendations",
      "strategic_recommendations"
    ],
    "aggregation_strategy": "recommendation_synthesis",
    "confidence_threshold": 0.78,
    "total_steps": 4
  },
  "P9-D6-Q5": {
    "question_id": "P9-D6-Q5",
    "point": "P9",
    "dimension": "D6",
    "question_number": 5,
    "question_text": "Generate evidence-based recommendations",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_generate_resolution_recommendations",
        "args": [
          {
            "name": "contradictions",
            "type": "List",
            "source": "identified_contradictions"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "resolution_recommendations"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_generate_resolution_recommendations",
        "purpose": "Generate recommendations to resolve contradictions",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [
            {
              "name": "contradictions",
              "type": "List",
              "source": "identified_contradictions"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 2,
        "adapter": "financial_viability",
        "adapter_class": "FinancialViabilityAdapter",
        "method": "generate_executive_report",
        "args": [
          {
            "name": "analysis_results",
            "type": "Dict",
            "source": "complete_analysis"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "executive_report"
        },
        "source_module": "financiero_viabilidad_tablas.py",
        "source_class": "FinancialViabilityAdapter",
        "source_method": "generate_executive_report",
        "purpose": "Generate executive report with recommendations",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "analysis_results",
              "type": "Dict",
              "source": "complete_analysis"
            }
          ],
          "return_type": "Dict",
          "source_file": "financiero_viabilidad_tablas.py"
        }
      },
      {
        "step": 3,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "generate_counterfactuals",
        "args": [
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "source": "evidence_dag"
          },
          {
            "name": "effects",
            "type": "List[Dict]",
            "source": "causal_effects"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "evidence_scenarios"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "generate_counterfactuals",
        "purpose": "Generate evidence-based counterfactual scenarios",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "graph",
              "type": "nx.DiGraph",
              "source": "evidence_dag"
            },
            {
              "name": "effects",
              "type": "List[Dict]",
              "source": "causal_effects"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 4,
        "adapter": "analyzer_one",
        "adapter_class": "AnalyzerOneAdapter",
        "method": "generate_recommendations",
        "args": [
          {
            "name": "analysis_results",
            "type": "Dict",
            "source": "complete_results"
          }
        ],
        "returns": {
          "type": "List[str]",
          "binding": "strategic_recommendations"
        },
        "source_module": "Analyzer_one.py",
        "source_class": "AnalyzerOneAdapter",
        "source_method": "generate_recommendations",
        "purpose": "Generate strategic recommendations",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "analysis_results",
              "type": "Dict",
              "source": "complete_results"
            }
          ],
          "return_type": "List[str]",
          "source_file": "Analyzer_one.py"
        }
      }
    ],
    "contributing_modules": [
      "Analyzer_one.py",
      "contradiction_deteccion.py",
      "financiero_viabilidad_tablas.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "contradiction_detection",
    "evidence_types": [
      "evidence_scenarios",
      "executive_report",
      "resolution_recommendations",
      "strategic_recommendations"
    ],
    "aggregation_strategy": "recommendation_synthesis",
    "confidence_threshold": 0.78,
    "total_steps": 4
  },
  "P10-D6-Q5": {
    "question_id": "P10-D6-Q5",
    "point": "P10",
    "dimension": "D6",
    "question_number": 5,
    "question_text": "Generate evidence-based recommendations",
    "execution_chain": [
      {
        "step": 1,
        "adapter": "contradiction_detection",
        "adapter_class": "ContradictionDetectionAdapter",
        "method": "_generate_resolution_recommendations",
        "args": [
          {
            "name": "contradictions",
            "type": "List",
            "source": "identified_contradictions"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "resolution_recommendations"
        },
        "source_module": "contradiction_deteccion.py",
        "source_class": "ContradictionDetectionAdapter",
        "source_method": "_generate_resolution_recommendations",
        "purpose": "Generate recommendations to resolve contradictions",
        "confidence_expected": 0.75,
        "signature": {
          "parameters": [
            {
              "name": "contradictions",
              "type": "List",
              "source": "identified_contradictions"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "contradiction_deteccion.py"
        }
      },
      {
        "step": 2,
        "adapter": "financial_viability",
        "adapter_class": "FinancialViabilityAdapter",
        "method": "generate_executive_report",
        "args": [
          {
            "name": "analysis_results",
            "type": "Dict",
            "source": "complete_analysis"
          }
        ],
        "returns": {
          "type": "Dict",
          "binding": "executive_report"
        },
        "source_module": "financiero_viabilidad_tablas.py",
        "source_class": "FinancialViabilityAdapter",
        "source_method": "generate_executive_report",
        "purpose": "Generate executive report with recommendations",
        "confidence_expected": 0.85,
        "signature": {
          "parameters": [
            {
              "name": "analysis_results",
              "type": "Dict",
              "source": "complete_analysis"
            }
          ],
          "return_type": "Dict",
          "source_file": "financiero_viabilidad_tablas.py"
        }
      },
      {
        "step": 3,
        "adapter": "teoria_cambio",
        "adapter_class": "ModulosAdapter",
        "method": "generate_counterfactuals",
        "args": [
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "source": "evidence_dag"
          },
          {
            "name": "effects",
            "type": "List[Dict]",
            "source": "causal_effects"
          }
        ],
        "returns": {
          "type": "List[Dict]",
          "binding": "evidence_scenarios"
        },
        "source_module": "teoria_cambio.py",
        "source_class": "ModulosAdapter",
        "source_method": "generate_counterfactuals",
        "purpose": "Generate evidence-based counterfactual scenarios",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "graph",
              "type": "nx.DiGraph",
              "source": "evidence_dag"
            },
            {
              "name": "effects",
              "type": "List[Dict]",
              "source": "causal_effects"
            }
          ],
          "return_type": "List[Dict]",
          "source_file": "teoria_cambio.py"
        }
      },
      {
        "step": 4,
        "adapter": "analyzer_one",
        "adapter_class": "AnalyzerOneAdapter",
        "method": "generate_recommendations",
        "args": [
          {
            "name": "analysis_results",
            "type": "Dict",
            "source": "complete_results"
          }
        ],
        "returns": {
          "type": "List[str]",
          "binding": "strategic_recommendations"
        },
        "source_module": "Analyzer_one.py",
        "source_class": "AnalyzerOneAdapter",
        "source_method": "generate_recommendations",
        "purpose": "Generate strategic recommendations",
        "confidence_expected": 0.8,
        "signature": {
          "parameters": [
            {
              "name": "analysis_results",
              "type": "Dict",
              "source": "complete_results"
            }
          ],
          "return_type": "List[str]",
          "source_file": "Analyzer_one.py"
        }
      }
    ],
    "contributing_modules": [
      "Analyzer_one.py",
      "contradiction_deteccion.py",
      "financiero_viabilidad_tablas.py",
      "teoria_cambio.py"
    ],
    "primary_adapter": "contradiction_detection",
    "evidence_types": [
      "evidence_scenarios",
      "executive_report",
      "resolution_recommendations",
      "strategic_recommendations"
    ],
    "aggregation_strategy": "recommendation_synthesis",
    "confidence_threshold": 0.78,
    "total_steps": 4
  }
}