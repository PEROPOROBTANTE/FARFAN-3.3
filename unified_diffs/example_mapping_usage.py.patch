diff --git a/example_mapping_usage.py b/example_mapping_usage.py
new file mode 100755
index 0000000..dd4b41e
--- /dev/null
+++ b/example_mapping_usage.py
@@ -0,0 +1,102 @@
+#!/usr/bin/env python3
+# example_mapping_usage.py - Example Usage of Mapping Loader
+"""
+Demonstrates how to integrate the mapping loader into FARFAN 3.0 application startup
+"""
+
+import sys
+import logging
+
+logging.basicConfig(
+    level=logging.INFO,
+    format='%(asctime)s [%(levelname)s] %(message)s'
+)
+
+logger = logging.getLogger(__name__)
+
+
+def main():
+    """Example: Validate mapping at application startup"""
+    
+    logger.info("FARFAN 3.0 - Application Startup with Mapping Validation")
+    logger.info("=" * 80)
+    
+    # Step 1: Import mapping validator
+    try:
+        from orchestrator.mapping_loader import (
+            MappingStartupValidator,
+            MappingValidationError
+        )
+        logger.info("✓ Imported mapping loader")
+    except ImportError as e:
+        logger.error(f"✗ Failed to import mapping loader: {e}")
+        logger.error("  Install dependencies: pip install pyyaml networkx")
+        return 1
+    
+    # Step 2: Validate execution mapping at startup (FAIL-FAST)
+    try:
+        logger.info("\nValidating execution mapping...")
+        loader = MappingStartupValidator.validate_at_startup()
+        
+        # If we get here, validation passed
+        logger.info("✓ Execution mapping is structurally sound")
+        
+        # Get statistics
+        stats = loader.get_statistics()
+        logger.info(f"\nMapping Statistics:")
+        logger.info(f"  Adapters: {stats['total_adapters']}")
+        logger.info(f"  Execution Chains: {stats['total_execution_chains']}")
+        logger.info(f"  Total Steps: {stats['total_steps']}")
+        logger.info(f"  Bindings: {stats['total_bindings']}")
+        
+        # Example: Query a specific execution chain
+        chain = loader.get_execution_chain("D1_INSUMOS.Q1_Baseline_Identification")
+        if chain:
+            logger.info(f"\nExample Chain: D1_INSUMOS.Q1_Baseline_Identification")
+            logger.info(f"  Steps: {len(chain['execution_chain'])}")
+            logger.info(f"  Aggregation: {chain['aggregation'].get('strategy', 'N/A')}")
+        
+        # Example: Get execution DAG
+        dag = loader.get_execution_dag("D1_INSUMOS.Q1_Baseline_Identification")
+        if dag:
+            logger.info(f"  DAG: {dag.number_of_nodes()} nodes, {dag.number_of_edges()} edges")
+        
+        logger.info("\n" + "=" * 80)
+        logger.info("✓ Application startup validation PASSED")
+        logger.info("  Ready to process policy documents...")
+        logger.info("=" * 80)
+        
+        # Now application can continue with normal startup...
+        # e.g., initialize orchestrator, load modules, etc.
+        
+        return 0
+        
+    except MappingValidationError as e:
+        logger.error("\n" + "!" * 80)
+        logger.error("✗ FATAL: Execution mapping validation FAILED")
+        logger.error("!" * 80)
+        logger.error("\nApplication cannot start due to structural errors in execution_mapping.yaml")
+        logger.error(f"\nDetected {len(e.conflicts)} conflict(s):")
+        
+        # Show first 3 conflicts with full diagnostics
+        for i, conflict in enumerate(e.conflicts[:3], 1):
+            logger.error(f"\n{i}. {str(conflict)}")
+        
+        if len(e.conflicts) > 3:
+            logger.error(f"\n... and {len(e.conflicts) - 3} more conflict(s)")
+        
+        logger.error("\n" + "!" * 80)
+        logger.error("REMEDIATION: Fix the conflicts above in execution_mapping.yaml")
+        logger.error("!" * 80)
+        
+        return 1
+    
+    except Exception as e:
+        logger.error(f"\n✗ Unexpected error during validation: {e}")
+        import traceback
+        traceback.print_exc()
+        return 1
+
+
+if __name__ == "__main__":
+    sys.exit(main())
