diff --git a/dependency_tracker.py b/dependency_tracker.py
new file mode 100644
index 0000000..e43cc8e
--- /dev/null
+++ b/dependency_tracker.py
@@ -0,0 +1,563 @@
+"""
+Dependency Tracking Framework - Static Analysis and Graph Construction
+========================================================================
+
+Parses Python AST to build a directed graph of all import statements and
+class/method references between orchestrator modules, main scripts, and adapters.
+
+Components:
+1. AST Parser - Extracts imports, class definitions, method calls
+2. Dependency Graph Builder - Constructs directed graph with metadata
+3. Call Site Analyzer - Tracks method signatures and call sites
+4. Graph Serialization - Stores/loads dependency graph baseline
+
+Author: FARFAN 3.0 Dev Team
+Version: 1.0.0
+Python: 3.10+
+"""
+
+import ast
+import json
+import logging
+from pathlib import Path
+from typing import Dict, List, Set, Any, Optional, Tuple
+from dataclasses import dataclass, field, asdict
+from collections import defaultdict
+import hashlib
+import inspect
+
+logger = logging.getLogger(__name__)
+
+
+@dataclass
+class CallSite:
+    """Represents a method call site with context"""
+    caller_file: str
+    caller_class: Optional[str]
+    caller_method: str
+    caller_line: int
+    callee_module: str
+    callee_class: Optional[str]
+    callee_method: str
+    args_signature: List[str]
+    kwargs_signature: List[str]
+    
+    def to_dict(self) -> Dict[str, Any]:
+        return asdict(self)
+
+
+@dataclass
+class MethodSignature:
+    """Represents a method signature"""
+    module: str
+    class_name: Optional[str]
+    method_name: str
+    args: List[str]
+    kwargs: List[str]
+    return_annotation: Optional[str]
+    decorators: List[str]
+    line_number: int
+    
+    def to_dict(self) -> Dict[str, Any]:
+        return asdict(self)
+    
+    def signature_hash(self) -> str:
+        """Compute hash of method signature for comparison"""
+        sig_str = f"{self.module}.{self.class_name or ''}.{self.method_name}({','.join(self.args)})"
+        return hashlib.sha256(sig_str.encode()).hexdigest()[:16]
+
+
+@dataclass
+class ImportStatement:
+    """Represents an import statement"""
+    importer_file: str
+    imported_module: str
+    imported_names: List[str]
+    is_from_import: bool
+    line_number: int
+    alias: Optional[str] = None
+    
+    def to_dict(self) -> Dict[str, Any]:
+        return asdict(self)
+
+
+@dataclass
+class DependencyEdge:
+    """Directed edge in dependency graph"""
+    source_file: str
+    target_file: str
+    edge_type: str
+    metadata: Dict[str, Any] = field(default_factory=dict)
+    
+    def to_dict(self) -> Dict[str, Any]:
+        return asdict(self)
+
+
+class ASTDependencyAnalyzer:
+    """
+    Analyzes Python AST to extract dependencies, imports, and method calls
+    """
+    
+    def __init__(self, project_root: Path):
+        self.project_root = project_root
+        self.imports: Dict[str, List[ImportStatement]] = defaultdict(list)
+        self.method_signatures: Dict[str, List[MethodSignature]] = defaultdict(list)
+        self.call_sites: Dict[str, List[CallSite]] = defaultdict(list)
+        self.class_definitions: Dict[str, List[str]] = defaultdict(list)
+        
+    def analyze_file(self, file_path: Path) -> None:
+        """Analyze a single Python file"""
+        try:
+            with open(file_path, 'r', encoding='utf-8') as f:
+                content = f.read()
+            
+            tree = ast.parse(content, filename=str(file_path))
+            relative_path = str(file_path.relative_to(self.project_root))
+            
+            visitor = DependencyVisitor(relative_path, self)
+            visitor.visit(tree)
+            
+            logger.debug(f"Analyzed {relative_path}: "
+                        f"{len(visitor.imports_found)} imports, "
+                        f"{len(visitor.methods_found)} methods, "
+                        f"{len(visitor.calls_found)} calls")
+            
+        except SyntaxError as e:
+            logger.warning(f"Syntax error in {file_path}: {e}")
+        except Exception as e:
+            logger.error(f"Error analyzing {file_path}: {e}")
+    
+    def analyze_project(self, exclude_dirs: Optional[Set[str]] = None) -> None:
+        """Analyze all Python files in project"""
+        if exclude_dirs is None:
+            exclude_dirs = {'venv', '.venv', '__pycache__', '.git', '.idea', 'build', 'dist'}
+        
+        python_files = []
+        for py_file in self.project_root.rglob('*.py'):
+            if not any(excluded in py_file.parts for excluded in exclude_dirs):
+                python_files.append(py_file)
+        
+        logger.info(f"Analyzing {len(python_files)} Python files...")
+        
+        for py_file in python_files:
+            self.analyze_file(py_file)
+        
+        logger.info(f"Analysis complete: "
+                   f"{sum(len(v) for v in self.imports.values())} imports, "
+                   f"{sum(len(v) for v in self.method_signatures.values())} method signatures, "
+                   f"{sum(len(v) for v in self.call_sites.values())} call sites")
+
+
+class DependencyVisitor(ast.NodeVisitor):
+    """AST visitor to extract dependencies"""
+    
+    def __init__(self, file_path: str, analyzer: ASTDependencyAnalyzer):
+        self.file_path = file_path
+        self.analyzer = analyzer
+        self.current_class: Optional[str] = None
+        self.current_method: Optional[str] = None
+        self.imports_found = []
+        self.methods_found = []
+        self.calls_found = []
+        
+    def visit_Import(self, node: ast.Import) -> None:
+        """Visit import statement"""
+        for alias in node.names:
+            import_stmt = ImportStatement(
+                importer_file=self.file_path,
+                imported_module=alias.name,
+                imported_names=[alias.name],
+                is_from_import=False,
+                line_number=node.lineno,
+                alias=alias.asname
+            )
+            self.analyzer.imports[self.file_path].append(import_stmt)
+            self.imports_found.append(import_stmt)
+        
+        self.generic_visit(node)
+    
+    def visit_ImportFrom(self, node: ast.ImportFrom) -> None:
+        """Visit from...import statement"""
+        if node.module:
+            imported_names = [alias.name for alias in node.names]
+            import_stmt = ImportStatement(
+                importer_file=self.file_path,
+                imported_module=node.module,
+                imported_names=imported_names,
+                is_from_import=True,
+                line_number=node.lineno
+            )
+            self.analyzer.imports[self.file_path].append(import_stmt)
+            self.imports_found.append(import_stmt)
+        
+        self.generic_visit(node)
+    
+    def visit_ClassDef(self, node: ast.ClassDef) -> None:
+        """Visit class definition"""
+        prev_class = self.current_class
+        self.current_class = node.name
+        
+        self.analyzer.class_definitions[self.file_path].append(node.name)
+        
+        self.generic_visit(node)
+        
+        self.current_class = prev_class
+    
+    def visit_FunctionDef(self, node: ast.FunctionDef) -> None:
+        """Visit function/method definition"""
+        prev_method = self.current_method
+        self.current_method = node.name
+        
+        args = []
+        kwargs = []
+        
+        for arg in node.args.args:
+            args.append(arg.arg)
+        
+        for arg in node.args.kwonlyargs:
+            kwargs.append(arg.arg)
+        
+        return_annotation = None
+        if node.returns:
+            return_annotation = ast.unparse(node.returns) if hasattr(ast, 'unparse') else None
+        
+        decorators = []
+        for dec in node.decorator_list:
+            if isinstance(dec, ast.Name):
+                decorators.append(dec.id)
+            elif isinstance(dec, ast.Call) and isinstance(dec.func, ast.Name):
+                decorators.append(dec.func.id)
+        
+        method_sig = MethodSignature(
+            module=self.file_path,
+            class_name=self.current_class,
+            method_name=node.name,
+            args=args,
+            kwargs=kwargs,
+            return_annotation=return_annotation,
+            decorators=decorators,
+            line_number=node.lineno
+        )
+        
+        self.analyzer.method_signatures[self.file_path].append(method_sig)
+        self.methods_found.append(method_sig)
+        
+        self.generic_visit(node)
+        
+        self.current_method = prev_method
+    
+    def visit_Call(self, node: ast.Call) -> None:
+        """Visit method/function call"""
+        callee_module = None
+        callee_class = None
+        callee_method = None
+        
+        if isinstance(node.func, ast.Name):
+            callee_method = node.func.id
+        
+        elif isinstance(node.func, ast.Attribute):
+            callee_method = node.func.attr
+            
+            if isinstance(node.func.value, ast.Name):
+                callee_module = node.func.value.id
+            elif isinstance(node.func.value, ast.Attribute):
+                if isinstance(node.func.value.value, ast.Name):
+                    callee_module = node.func.value.value.id
+                    callee_class = node.func.value.attr
+        
+        if callee_method:
+            args_sig = []
+            for arg in node.args:
+                if isinstance(arg, ast.Name):
+                    args_sig.append(arg.id)
+                else:
+                    args_sig.append(ast.unparse(arg) if hasattr(ast, 'unparse') else '<expr>')
+            
+            kwargs_sig = []
+            for kw in node.keywords:
+                if kw.arg:
+                    kwargs_sig.append(kw.arg)
+            
+            call_site = CallSite(
+                caller_file=self.file_path,
+                caller_class=self.current_class,
+                caller_method=self.current_method or '<module>',
+                caller_line=node.lineno,
+                callee_module=callee_module or '',
+                callee_class=callee_class,
+                callee_method=callee_method,
+                args_signature=args_sig,
+                kwargs_signature=kwargs_sig
+            )
+            
+            self.analyzer.call_sites[self.file_path].append(call_site)
+            self.calls_found.append(call_site)
+        
+        self.generic_visit(node)
+
+
+class DependencyGraph:
+    """
+    Directed graph of dependencies with metadata
+    """
+    
+    def __init__(self):
+        self.nodes: Set[str] = set()
+        self.edges: List[DependencyEdge] = []
+        self.adjacency: Dict[str, Set[str]] = defaultdict(set)
+        self.reverse_adjacency: Dict[str, Set[str]] = defaultdict(set)
+        self.method_signatures: Dict[str, List[MethodSignature]] = {}
+        self.call_sites: Dict[str, List[CallSite]] = {}
+        self.imports: Dict[str, List[ImportStatement]] = {}
+        
+    def add_node(self, file_path: str) -> None:
+        """Add a node (file) to the graph"""
+        self.nodes.add(file_path)
+    
+    def add_edge(self, source: str, target: str, edge_type: str, metadata: Optional[Dict] = None) -> None:
+        """Add a directed edge to the graph"""
+        self.add_node(source)
+        self.add_node(target)
+        
+        edge = DependencyEdge(
+            source_file=source,
+            target_file=target,
+            edge_type=edge_type,
+            metadata=metadata or {}
+        )
+        
+        self.edges.append(edge)
+        self.adjacency[source].add(target)
+        self.reverse_adjacency[target].add(source)
+    
+    def build_from_analyzer(self, analyzer: ASTDependencyAnalyzer) -> None:
+        """Build graph from AST analyzer results"""
+        logger.info("Building dependency graph...")
+        
+        self.method_signatures = dict(analyzer.method_signatures)
+        self.call_sites = dict(analyzer.call_sites)
+        self.imports = dict(analyzer.imports)
+        
+        for file_path in analyzer.imports:
+            self.add_node(file_path)
+        
+        for file_path, imports_list in analyzer.imports.items():
+            for imp in imports_list:
+                target_file = self._resolve_import_to_file(imp.imported_module, analyzer.project_root)
+                if target_file:
+                    self.add_edge(
+                        file_path,
+                        target_file,
+                        'import',
+                        {'imported_names': imp.imported_names, 'line': imp.line_number}
+                    )
+        
+        for file_path, calls_list in analyzer.call_sites.items():
+            for call in calls_list:
+                if call.callee_module:
+                    target_file = self._resolve_module_to_file(call.callee_module, analyzer.project_root)
+                    if target_file:
+                        self.add_edge(
+                            file_path,
+                            target_file,
+                            'method_call',
+                            {
+                                'callee_class': call.callee_class,
+                                'callee_method': call.callee_method,
+                                'line': call.caller_line,
+                                'caller_method': call.caller_method
+                            }
+                        )
+        
+        logger.info(f"Graph built: {len(self.nodes)} nodes, {len(self.edges)} edges")
+    
+    def _resolve_import_to_file(self, module_name: str, project_root: Path) -> Optional[str]:
+        """Resolve module name to file path"""
+        parts = module_name.split('.')
+        
+        potential_paths = [
+            project_root / '/'.join(parts + ['__init__.py']),
+            project_root / '/'.join(parts[:-1] + [parts[-1] + '.py']) if len(parts) > 0 else None,
+            project_root / (module_name.replace('.', '/') + '.py'),
+        ]
+        
+        for path in potential_paths:
+            if path and path.exists():
+                try:
+                    return str(path.relative_to(project_root))
+                except ValueError:
+                    continue
+        
+        return None
+    
+    def _resolve_module_to_file(self, module_name: str, project_root: Path) -> Optional[str]:
+        """Resolve module variable name to file path (heuristic)"""
+        return self._resolve_import_to_file(module_name, project_root)
+    
+    def get_dependencies(self, file_path: str) -> Set[str]:
+        """Get all files that file_path depends on"""
+        return self.adjacency.get(file_path, set())
+    
+    def get_dependents(self, file_path: str) -> Set[str]:
+        """Get all files that depend on file_path"""
+        return self.reverse_adjacency.get(file_path, set())
+    
+    def find_broken_references(self) -> List[Dict[str, Any]]:
+        """Find method calls that don't match any known signature"""
+        broken = []
+        
+        sig_index = {}
+        for file_path, signatures in self.method_signatures.items():
+            for sig in signatures:
+                key = f"{sig.class_name or ''}.{sig.method_name}"
+                if key not in sig_index:
+                    sig_index[key] = []
+                sig_index[key].append(sig)
+        
+        for file_path, calls_list in self.call_sites.items():
+            for call in calls_list:
+                key = f"{call.callee_class or ''}.{call.callee_method}"
+                
+                if key not in sig_index and call.callee_method not in ['__init__', '__str__', '__repr__']:
+                    broken.append({
+                        'type': 'missing_method',
+                        'caller_file': call.caller_file,
+                        'caller_line': call.caller_line,
+                        'callee_class': call.callee_class,
+                        'callee_method': call.callee_method,
+                        'message': f"Method {key} not found in any analyzed file"
+                    })
+        
+        return broken
+    
+    def find_orphaned_calls(self) -> List[Dict[str, Any]]:
+        """Find calls to methods in files not in the graph"""
+        orphaned = []
+        
+        for file_path, calls_list in self.call_sites.items():
+            for call in calls_list:
+                if call.callee_module:
+                    target_file = self._resolve_module_to_file(call.callee_module, Path.cwd())
+                    if target_file and target_file not in self.nodes:
+                        orphaned.append({
+                            'type': 'orphaned_call',
+                            'caller_file': call.caller_file,
+                            'caller_line': call.caller_line,
+                            'target_module': call.callee_module,
+                            'target_method': call.callee_method,
+                            'message': f"Call to method in unanalyzed module {call.callee_module}"
+                        })
+        
+        return orphaned
+    
+    def to_dict(self) -> Dict[str, Any]:
+        """Serialize graph to dictionary"""
+        return {
+            'nodes': list(self.nodes),
+            'edges': [edge.to_dict() for edge in self.edges],
+            'method_signatures': {
+                file: [sig.to_dict() for sig in sigs]
+                for file, sigs in self.method_signatures.items()
+            },
+            'call_sites': {
+                file: [call.to_dict() for call in calls]
+                for file, calls in self.call_sites.items()
+            },
+            'imports': {
+                file: [imp.to_dict() for imp in imports]
+                for file, imports in self.imports.items()
+            },
+            'metadata': {
+                'node_count': len(self.nodes),
+                'edge_count': len(self.edges),
+                'total_methods': sum(len(sigs) for sigs in self.method_signatures.values()),
+                'total_calls': sum(len(calls) for calls in self.call_sites.values())
+            }
+        }
+    
+    def save(self, file_path: Path) -> None:
+        """Save graph to JSON file"""
+        with open(file_path, 'w', encoding='utf-8') as f:
+            json.dump(self.to_dict(), f, indent=2)
+        logger.info(f"Dependency graph saved to {file_path}")
+    
+    @classmethod
+    def load(cls, file_path: Path) -> 'DependencyGraph':
+        """Load graph from JSON file"""
+        with open(file_path, 'r', encoding='utf-8') as f:
+            data = json.load(f)
+        
+        graph = cls()
+        
+        for node in data['nodes']:
+            graph.add_node(node)
+        
+        for edge_data in data['edges']:
+            graph.add_edge(
+                edge_data['source_file'],
+                edge_data['target_file'],
+                edge_data['edge_type'],
+                edge_data.get('metadata')
+            )
+        
+        graph.method_signatures = {
+            file: [MethodSignature(**sig) for sig in sigs]
+            for file, sigs in data.get('method_signatures', {}).items()
+        }
+        
+        graph.call_sites = {
+            file: [CallSite(**call) for call in calls]
+            for file, calls in data.get('call_sites', {}).items()
+        }
+        
+        graph.imports = {
+            file: [ImportStatement(**imp) for imp in imports]
+            for file, imports in data.get('imports', {}).items()
+        }
+        
+        logger.info(f"Dependency graph loaded from {file_path}")
+        return graph
+
+
+def build_dependency_graph(project_root: Path, output_file: Path) -> DependencyGraph:
+    """
+    Main entry point: Build dependency graph for entire project
+    """
+    logger.info(f"Building dependency graph for {project_root}")
+    
+    analyzer = ASTDependencyAnalyzer(project_root)
+    analyzer.analyze_project()
+    
+    graph = DependencyGraph()
+    graph.build_from_analyzer(analyzer)
+    
+    graph.save(output_file)
+    
+    return graph
+
+
+if __name__ == '__main__':
+    logging.basicConfig(level=logging.INFO)
+    
+    project_root = Path(__file__).parent
+    output_file = project_root / 'dependency_graph.json'
+    
+    graph = build_dependency_graph(project_root, output_file)
+    
+    print(f"\nDependency Graph Statistics:")
+    print(f"  Nodes (files): {len(graph.nodes)}")
+    print(f"  Edges: {len(graph.edges)}")
+    print(f"  Method signatures: {sum(len(sigs) for sigs in graph.method_signatures.values())}")
+    print(f"  Call sites: {sum(len(calls) for calls in graph.call_sites.values())}")
+    
+    broken = graph.find_broken_references()
+    if broken:
+        print(f"\n⚠️  Found {len(broken)} broken references:")
+        for item in broken[:5]:
+            print(f"  - {item['caller_file']}:{item['caller_line']} - {item['message']}")
+    
+    orphaned = graph.find_orphaned_calls()
+    if orphaned:
+        print(f"\n⚠️  Found {len(orphaned)} orphaned calls:")
+        for item in orphaned[:5]:
+            print(f"  - {item['caller_file']}:{item['caller_line']} - {item['message']}")
